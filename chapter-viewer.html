<!DOCTYPE html>
<html lang="en">
<head>
    <!-- START: Import Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;1,400&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- END: Import Google Fonts -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pyr Course Viewer</title>
    <!-- Using PDF.js v2.5.207 as base for rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.min.js"></script>
    <!-- Viewer script still used for SimpleLinkService and CSS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf_viewer.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf_viewer.css">
    <style>
:root{
    --accent:#f5a623; /* Amber/Orange */
    --fiery-orange: #f97316; /* Adjusted fiery orange */
    --lab-blue:#080e1c; /* Dark Navy Blue */
    --page:#fff;
    --text-on-dark:rgba(255,255,255,.9);
    --page-w:650px;
    --page-h:842px;
    --gradient-flame: linear-gradient(90deg, var(--fiery-orange), var(--accent), var(--fiery-orange)); /* Orange -> Amber -> Orange */
    --page-padding: 0.2px;
    --font-heading: 'Roboto', sans-serif;
    --font-body: 'Open Sans', sans-serif;
    /* Modern Font Stack */
    --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";

    /* Add these variables if not defined elsewhere, based on the time-capsule example */
    --gradient-time-capsule: linear-gradient(45deg, #f5a623, #f97316, #c553eb, #38bdf8); /* Example gradient */
    --radius-full: 50%; /* Define if not already defined */

    /* NEW: Parchment color */
    --parchment: #f5e8c7;
    --parchment-overlay: rgba(245, 232, 199, 0.85); /* Parchment with some transparency */

    /* NEW: Subtle pulse animation */
@keyframes pulseAnimation {
  0%, 100% { transform: translateX(-50%) scale(1); opacity: 1; }
  50% { transform: translateX(-50%) scale(1.03); opacity: 0.85; }
}

    /* NEW: LO Colors */
    --lo-greyed-out-filter: grayscale(100%);
    --lo-tooltip-bg: rgba(8, 14, 28, 0.95);
    /* --lo-popup-bg: rgba(28, 37, 54, 0.95); Replaced with white background below */
}
*{margin:0;padding:0;box-sizing:border-box}
body{
    font-family: var(--font-body); /* Use Open Sans as the default */
    background-color:var(--lab-blue);
    color:var(--text-on-dark);
    height:100vh; width:100vw;
    overflow:hidden; display:flex; flex-direction:column; position:fixed;
    line-height:1.6;
    -webkit-tap-highlight-color: transparent; /* Prevent tap highlight globally */
}
body::before{content:'';position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;background-image:radial-gradient(circle at 15% 15%,rgba(249,115,22,.12) 0,transparent 45%),radial-gradient(circle at 85% 85%,rgba(197,83,235,.12) 0,transparent 45%),radial-gradient(circle at 85% 15%,rgba(56,189,248,.05) 0,transparent 40%),radial-gradient(circle at 15% 85%,rgba(251,191,36,.08) 0,transparent 40%);animation:ambient-shift 30s ease infinite alternate}
@keyframes ambient-shift{0%{background-position:0 0,0 0,0 0,0 0}100%{background-position:5% 10%,-5% -5%,10% -5%,-10% 5%}}
@media (prefers-reduced-motion:reduce){body::before{animation:none!important}}

/* --- START: Toolbar & Slider Base Positioning (REVERTED CSS from old code for toolbar/trigger) --- */
#new-toolbar{
    position:fixed!important;
    top:15px!important; /* Position from top */
    right:-60px!important; /* Start hidden off-screen right */
    bottom: auto!important; /* Ensure bottom is not set */
    left: auto!important; /* Ensure left is not set */
    z-index:9999!important;
    display:flex!important;
    flex-direction:column!important; /* Vertical layout */
    gap:10px!important; /* KEEPING GAP AS IS - affects all buttons */
    transition:right .3s ease!important; /* Animate right property */
    background:rgba(28,37,54,.9)!important;
    backdrop-filter:blur(5px);
    -webkit-backdrop-filter:blur(5px);
    /* Adjusted top/bottom padding by 50% for the container (affects space above first & below last) */
    padding: 2.5px 5px !important;
    border-radius:8px 0 0 8px!important; /* Rounded corners on the left */
    box-shadow:-2px 2px 10px rgba(0,0,0,.4)!important;
    width:58px; /* Fixed width */
    height: auto!important; /* Height adjusts to content */
    border:1px solid rgba(255,255,255,.1);
    border-right: none!important; /* Border only on left/top/bottom */
}

.toolbar-trigger-area{ /* REVERTED: Trigger zone for hover from old code */
    position:fixed;
    top:0;
    right:0; /* Always on the right edge */
    width:30px;
    height:100%;
    z-index:9998;
    transition:none!important; /* No transition needed */
}
#new-toolbar.visible{
    right:0!important; /* Slide in from the right */
    transform:none!important; /* No translation needed */
}
/* --- END: Toolbar & Slider Base Positioning --- */

/* --- START: Rotation Block Indication --- */
@keyframes rotateButtonWiggleGlow {
  0%, 100% {
    transform: rotate(0deg);
    box-shadow: 0 0 8px rgba(245, 166, 35, 0); /* Transparent start/end */
    filter: drop-shadow(0 0 0px var(--accent));
  }
  25% {
    transform: rotate(-5deg);
    box-shadow: 0 0 15px 5px rgba(249, 115, 22, 0.7); /* Fiery orange glow */
    filter: drop-shadow(0 0 8px var(--fiery-orange));
  }
  50% {
    transform: rotate(5deg);
    box-shadow: 0 0 18px 6px rgba(245, 166, 35, 0.8); /* Accent glow */
     filter: drop-shadow(0 0 10px var(--accent));
  }
  75% {
    transform: rotate(-2deg);
    box-shadow: 0 0 15px 5px rgba(249, 115, 22, 0.7); /* Fiery orange glow */
    filter: drop-shadow(0 0 8px var(--fiery-orange));
  }
}

#return-view-fixed-btn.indicate-rotation-block {
  animation: rotateButtonWiggleGlow 0.6s ease-in-out 1; /* Apply animation once */
}
/* --- END: Rotation Block Indication --- */

        
/* Base button style (Keep New Code's Version) */
.new-btn{
    background:rgba(44,62,80,.8)!important;
    border:1px solid rgba(255,255,255,.15)!important;
    color:var(--text-on-dark)!important;
    width:48px!important;
    height:48px!important;
    border-radius:4px!important; /* Default rounded square */
    display:flex!important;
    align-items:center!important;
    justify-content:center!important;
    font-size:25px!important; /* Base font size for symbols */
    cursor:pointer!important;
    transition:all .2s!important;
    box-shadow:0 2px 5px rgba(0,0,0,.2)!important;
    user-select:none!important;
    flex-shrink:0;
    transform: rotate(0deg)!important; /* Ensure buttons are never rotated */
    padding: 0; /* Reset padding for icon centering */
    position: relative; /* Needed for pseudo-element positioning or stacking */
    overflow: visible; /* Allow hover effects like translate */
    /* z-index: 1; Needed by Time Capsule */
}
/* Ensure icons/text within buttons are centered */
.new-btn > *, .new-btn .icon {
    margin: 0; /* Remove default margins */
    line-height: 1; /* Helps vertical centering of text symbols */
    flex-shrink: 0; /* Prevent shrinking */
}
.new-btn .icon { /* Specific SVG icon styling */
    width: 24px; /* Default icon size */
    height: 24px;
    stroke-width: 1.5;
}

.new-btn:hover{
    background:rgba(52,73,94,.9)!important;
    border-color:rgba(255,255,255,.25)!important;
    box-shadow:0 2px 8px rgba(0,0,0,.3)!important;
    transform:translateY(-2px)!important; /* Keep vertical hover effect */
}
.new-btn:active{
    transform:translateY(1px)!important; /* Keep vertical active effect */
}
.new-btn[disabled]{opacity:.5;cursor:not-allowed;pointer-events:none}

/* Back Button Specific Styles - MODIFIED (Keep New Code's Version) */
#back-btn {
    background: none !important;
    border: none !important;
    box-shadow: none !important;
    font-size: 20px !important; /* Decreased font size */
    color: var(--text-on-dark) !important;
    /* Decreased width/height for smaller size */
    width: 36px !important;
    height: 36px !important;
    padding: 0 !important;
    /* Add negative margin to reduce space specifically around this button */
    /* 50% reduction of container padding (5px -> 2.5px) + 50% reduction of gap (10px -> 5px) */
    margin-top: -2.5px !important; /* Adjust space above */
    margin-bottom: -5px !important; /* Adjust space below (relative to gap) */
    /* Ensure flex alignment still works */
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    transition: color 0.2s, transform 0.2s !important;
}

#back-btn:hover {
    background: none !important;
    border: none !important;
    box-shadow: none !important;
    color: var(--accent) !important; /* Change color on hover */
    transform: translateX(-3px) !important; /* Move left slightly */
}
#back-btn:active {
    transform: translateX(0px) !important; /* Reset on active */
    color: var(--secondary) !important;
}


/* Time Capsule Button (Last button) (Keep New Code's Version) */
#time-capsule-btn {
    position: relative; /* Needed for pseudo-element */
    overflow: hidden; /* Clip pseudo-element */
    z-index: 1; /* Stacking context */
    border-radius: 50% !important; /* Make it a circle */
    padding: 0 !important; /* Ensure padding doesn't interfere */
    /* Inherits base .new-btn styles (size, flex centering, base bg/color) */
}

#time-capsule-btn::before {
    content: "";
    position: absolute;
    z-index: -1; /* Behind the button content */
    top: -3px; left: -3px; right: -3px; bottom: -3px; /* Offset for effect */
    background: var(--gradient-time-capsule); /* --- UNCHANGED: This gradient is used for initial state --- */
    background-size: 300% 300%;
    border-radius: 50%; /* Match button shape */
    filter: blur(3px); /* Initial blur */
    opacity: 0.35; /* Initial opacity */
    transition: opacity 0.4s ease-out, filter 0.4s ease-out;
    animation: hazyGradientAnimation 6s linear infinite; /* --- UNCHANGED: Button animation speed --- */
    pointer-events: none; /* Don't interfere with clicks */
}

/* Hover effects specific to Time Capsule button */
#time-capsule-btn:hover {
    /* Use standard .new-btn hover styles for consistency */
    background: rgba(52,73,94,.9) !important;
    border-color: rgba(255,255,255,.25) !important;
    box-shadow: 0 2px 8px rgba(0,0,0,.3) !important;
    transform: translateY(-2px) !important;
    color: var(--text-on-dark) !important; /* Keep icon color */
}

#time-capsule-btn:hover::before {
    opacity: 0.8; /* Increased opacity on hover */
    filter: blur(5px); /* Increased blur on hover */
}

/* Ensure icon/content inside Time Capsule button remains visible */
#time-capsule-btn .icon { /* Target the SVG icon */
    position: relative;
    z-index: 2; /* Above the ::before pseudo-element */
    margin: 0; /* Ensure no extra margin */
    /* Size and stroke-width inherited from .new-btn .icon */
    color: var(--text-on-dark) !important; /* Ensure correct color */
}

#time-capsule-btn:hover .icon {
    color: var(--text-on-dark) !important; /* Keep color on hover */
}


@keyframes hazyGradientAnimation { /* Ensure animation is defined */
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* --- START: MODIFIED SLIDER VISIBILITY/POSITIONING (Keep New Code's Version) --- */
.page-slider-container{
    position:fixed;
    bottom:-80px; /* Start hidden below */
    left:50%!important; /* Center horizontally */
    transform:translateX(-50%)!important; /* Precise horizontal centering */
    top: auto!important; /* Ensure top is not set */
    right: auto!important; /* Ensure right is not set */
    width:90%;
    max-width:700px;
    height: auto!important; /* Height adjusts */
    /* MODIFIED: Increased padding slightly for LO emojis */
    padding: 18px 20px 14px 20px;
    background:rgba(28,37,54,.9);
    backdrop-filter:blur(5px);
    -webkit-backdrop-filter:blur(5px);
    border:1px solid rgba(255,255,255,.1);
    border-bottom:none;
    box-shadow:0 -4px 20px rgba(0,0,0,.4);
    display:flex;
    flex-direction:column!important; /* Content flows vertically */
    align-items:center;
    z-index:9998;
    transition:bottom .35s cubic-bezier(.2,.9,.3,1)!important; /* Animate bottom property */
    border-radius:16px 16px 0 0; /* Rounded top corners */
    opacity: 0; /* Start fully transparent */
    visibility: hidden; /* Start hidden */
    pointer-events: none; /* Not interactive when hidden */
    transition: bottom .35s cubic-bezier(.2,.9,.3,1), opacity .35s ease-out, visibility 0s linear .35s !important; /* Add opacity/visibility transition */
}
.page-slider-container.visible{
    bottom:0!important; /* Slide up from bottom */
    opacity: 1; /* Fade in */
    visibility: visible; /* Become visible */
    pointer-events: auto; /* Become interactive */
    transition-delay: 0s, 0s, 0s !important; /* Reset transition delay for visibility */
}
#page-slider-trigger-zone { /* Trigger zone for slider */
    position: fixed;
    bottom: 0; /* At the bottom edge */
    left: 0;
    width: 100%;
    height: 30px; /* Height of the trigger area */
    z-index: 9997;
    pointer-events: auto; /* Must be interactive */
    cursor: pointer; /* Indicate it's interactive */
    /* background: rgba(255,0,0,0.1); */ /* DEBUG: Optional visual */
}
/* --- END: MODIFIED SLIDER VISIBILITY/POSITIONING --- */

/* MODIFIED: Ensure track container is relative for absolute positioning of milestones */
.page-slider-track{
    width:100%;
    margin-bottom:8px;
    padding:0 10px;
    position: relative; /* <-- ADDED for milestone positioning */
    height: 20px; /* <-- ADDED: Give track some explicit height for milestones */
    display: flex; /* <-- ADDED: Center the slider input within */
    align-items: center; /* <-- ADDED: Vertically center slider input */
}
.page-slider{
    width:100%!important; /* Full width */
    height:6px!important; /* Base height */
    -webkit-appearance:none!important;
    appearance:none!important;
    background:rgba(255,255,255,.1)!important; /* Base track color */
    outline:none;
    border-radius:3px!important;
    overflow:visible; /* Allow thumb to overflow slightly */
    cursor:pointer;
    transition:height .2s;
    writing-mode: horizontal-tb !important; /* Ensure horizontal */
    position: relative; /* Ensure slider is in stacking context */
    z-index: 1; /* Above milestones */
}
.page-slider:hover{height:8px}
.page-slider::-webkit-slider-thumb{
    -webkit-appearance:none!important;
    appearance:none!important;
    width:20px!important;height:20px!important; /* Thumb size */
    border-radius:50%!important;
    background:var(--accent)!important; /* Keep thumb the accent color for now */
    cursor:pointer;
    border:3px solid rgba(28,37,54,.9)!important;
    box-shadow:0 1px 6px rgba(0,0,0,.4)!important;
    transition:all .2s ease;
    margin-top:-7px!important; /* Vertical centering for horizontal slider */
    margin-left: 0 !important; /* No horizontal margin adjustment */
    position: relative; /* Ensure thumb is in stacking context */
    z-index: 4; /* Above slider track/milestones */
}
.page-slider:hover::-webkit-slider-thumb{width:24px!important;height:24px!important;margin-top:-8px!important}

/* --- START: MODIFIED SLIDER TRACK COLORS (Keep New Code's Version) --- */
.page-slider::-webkit-slider-runnable-track {
    width: 100% !important;
    height: 100% !important;
    /* Use multiple backgrounds for WebKit:
       1. The desired gradient for the filled portion, sized by --slider-percent.
       2. The standard empty track color underneath. */
    background-image: linear-gradient(to right, var(--fiery-orange), var(--accent)), /* Filled part gradient */
                      linear-gradient(to right, rgba(255, 255, 255, .1), rgba(255, 255, 255, .1)); /* Empty part color */
    background-size: var(--slider-percent, 0%) 100%, 100% 100%; /* Size gradient based on percent */
    background-repeat: no-repeat;
    border-radius: 3px !important;
    /* Explicitly set background color to transparent to avoid clash with background-image */
    background-color: transparent !important;
}

/* Firefox specific styles */
.page-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--accent); /* Keep thumb the accent color */
    cursor: pointer;
    border: 3px solid rgba(28, 37, 54, .9);
    box-shadow: 0 1px 6px rgba(0, 0, 0, .4);
    position: relative; /* Ensure thumb is in stacking context */
    z-index: 4; /* Above milestones */
}
.page-slider:hover::-moz-range-thumb {width: 24px; height: 24px;}
.page-slider::-moz-range-progress {
    /* Apply the desired gradient to the progress bar */
    background: linear-gradient(to right, var(--fiery-orange), var(--accent)) !important;
    height: 100%;
    border-radius: 3px;
}
.page-slider::-moz-range-track {
    /* Ensure the empty part of the track is the standard light color */
    background-color: rgba(255, 255, 255, .1) !important;
    height: 100%;
    border-radius: 3px;
}
/* --- END: MODIFIED SLIDER TRACK COLORS --- */

.page-slider-info{
    font-size:12px;
    font-family: var(--font-heading);
    color:var(--text-on-dark);
    font-weight:500;
    letter-spacing:.3px;
    opacity:.8;
    transform: rotate(0deg)!important; /* Ensure info text is never rotated */
    white-space: normal!important; /* Allow wrapping if needed */
    margin-bottom: 0 !important; /* Reset margin */
    padding-top: 0 !important; /* Reset padding */
    transition: opacity 0.25s ease-in-out;
}
/* --- END: Toolbar & Slider --- */


/* --- START: LO Milestone Styles --- */
.lo-milestone {
    position: absolute;
    top: 50%; /* Vertically center relative to track container */
    transform: translate(-50%, -50%); /* Center emoji on its position */
    font-size: 27px; /* Adjust size as needed */
    cursor: pointer;
    user-select: none;
    z-index: 3; /* Below slider thumb and above track progress gradient */
    opacity: var(--lo-greyed-out-opacity);
    filter: var(--lo-greyed-out-filter);
    transition: opacity 0.3s ease, filter 0.3s ease;
    will-change: opacity, filter; /* Optimize transitions */
}
.lo-milestone.lo-passed {
    opacity: 1;
    filter: none;
}
/* Style for temporary color on hover (greyed out state) */
.lo-milestone.hover-colored {
    opacity: 1;
    filter: none;
}
/* LO Tooltip */
/* Placeholder for #lo-tooltip styles if needed later */
#lo-tooltip {
    position: absolute; /* Positioned relative to milestones container? */
    /* Example styles - adjust as needed */
    background-color: var(--lo-tooltip-bg);
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 10000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0s linear 0.2s;
    pointer-events: none;
    transform: translateY(-100%); /* Position above the milestone */
}
#lo-tooltip.visible {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}
/* --- END: LO Milestone Styles --- */

/* --- START: LO Achievement Pop-up Styles (Updated Layout/Fonts) --- */
#lo-achievement-backdrop {
    position: fixed;
    inset: 0;
    background-color: rgba(8, 14, 28, 0.7);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    z-index: 10020;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
    cursor: pointer;
}
#lo-achievement-backdrop.visible {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}
#lo-achievement-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    width: 90%;
    max-width: 500px;
    background-color: #FFFFFF;
    color: #333333;
    border: 1px solid #ddd;
    border-radius: 10px;
    padding: 25px 30px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.2);
    z-index: 10021;
    opacity: 0;
    visibility: hidden;
    text-align: center;
    font-family: var(--font-body); /* Base font Open Sans */
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out, visibility 0s linear 0.3s;
}
#lo-achievement-popup.visible {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
    transition-delay: 0s;
}
#lo-achievement-popup h3 {
    font-family: var(--font-heading); /* Roboto */
    font-size: 1.45rem;
    margin-bottom: 15px; /* Increased margin slightly */
    color: #222;
    font-weight: 700;
}

/* Target the container paragraph for LO */
#lo-achievement-popup p#lo-achievement-text {
    margin-bottom: 15px;
    padding: 0;
    line-height: normal; /* Reset */
}

/* Style the Emoji Span */
#lo-achievement-text .lo-popup-emoji {
    display: block; /* Emoji on its own line */
    font-size: 5rem;  /* Larger emoji */
    line-height: 1;
    margin-bottom: 10px; /* Space below emoji */
}

/* Style the LO Text Span */
#lo-achievement-text .lo-popup-text {
    display: block; /* Keep as block */
    font-size: 1.0rem; /* <<< ADJUSTED: Slightly smaller font size */
    line-height: 1.5;
    /* --- Start: Gradient & Shimmer Styles --- */
    background: var(--gradient-flame); /* Apply the base gradient */
    background-size: 300% 100%; /* Make background wider than element */
    -webkit-background-clip: text; /* Clip background to text shape (WebKit) */
    background-clip: text;          /* Clip background to text shape (Standard) */
    color: transparent;             /* Make the text itself transparent */
    animation: shimmerText 2.5s infinite linear; /* Apply animation */
    /* --- End: Gradient & Shimmer Styles --- */
    /* Ensure text alignment works if needed (already centered by parent) */
    /* text-align: center; */ /* Likely not needed due to parent style */
    /* Add margin if needed to adjust spacing after font size change */
    margin-top: 5px; /* Optional: Adjust spacing if needed */
    margin-bottom: 5px; /* Optional: Adjust spacing if needed */
}

/* Style the strong tag within the LO Text */
#lo-achievement-text .lo-popup-text strong {
    font-weight: bold;
    color: #080e1c;
    text-decoration: underline; 
    text-decoration-color: #ffaa75; 
    text-decoration-thickness: 1.6px;
    line-height: 1.1;     
}


/* The "Teach it..." tip */
#lo-achievement-popup em#lo-achievement-tip {
    font-family: var(--font-body); /* Open Sans */
    display: block;
    font-size: 0.76rem; /* Smaller tip text */
    color: #666;
    margin-bottom: 20px;
    font-style: italic;
}

#lo-continue-btn {
    font-family: var(--font-heading); /* Roboto */
    padding: 10px 25px;
    font-size: 1rem;
    font-weight: bold;
    color: white;
    background: linear-gradient(135deg, var(--accent), var(--fiery-orange));
    border: none;
    border-radius: 20px;
    cursor: pointer;
    transition: background 0.2s ease, transform 0.1s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}
#lo-continue-btn:hover {
    background: linear-gradient(135deg, var(--fiery-orange), var(--accent));
    transform: scale(1.05);
}
#lo-continue-btn:active {
    transform: scale(0.98);
}
/* --- END: LO Achievement Pop-up Styles --- */


/* --- START: Left Toolbar for Timelock (REVERTED CSS from old code for toolbar/trigger) --- */
#left-toolbar {
    position: fixed !important;
    top: 15px !important; /* Align with right toolbar */
    left: -60px !important; /* Start hidden off-screen left */
    bottom: auto !important; /* Ensure bottom is not set */
    right: auto !important; /* Ensure right is not set */
    z-index: 9999 !important;
    display: flex !important;
    flex-direction: column !important; /* Vertical layout */
    gap: 10px !important; /* Standard gap */
    transition: left .3s ease !important; /* Animate left property */
    background: rgba(28, 37, 54, .9) !important;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    padding: 2.5px 5px !important; /* Consistent padding */
    border-radius: 0 8px 8px 0 !important; /* Rounded corners on the right */
    box-shadow: 2px 2px 10px rgba(0, 0, 0, .4) !important;
    width: 58px; /* Fixed width */
    height: auto !important; /* Height adjusts to content */
    border: 1px solid rgba(255, 255, 255, .1);
    border-left: none !important; /* Border only on right/top/bottom */
}

.left-toolbar-trigger-area { /* REVERTED: Trigger zone for hover from old code */
    position: fixed;
    top: 0;
    left: 0; /* Always on the left edge */
    width: 30px;
    height: 100%;
    z-index: 9998;
    transition: none !important; /* No transition needed */
}

#left-toolbar.visible {
    left: 0 !important; /* Slide in from the left */
    transform: none !important; /* No translation needed */
}

/* Specific styling for the timelock button (Keep New Code's Version - logic is identical) */
#timelock-toggle-btn {
    /* Inherits .new-btn styles */
}
#timelock-toggle-btn.timelock-on .icon-clock-on {
    display: block; /* Show the 'on' icon */
    stroke: var(--secondary); /* Greenish tint for 'on' */
}
#timelock-toggle-btn.timelock-on .icon-clock-off {
    display: none; /* Hide the 'off' icon */
}

#timelock-toggle-btn.timelock-off .icon-clock-on {
    display: none; /* Hide the 'on' icon */
}
#timelock-toggle-btn.timelock-off .icon-clock-off {
    display: block; /* Show the 'off' icon */
    stroke: var(--accent); /* Orange tint for 'off' */
}

/* --- END: Left Toolbar for Timelock --- */


/* Reader container (Keep New Code's Version) */
.main-container{
    flex:1;display:flex;justify-content:center!important;align-items:center!important;padding:0;height:100%;width:100%;overflow:hidden;position:relative;background:transparent;
    visibility: hidden;
    opacity: 0;
    transition: visibility 0s linear 0.3s, opacity 0.3s ease-in-out;
}
body:not(.loading-game-active) .main-container {
    visibility: visible;
    opacity: 1;
    transition-delay: 0s;
}


.book-spread{display:flex;box-shadow:0 10px 35px rgba(0,0,0,.5);position:fixed!important;top:50%!important;left:50%!important;transform-origin:center center;width:auto!important;height:auto!important;transition:transform .3s ease; transform: translate(-50%, -50%)}
.book-page{width:var(--page-w);height:var(--page-h);background-color:var(--page);position:relative;overflow:hidden; flex-shrink:0;display:flex;justify-content:center;align-items:center;border:1px solid rgba(255,255,255,.08);padding:0;}
.book-page.left{border-right:1px solid rgba(255,255,255,.15);border-radius:3px 0 0 3px}
.book-page.right{border-left:1px solid rgba(255,255,255,.15);border-radius:0 3px 3px 0}
.canvas-container {
    position: relative; /* Important for positioning layers */
    width: calc(100% - 2 * var(--page-padding));
    height: calc(100% - 2 * var(--page-padding));
    margin: var(--page-padding);
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden; /* Clip layers */
}
.pdf-canvas{max-width:100%;max-height:100%;display:block;object-fit:contain;box-shadow: none; position: absolute; top: 0; left: 0; z-index: 1; } /* Canvas layer */
.page-number{display:none}
.page-loading-overlay{position:absolute;inset:var(--page-padding);background:rgba(255,255,255,.6);z-index:50;display:none;justify-content:center;align-items:center;border-radius:3px}
.page-loading-spinner{width:32px;height:32px;border-radius:50%;border:3px solid rgba(0,0,0,.1);border-top-color:var(--primary);animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.page-edge-nav{position:absolute;top:0;height:100%;width:50px;cursor:pointer;z-index:10;transition:background-color .2s;-webkit-tap-highlight-color:transparent}
.page-edge-nav:hover{background-color:rgba(0,0,0,.03)}
.page-edge-left{left:0;border-radius:3px 0 0 3px}
.page-edge-right{right:0;border-radius:0 3px 3px 0}
.page-edge-left:hover::after,.page-edge-right:hover::after{content:"";position:absolute;top:50%;width:12px;height:12px;border-style:solid;border-color:rgba(0,0,0,.6);border-width:2px 2px 0 0;opacity:.8}
.page-edge-left:hover::after{left:18px;transform:translateY(-50%) rotate(-135deg)}
.page-edge-right:hover::after{right:18px;transform:translateY(-50%) rotate(45deg)}

/* --- START: Single Page Mode Styles Adjustment (Keep New Code's Version) --- */
.fullscreen-mode .book-page.right {
    display: none !important;
}
.fullscreen-mode .book-page.left { /* Ensure border/radius looks ok in single page */
    border-right: 1px solid rgba(255, 255, 255, .08) !important;
    border-radius: 3px !important;
}
.fullscreen-mode .canvas-container {
    margin: var(--page-padding);
}
.fullscreen-mode .pdf-canvas {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    position: absolute;
    z-index: 1;
}
/* --- END: Single Page Mode Styles Adjustment --- */

/* --- START: Content Rotated Mode Styles (Keep New Code's Version) --- */
/* Apply rotation transform in JS via applyCurrentViewModeStyles */
.content-rotated-mode .book-page.left{
    width:var(--page-w)!important; /* Use base dimensions for rotation calc */
    height:var(--page-h)!important;
    border-radius: 3px !important;
    border: 1px solid rgba(255, 255, 255, .08) !important;
    padding:0 !important;
    background-color:var(--page);
    display:flex!important; /* Ensure it's displayed */
    justify-content:center;align-items:center;
}
body.content-rotated-mode .page-edge-nav {
    display: none !important;
}
.content-rotated-mode .canvas-container {
    margin: 10px !important; /* Use consistent padding/margin */
    width: calc(100% - 20px);
    height: calc(100% - 20px);
}
.content-rotated-mode .book-page.right{
    display:none!important; /* Always hide right page when content is rotated */
}
.content-rotated-mode .pdf-canvas{
    box-shadow:none;
    max-width:100%;
    max-height:100%;
    object-fit:contain;
    position: relative;
    z-index: 1;
}
/* --- END: Content Rotated Mode Styles --- */


body:not(.fullscreen-mode):not(.content-rotated-mode) .book-page{width:var(--page-w);height:var(--page-h)} /* Default page size */
.book-page.right.placeholder-page{background-color:var(--page)!important;border-left:1px solid rgba(0,0,0,.1);position:relative;display:flex!important;justify-content:center;align-items:center}
.book-page.right.placeholder-page::after{content:"End of document";font-size:14px;font-style:italic;color:rgba(0,0,0,.5)}
.book-page.right.placeholder-page .canvas-container,.book-page.right.placeholder-page .page-edge-nav,.book-page.right.placeholder-page .page-loading-overlay,.book-page.right.placeholder-page .page-action-btn{display:none} /* Hide page action buttons on placeholder */

/* Gutter shadow effect only in double page view */
body:not(.fullscreen-mode):not(.content-rotated-mode) .book-page.right.placeholder-page { border-left: 1px solid rgba(0,0,0,.1) !important; }

/* --- START: REALISTIC VERTICAL CREASE EFFECT (Keep New Code's Version) --- */
body:not(.fullscreen-mode):not(.content-rotated-mode) .book-spread::before {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%; /* Center horizontally */
    width: 30px; /* Width of the crease effect */
    transform: translateX(-50%); /* Precise centering */
    background: linear-gradient(to right,
        rgba(0, 0, 0, 0.0) 0%,
        rgba(0, 0, 0, 0.12) 35%,
        rgba(0, 0, 0, 0.18) 50%,
        rgba(0, 0, 0, 0.12) 65%,
        rgba(0, 0, 0, 0.0) 100%
    );
    pointer-events: none; /* Doesn't interfere with mouse */
    z-index: 6; /* Position above page background, below other interactive elements */
    opacity: 1; /* Keep opacity at 1, control darkness via RGBA alpha values */
}
/* --- END: REALISTIC VERTICAL CREASE EFFECT --- */

/* --- START: Page Action Button Styles (e.g., Rotate) (MODIFIED) --- */
.page-action-btn { /* Base style for potential future page buttons */
    position: absolute;
    z-index: 20;
    background-color: rgba(44, 62, 80, 0.7);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    width: 36px; /* Base size */
    height: 36px;
    font-size: 20px; /* Base size */
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease, opacity 0.2s ease, pointer-events 0.2s ease; /* Added opacity/pointer-events transition */
    opacity: 0; /* Hidden by default */
    pointer-events: none; /* Not interactive by default */
    box-shadow: 0 1px 4px rgba(0,0,0,0.2);
}
.page-action-btn:hover {
    background-color: rgba(52, 73, 94, 0.9);
    transform: scale(1.1); /* Keep hover scale effect */
}

/* Specific styles for the Rotate button: Size and Position */
.page-rotate-btn {
    /* 70% size */
    width: 25px; /* 36 * 0.7 ~= 25 */
    height: 25px;
    font-size: 14px; /* 20 * 0.7 = 14 */
    /* Adjusted positioning */
    top: 5px;
    right: 5px;
}

/* NEW: Invisible trigger area for rotate button hover */
.page-rotate-hover-trigger {
    position: absolute;
    top: 0;
    right: 0;
    width: 25%;  /* Covers top-right quarter horizontally */
    height: 20%; /* Covers top half vertically */
    z-index: 19; /* Below button (z-index 20) */
    pointer-events: auto; /* Must capture hover */
}

/* NEW: Disable rotate hover trigger in single page (fullscreen) mode */
body.fullscreen-mode .page-rotate-hover-trigger {
    pointer-events: none; /* Makes the trigger area ignore mouse hover */
    /* Alternatively, you could use display: none; if you prefer */
    /* display: none; */
}

/* NEW: Show rotate button when trigger area is hovered */
/* Uses adjacent sibling selector (+) assuming trigger div is placed directly before the button in HTML */
.page-rotate-hover-trigger:hover + .page-rotate-btn {
    opacity: 1;
    pointer-events: auto;
}

/* Keep existing rules for hiding the button and trigger in specific modes */
body.loading-game-active .page-rotate-btn,
body.loading-game-active .page-rotate-hover-trigger { /* Also hide trigger */
     display: none !important;
}
body.content-rotated-mode .page-rotate-btn,
body.content-rotated-mode .page-rotate-hover-trigger { /* Also hide trigger */
    display: none !important;
}

/* NEW: Disable interaction with game iframe when Go To Chapter btn is visible */
body.loading-game-active #game-iframe.iframe-inactive {
    pointer-events: none;
    /* Optional: Add visual indication like slight opacity */
    /* opacity: 0.7; */
}
        
/* Hide trigger on placeholder page */
.book-page.placeholder-page .page-rotate-hover-trigger {
    display: none;
}
/* Note: .page-action-btn hiding on placeholder page is already handled by a separate rule below */
/* --- END: Page Action Button Styles --- */

/* --- START: Return from Rotated View Button (Keep New Code's Version) --- */
#return-view-fixed-btn {
    position: fixed !important;
    top: 15px !important;
    right: 15px !important;
    z-index: 10000 !important; /* Above most other UI */
    /* display: none; Set via class logic below */
    /* Inherits .new-btn styles */
}
/* Hide by default */
body:not(.content-rotated-mode) #return-view-fixed-btn {
    display: none !important;
}
/* Show only when in rotated mode */
body.content-rotated-mode #return-view-fixed-btn {
    display: flex !important; /* Use flex to ensure icon centers */
}
/* --- END: Return from Rotated View Button --- */


/* --- TOC, Loading, Text/Annotation Layers, Keywords (Keep New Code's Versions/Improvements) --- */
.loading-overlay{position:fixed;inset:0;background:rgba(8,14,28,.85);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);z-index:10001;display:none;justify-content:center;align-items:center;flex-direction:column}
.loading-overlay.visible { display: flex !important; } /* Added for JS helper */
.loading-spinner{width:50px;height:50px;border-radius:50%;border:4px solid rgba(255,255,255,.2);border-top-color:var(--accent);animation:spin 1s linear infinite;margin-bottom:15px}
.loading-message{font-size:16px;color:var(--text-on-dark)}
#status-indicator{display:none}
/* --- Base Text Layer (Hidden) & Annotation Layer Styles --- */
.textLayer { position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; opacity: 1; line-height: 1.0; color: transparent !important; user-select: none; -webkit-user-select: none; pointer-events: none !important; z-index: 2; }
.textLayer > div { position: absolute; white-space: pre; cursor: default; transform-origin: 0% 0%; pointer-events: none !important; border-radius: 2px; }
.annotationLayer { position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; pointer-events: none; z-index: 3; }
.annotationLayer section { position: absolute; pointer-events: auto; }
/* --- MODIFIED: Annotation Link Style --- */
.annotationLayer .linkAnnotation > a {
    position: absolute;
    font-size: 1em;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: 1px solid transparent;
    transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out;
    pointer-events: auto !important; /* Explicitly allow pointer events on the link itself */
    cursor: pointer;
}
.annotationLayer .linkAnnotation > a:hover {
    cursor: pointer;
    background-color: rgba(255, 255, 0, 0.2);
    border: 1px solid rgba(255, 255, 0, 0.5);
    box-shadow: 0px 0px 2px rgba(255, 255, 0, 0.5);
}
/* --- END: Custom Keyword Overlay & Popup Styles --- */
/* --- START: Custom Keyword Overlay & Popup Styles --- */
.keyword-overlay-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 21; overflow: hidden; }
.keyword-highlight { position: absolute; background: transparent; transition: background 0.2s ease-out, box-shadow 0.2s ease-out; pointer-events: auto; cursor: pointer; z-index: 5; box-sizing: border-box; border-radius: 3px; }
/* Hover effect still applies to ALL keyword highlights (when not in rotated mode) */
.keyword-highlight:hover { background: linear-gradient(to right, rgba(249, 115, 22, 0.25), rgba(251, 191, 36, 0.25)); box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }

/* --- START: MODIFIED UNDERLINE RULE --- */
/* Underline now ONLY applies if the 'first-keyword-instance' class is present */
.keyword-highlight.first-keyword-instance::after {
    content: '';
    position: absolute;
    left: 0;
    bottom: -2px; /* Position 2px below the highlight box */
    width: 100%; /* Takes the width of the correctly sized highlight box */
    height: 1.5px;  /* Make it slightly thicker but still subtle */
    background: linear-gradient(to right, var(--fiery-orange), var(--accent)); /* This is the target gradient */
    pointer-events: none; /* Prevent interaction with the line itself */
    min-height: 1px;
    border-radius: 1px; /* Slightly rounded ends */
    opacity: 0.54; /* UPDATED: Was 0.9, now 60% of that (0.9 * 0.6) */
    transition: opacity 0.2s ease-out; /* Allow transition if needed */
}
/* --- END: MODIFIED UNDERLINE RULE --- */

/* --- START: Disable Keyword Effects in Rotated Mode --- */
body.content-rotated-mode .keyword-highlight {
    pointer-events: none !important; /* Disable click and hover interactions */
    cursor: default; /* Remove pointer cursor */
}

body.content-rotated-mode .keyword-highlight.first-keyword-instance::after {
    display: none; /* Hide the underline */
    opacity: 0; /* Optionally transition out */
}
/* --- END: Disable Keyword Effects in Rotated Mode --- */

/* --- START: Replacement Keyword Popup CSS --- */ /* <<<< CONFIRMED: Correct Block Start */
#definition-popup {
    position: fixed;
    background: #ffffff;
    border-radius: 8px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15), 0 2px 5px rgba(0, 0, 0, 0.1);
    padding: 14px 18px;
    max-width: 320px;
    min-width: 180px;
    color: #2d3748;
    z-index: 10002;
    transform-origin: top center;
    transform: translateY(6px) scale(0.98);
    opacity: 0;
    visibility: hidden;
    transition: transform 0.18s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.18s cubic-bezier(0.4, 0, 0.2, 1), visibility 0s linear 0.18s;
    pointer-events: none;
    will-change: transform, opacity;
}
#definition-popup.visible {
    transform: translateY(0) scale(1);
    opacity: 1;
    visibility: visible;
    transition-delay: 0s, 0s, 0s;
    pointer-events: auto;
}

/* Style for the header containing keyword + PoS */
#popup-word {
    display: flex;
    justify-content: space-between; /* Push items apart */
    align-items: baseline;      /* Align text baselines */
    margin: 0 0 10px 0;
    border-bottom: 1px solid #e2e8f0;
    padding: 0 0 8px 0;
    font-family: var(--font-heading); /* Roboto */
    font-size: 15px;
    font-weight: 600;
}

/* Style for the keyword term itself */
#popup-word .keyword-term {
    color: #1c1e66; /* NEW Blue color */
    flex-grow: 1;      /* Allow it to take space */
    padding-right: 10px; /* Space before PoS */
}

/* Style for the Part of Speech */
#popup-word .part-of-speech {
    color: #f97315; /* Orange color */
    font-family: var(--font-heading); /* Roboto */
    font-size: 0.85em; /* Slightly smaller */
    font-weight: 400;  /* Normal weight */
    white-space: nowrap; /* Prevent wrapping */
    flex-shrink: 0;  /* Don't let it shrink */
    margin-left: 10px; /* Space from keyword */
}

/* Style for the definition text */
#popup-definition {
    font-family: var(--font-body); /* Open Sans */
    font-size: 14px;
    line-height: 1.6;
    max-height: 180px;
    overflow-y: auto;
    color: #4a5568;
    padding-right: 5px;
    margin-right: -5px;
}
#popup-definition::-webkit-scrollbar { width: 5px; }
#popup-definition::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px;}
#popup-definition::-webkit-scrollbar-thumb { background: #cbd5e0; border-radius: 3px;}
#popup-definition::-webkit-scrollbar-thumb:hover { background: #a0aec0; }


/* --- START: Loading Game Styles (MODIFIED) (Keep New Code's Version + Changes) --- */
#loading-game-container {
    position: fixed;
    inset: 0;
    z-index: 10000;
    background-color: var(--lab-blue);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
    opacity: 1;
    visibility: visible;
    padding-bottom: 80px; /* Add padding to avoid overlap with button */
}
body.loading-game-active #loading-game-container {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}
body:not(.loading-game-active) #loading-game-container {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
}

#game-iframe {
    width: 90%;
    max-width: 900px;
    height: 70vh;
    max-height: 400px;
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    background-color: var(--lab-blue); /* Use lab blue as placeholder */
    margin-bottom: 15px; /* Space between iframe and text */
}

/* REMOVED: Loading Bar Styles */
/* #game-loading-bar-container { ... } */
/* #game-loading-bar { ... } */

#iframe-loading-text {
    color: var(--text-on-dark);
    margin-top: 15px; /* Adjusted margin since bar is removed */
}

/* MODIFIED: Pop-up animation for Go To Chapter button */
@keyframes popUpBounce {
  0% { transform: translateX(-50%) scale(0.8); opacity: 0; } /* Start from hidden/scaled down state */
  60% { transform: translateX(-50%) scale(1.1); opacity: 1; }
  80% { transform: translateX(-50%) scale(0.95); }
  100% { transform: translateX(-50%) scale(1); opacity: 1; }
}

/* Base state - hidden, scaled down */
#go-to-chapter-btn {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) scale(0.8); /* Start scaled down for pop */
    z-index: 10001;
    padding: 12px 25px;
    font-size: 1.1rem;
    font-weight: bold;
    color: white;
    background: linear-gradient(135deg, var(--fiery-orange), var(--accent)); /* Default final background */
    border: none;
    border-radius: 25px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(255, 255, 255, 0.2) inset;
    opacity: 0; /* Start hidden */
    visibility: hidden;
    animation: none; /* No animation initially */
    transition: background-color 0.3s ease, background-image 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease, opacity 0.3s ease, visibility 0s linear 0.3s; /* Add transitions, ensure visibility transition matches opacity */
}

/* Loading state - visible, navy blue, normal size, no animation */
/* Apply pulse animation ONLY to the loading state */
#go-to-chapter-btn.loading-chapter {
    background-color: var(--lab-blue); /* Dark navy blue */
    background-image: none; /* Override gradient */
    color: var(--text-on-dark); /* White text */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4); /* Simpler shadow */
    opacity: 1; /* Make visible */
    visibility: visible;
    transform: translateX(-50%) scale(1); /* Visible at normal size */
    transition-delay: 0s; /* Ensure transitions apply immediately */
    /* ADDED THIS LINE TO APPLY ANIMATION: */
    animation: pulseAnimation 1.8s infinite ease-in-out;
}

/* Ensure the non-loading states don't have the pulse */
#go-to-chapter-btn:not(.loading-chapter) {
    animation: none; /* Remove pulse if not loading */
}
/* Re-apply pop animation for the .visible state (if not loading) */
#go-to-chapter-btn.visible:not(.loading-chapter) {
    /* Use popUpBounce or none if you don't want the pop */
    animation: popUpBounce 0.5s ease-out forwards;
}

/* Final visible state (triggered by adding .visible class) - animates in */
#go-to-chapter-btn.visible {
    opacity: 1; /* Ensure visible */
    visibility: visible;
    /* Apply the fun pop-up animation */
    animation: popUpBounce 0.5s ease-out forwards;
    /* Transform is handled by animation */
    transition-delay: 0s; /* Ensure transitions apply immediately */
}

/* Hover/Active for final state */
#go-to-chapter-btn.visible:hover { /* Target .visible specifically for hover */
    background: linear-gradient(135deg, var(--accent), var(--fiery-orange));
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 1px 4px rgba(255, 255, 255, 0.25) inset;
    /* Apply hover scale ON TOP of the final animation state */
    transform: translateX(-50%) scale(1.05);
}
#go-to-chapter-btn.visible:active { /* Target .visible specifically for active */
    /* Apply active scale ON TOP of the final animation state */
    transform: translateX(-50%) scale(0.98);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.15) inset;
}

/* Hover/Active for loading state */
#go-to-chapter-btn.loading-chapter:hover {
     background-color: #0b1221; /* Slightly lighter navy */
     transform: translateX(-50%) scale(1.03); /* Subtle hover */
 }
 #go-to-chapter-btn.loading-chapter:active {
     background-color: #060a14; /* Slightly darker navy */
     transform: translateX(-50%) scale(0.98); /* Subtle active */
 }

/* Initially hide reader elements when game is active */
body.loading-game-active #new-toolbar,
body.loading-game-active .toolbar-trigger-area,
body.loading-game-active #left-toolbar,
body.loading-game-active .left-toolbar-trigger-area,
body.loading-game-active #page-slider-container,
body.loading-game-active #page-slider-trigger-zone,
body.loading-game-active #definition-popup,
body.loading-game-active #iframe-popup-backdrop,
body.loading-game-active #iframe-popup-modal,
body.loading-game-active #notes-popup-backdrop,
body.loading-game-active #notes-popup-container,
body.loading-game-active .page-action-btn, /* Hide page action buttons */
body.loading-game-active .page-rotate-hover-trigger, /* Hide rotate button trigger */
body.loading-game-active #return-view-fixed-btn, /* Hide return view button */
body.loading-game-active #lo-tooltip, /* Hide LO tooltip */
body.loading-game-active #lo-achievement-backdrop, /* Hide LO popup */
body.loading-game-active #lo-achievement-popup /* Hide LO popup */
{
    display: none !important;
    visibility: hidden;
    opacity: 0;
}
/* --- END: Loading Game Styles --- */

/* --- START: Reading Time Alert (MODIFIED for Fade Down & Immediate Centering) (Keep New Code's Version) --- */
/* Fun wiggle animation (Shared - ensure translateX stays for centering) */
@keyframes wiggle {
  0%, 100% { transform: translateX(-50%) rotate(0deg); } /* Keep translateX for horizontal centering during animation */
  25% { transform: translateX(-50%) rotate(-3deg); }
  50% { transform: translateX(-50%) rotate(3deg); }
  75% { transform: translateX(-50%) rotate(-1deg); }
}

#reading-time-alert {
    position: fixed;
    bottom: 80px;
    left: 50%;
    /* MODIFIED: Start centered horizontally AND vertically in final position */
    transform: translateX(-50%) translateY(0); /* Changed translateY from 30px to 0 */
    background: rgba(44, 62, 80, 0.9);
    color: white;
    padding: 10px 20px;
    border-radius: 6px;
    z-index: 10005;
    font-family: var(--font-sans);
    font-size: 14px;
    font-weight: 500;
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
    opacity: 0; /* Start invisible */
    visibility: hidden; /* Start hidden */
    /* MODIFIED: Removed transform from transition */
    transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s; /* Removed 'transform 0.3s ease-in-out' */
    pointer-events: none;
    white-space: nowrap;
    animation: none; /* No animation by default */
}
#reading-time-alert.visible {
    opacity: 1; /* Fade in */
    visibility: visible; /* Become visible */
    /* Transform remains the same as base state now, ensuring it stays centered */
    transform: translateX(-50%) translateY(0);
    /* MODIFIED: Transition delay only needed for opacity/visibility now */
    transition-delay: 0s, 0s; /* Removed third delay for transform */
    /* Apply wiggle animation ONCE when it becomes visible */
    animation: wiggle 0.5s ease-in-out 1;
}
#reading-time-alert em {
    font-style: italic;
    font-weight: normal;
}
/* --- END: Reading Time Alert --- */


/* --- START: Iframe Popup Styles (MODIFIED) (Keep New Code's Version) --- */
#iframe-popup-backdrop {
    position: fixed;
    inset: 0;
    background-color: rgba(8, 14, 28, 0.7);
    backdrop-filter: blur(3.15px);
    -webkit-backdrop-filter: blur(3.15px);
    z-index: 10003;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.25s ease-out, visibility 0s linear 0.25s, backdrop-filter 0.25s ease-out; /* Added filter transition */
    cursor: pointer;
    overflow: hidden;
}
#iframe-popup-backdrop.visible { opacity: 1; visibility: visible; transition-delay: 0s; } /* Added */

/* Gradient overlay using ::before (MODIFIED for smoother animation) */
#iframe-popup-backdrop::before {
    content: "";
    position: absolute;
    inset: 0;
    background: var(--gradient-time-capsule);
    background-size: 300% 300%;
    opacity: 0; /* Start transparent */
    animation: hazyGradientAnimation 30s linear infinite;
    pointer-events: none;
    z-index: -1;
    /* MODIFIED: Delayed fade-in for the gradient */
    transition: opacity 0.4s ease-out 0.1s; /* Start 0.1s after backdrop, fade over 0.4s */
}
#iframe-popup-backdrop.visible::before {
    opacity: 0.35; /* Fade to target opacity */
}

#iframe-popup-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    width: 80%;
    height: 80%;
    max-width: 1000px;
    max-height: 700px;
    background-color: var(--page);
    border-radius: 8px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    z-index: 10004;
    opacity: 0;
    visibility: hidden;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1) 0.1s, opacity 0.45s ease-out 0.1s, visibility 0s linear 0.45s; /* Added 0.1s delay to transform/opacity, adjusted visibility delay */
}
#iframe-popup-modal.visible { /* Combined with backdrop rule above */
    opacity: 1;
    visibility: visible;
    transition-delay: 0s, 0s, 0s;
    transform: translate(-50%, -50%) scale(1);
}
#popup-iframe {
    flex-grow: 1;
    border: none;
    width: 100%;
    height: 100%;
}
#close-iframe-popup-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 32px;
    height: 32px;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    line-height: 1;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, transform 0.2s;
    z-index: 10005;
}
#close-iframe-popup-btn:hover {
    background-color: rgba(0, 0, 0, 0.7);
    transform: scale(1.1);
}
/* --- END: Iframe Popup Styles --- */

/* --- START: Notes Popup Styles (MODIFIED) (Keep New Code's Version) --- */
#notes-popup-backdrop {
    position: fixed;
    inset: 0;
    background-color: var(--parchment-overlay);
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px);
    z-index: 10010;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
    cursor: pointer;
}
#notes-popup-backdrop.visible { opacity: 1; visibility: visible; transition-delay: 0s; } /* Added */

/* Wiggle animation reused from Alert (modified to only rotate) */
/* MODIFIED Wiggle animation (Rely on external centering) */
@keyframes notes-wiggle { /* Renamed to avoid conflict if needed */
  0%, 100% { transform: rotate(0deg); }
  25% { transform: rotate(-3deg); }
  50% { transform: rotate(3deg); }
  75% { transform: rotate(-1deg); }
}

/* Subtle wiggle for the whole notes popup container */
@keyframes subtleWiggle {
  0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
  25% { transform: translate(calc(-50% - 2px), -50%) scale(1.01) rotate(-0.5deg); }
  50% { transform: translate(calc(-50% + 2px), -50%) scale(1.01) rotate(0.5deg); }
  75% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
}

#notes-popup-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    width: 90vw;
    height: 90vh;
    max-width: 700px;
    max-height: 900px;
    display: flex;
    flex-direction: column;
    align-items: center; /* Center children horizontally */
    justify-content: center; /* Center vertically (unless children push) */
    z-index: 10011;
    opacity: 0;
    visibility: hidden;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out, visibility 0s linear 0.3s;
    pointer-events: none;
    animation: none;
}
#notes-popup-container.visible { /* Combined with backdrop rule above */
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
    transform: translate(-50%, -50%) scale(1);
    pointer-events: auto;
    /* Apply subtle wiggle animation ONCE when container becomes visible */
    animation: subtleWiggle 0.4s ease-in-out 1 forwards;
}

#notes-pdf-canvas-container {
    width: 100%;
    height: calc(100% - 60px); /* Leave space for instruction */
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative; /* Needs to be relative for nav buttons */
    margin-bottom: 10px;
    pointer-events: auto;
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
    background-color: transparent; 
}

/* Styles for the local loader inside the notes canvas container */
.notes-local-loader {
    position: absolute; /* Center over the canvas area */
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10013; /* Above canvas, below nav buttons */
    display: flex; /* Use flex to align spinner and text */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: var(--text-on-dark);
    font-family: var(--font-sans);
    font-size: 14px;
    opacity: 0; /* Hidden by default */
    visibility: hidden;
    transition: opacity 0.2s ease-out, visibility 0s linear 0.2s;
    pointer-events: none; /* Don't block clicks when hidden */
    background: rgba(8, 14, 28, 0.8); /* Semi-transparent dark */
    padding: 20px;
    border-radius: 8px;
}
.notes-local-loader.visible { /* Show the loader */
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}
.notes-local-spinner {
    width: 32px; height: 32px;
    border-radius: 50%;
    border: 3px solid rgba(255, 255, 255, 0.2);
    border-top-color: var(--accent);
    animation: spin 1s linear infinite;
    margin-bottom: 10px; /* Space between spinner and text */
}
/* The span inside the loader */
.notes-local-loader span {
    font-weight: 500;
}


#notes-pdf-canvas {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    display: block;
    background-color: var(--page);
    opacity: 0; /* Start hidden */
    transition: opacity 0.3s ease-out; /* Transition for fade-in */
}

/* === START: Updated Notes Nav Button CSS === */

/* === START: Updated Notes Nav Button CSS (Adaptive) === */
.notes-nav-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background-color: rgba(44, 62, 80, 0.7);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    font-size: 28px;
    font-weight: bold;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    /* Base transitions */
    transition: background-color 0.2s, transform 0.2s, opacity 0.3s ease-out, visibility 0s linear 0s; /* Default immediate visibility change */
    opacity: 1; /* Start visible */
    visibility: visible; /* Start visible */
    z-index: 10014;
    pointer-events: auto;
    user-select: none;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    padding: 0;
    will-change: opacity, transform; /* Performance hint */
}

/* Positioning rules */
#notes-prev-btn { left: 10px; } /* Slightly more space */
#notes-next-btn { right: 10px; } /* Slightly more space */

/* Hover state - always forces visibility */
.notes-nav-btn:hover {
    background-color: rgba(52, 73, 94, 0.9);
    transform: translateY(-50%) scale(1.1);
    opacity: 1 !important; /* Override fade */
    visibility: visible !important; /* Ensure visible */
}

/* Active state */
.notes-nav-btn:active {
    transform: translateY(-50%) scale(1);
}

/* Disabled state */
.notes-nav-btn[disabled] {
    display: none; /* Hide the button completely */
}


/* --- Fading Logic (Only applies below breakpoint) --- */
@media (max-width: 768px) {
    /* Rule for the faded-out state ON SMALL SCREENS */
    .notes-nav-btn.notes-nav-faded {
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Prevent interaction when faded */
        /* Fade out quickly, hide visibility after fade */
        transition: background-color 0.2s, transform 0.2s, opacity 0.3s ease-out, visibility 0s linear 0.3s;
    }

    /* When NOT faded on small screens, ensure visibility transition allows instant show */
     .notes-nav-btn:not(.notes-nav-faded) {
        transition: background-color 0.2s, transform 0.2s, opacity 0.3s ease-out, visibility 0s linear 0s;
     }
}
/* --- END Fading Logic --- */

/* === END: Updated Notes Nav Button CSS === */

/* Positioning rules */
#notes-prev-btn {
    left: 5px;
}
#notes-next-btn {
    right: 5px;
}
/* === END: Updated Notes Nav Button CSS === */

/* MODIFIED Notes Instruction for better centering */
#notes-instruction {
    background-color: rgba(44, 62, 80, 0.9);
    color: var(--text-on-dark);
    padding: 8px 18px;
    border-radius: 20px;
    font-family: var(--font-sans);
    font-size: 13px;
    font-weight: 500;
    text-align: center; /* Center text inside */
    z-index: 10012;
    pointer-events: auto;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.15);
    margin-top: auto; /* Pushes to bottom of flex container */
    width: auto; /* Let content dictate width */
    max-width: 90%; /* Prevent overflow */
    /* Flex container handles horizontal centering, no translateX needed here */
    transform-origin: center center; /* For rotation animation */
    transform: scale(1); /* Base state, no scaling */
    animation: none; /* No animation by default */
}
/* Class added by JS after PDF load to trigger wiggle */
#notes-instruction.wiggle-now {
    /* Apply the modified wiggle animation (rotation only) */
    animation: notes-wiggle 0.5s ease-in-out 1; /* Use renamed animation */
}
/* --- END: Notes Popup Styles --- */

/* === START: Floating Toolbar Handle Styles === */

/* Define class to add to BODY when handles should float */
/* We'll primarily use classes on the toolbars themselves,
   but body classes can be useful for hiding triggers */
.right-handle-floated #new-toolbar.visible,
.left-handle-floated #left-toolbar.visible {
  /* Keep toolbar visible if user explicitly clicked the floated handle */
  /* But the handle itself remains floated */
}

/* OPTIONAL: Hide the original hover trigger areas when handles are floated */
body.right-handle-floated .toolbar-trigger-area {
   /* display: none; */ /* Uncomment if hover area causes issues */
   pointer-events: none; /* Safer than display:none */
   /* background: rgba(0,255,0,0.1); */ /* Debug */
}
 body.left-handle-floated .left-toolbar-trigger-area {
   /* display: none; */ /* Uncomment if hover area causes issues */
   pointer-events: none; /* Safer than display:none */
   /* background: rgba(0,0,255,0.1); */ /* Debug */
}

/* Ensure original handles have transition too */
#new-toolbar::before,
#left-toolbar::before {
    transition: all 0.3s ease-in-out;
}

/* === END: Floating Toolbar Handle Styles === */

/* --- Hover Glow Effect for Toolbar Triggers --- */

/* Ensure Trigger Areas are set up for positioning */
#toolbar-trigger-area,
#left-toolbar-trigger-area {
    position: fixed; /* Must be fixed */
    width: 30px;
    height: 100%;
    top: 0;
    z-index: 9998;
    pointer-events: auto; /* Critical for hover */
    /* Remove any background/border from the trigger area itself */
    background: transparent;
    border: none;
}
#toolbar-trigger-area { right: 0; }
#left-toolbar-trigger-area { left: 0; }
/* NEW: Adjust Right Toolbar Trigger in Double Page View */
body:not(.fullscreen-mode):not(.content-rotated-mode) #toolbar-trigger-area {
    top: 60px;                 /* Lower the top edge */
    height: calc(100% - 60px); /* Reduce height to keep bottom edge in place */
}


/* Common Glow Styles (Hidden by default) */
#toolbar-trigger-area::after,
#left-toolbar-trigger-area::after {
    content: '';
    position: absolute;
    top: 50%; /* Center vertically */
    left: 50%; /* Center horizontally */
    width: 60px;  /* Width of the glow */
    height: 90px; /* Height of the glow (slightly taller) */
    /* Create the orange glow gradient */
    
    );
    border-radius: 50%; /* Make it elliptical/circular */
    filter: blur(15px); /* Soften the glow */
    /* Start hidden */
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.8); /* Center and slightly scaled down */
    transition: opacity 0.25s ease-out, transform 0.25s ease-out;
    pointer-events: none; /* Glow itself doesn't intercept clicks */
    z-index: -1; /* Behind potential trigger content */
}

/* Show Glow on Trigger Area Hover */
#toolbar-trigger-area:hover::after,
#left-toolbar-trigger-area:hover::after {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1); /* Scale up to full size */
}

        /* Keyframes for the text shimmer effect */
@keyframes shimmerText {
    0% {
        background-position: 150% 50%; /* Start with gradient shifted right */
    }
    100% {
        background-position: -50% 50%; /* End with gradient shifted left */
    }
}
        
</style>

</head>
<body class="loading-game-active"> <!-- Start with loading game active -->

    <!-- Loading Game Screen -->
    <div id="loading-game-container">
        <iframe id="game-iframe" src="/chapter2-loading-game.html" title="Loading Game"></iframe>
        <!-- REMOVED: Loading Bar -->
        <p id="iframe-loading-text">Loading game...</p>
    </div>
    <!-- Go To Chapter Button (Initially hidden, modified state via JS/CSS) -->
    <button id="go-to-chapter-btn">Go to Chapter</button>

    <!-- Left Toolbar (Timelock) -->
    <div id="left-toolbar"></div>
    <div class="left-toolbar-trigger-area" id="left-toolbar-trigger-area"></div> <!-- REVERTED trigger div name -->

    <!-- Right Toolbar (Position Modified) -->
    <div id="new-toolbar"></div>
    <!-- Trigger Area for Right Toolbar (Position Modified) -->
    <div class="toolbar-trigger-area" id="toolbar-trigger-area"></div> <!-- REVERTED trigger div name -->

    <!-- Fixed button to return from rotated view (Initially hidden by CSS) -->
    <button id="return-view-fixed-btn" class="new-btn" title="Return to Previous View">↶</button>

    <!-- Status Indicator (Hidden by default) -->
    <div id="status-indicator">Status: Initializing...</div>

    <!-- Main Reader Area (Initially hidden via CSS/JS) -->
    <div class="main-container">
        <div class="book-spread">
            <!-- Left Page -->
            <div class="book-page left">
                <div class="page-rotate-hover-trigger"></div> <!-- ADDED Trigger Element -->
                <button class="page-action-btn page-rotate-btn" title="Rotate Content">↷</button>
                <div class="canvas-container">
                    <canvas id="left-page-canvas" class="pdf-canvas"></canvas>
                    <div class="textLayer" id="left-text-layer"></div>
                    <div class="annotationLayer" id="left-annotation-layer"></div>
                    <div class="keyword-overlay-container" id="left-keyword-overlay"></div>
                </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="left-page-number"></div>
                <div class="page-loading-overlay"><div class="page-loading-spinner"></div></div>
            </div>
            <!-- Right Page (Initially placeholder) -->
            <div class="book-page right placeholder-page">
                 <div class="page-rotate-hover-trigger"></div> <!-- ADDED Trigger Element -->
                 <button class="page-action-btn page-rotate-btn" title="Rotate Content">↷</button>
                 <div class="canvas-container">
                    <canvas id="right-page-canvas" class="pdf-canvas"></canvas>
                     <div class="textLayer" id="right-text-layer"></div>
                     <div class="annotationLayer" id="right-annotation-layer"></div>
                     <div class="keyword-overlay-container" id="right-keyword-overlay"></div>
                 </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="right-page-number"></div>
                <div class="page-loading-overlay"><div class="page-loading-spinner"></div></div>
            </div>
        </div>
    </div>


    <!-- Global Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay"></div>
    <!-- Page Slider -->
    <div class="page-slider-container" id="page-slider-container">
        <!-- Slider Track and Milestones -->
        <div class="page-slider-track">
            <div id="lo-milestones-container"></div> <!-- NEW Container for milestones -->
            <input type="range" id="page-slider" class="page-slider" min="1" max="1" value="1" style="--slider-percent: 0%">
        </div>
        <!-- Slider Info -->
        <div class="page-slider-info">
            <span id="current-page-display">Page 1</span> of <span id="total-pages-display">1</span>
        </div>
        <!-- LO Tooltip (Initially hidden) -->
        <div id="lo-tooltip"></div>
    </div>
    <!-- Separate Trigger Zone for Page Slider -->
    <div id="page-slider-trigger-zone"></div>

    <!-- Keyword Definition Popup -->
    <div id="definition-popup"> <!-- Removed class="definition-popup" as ID is sufficient -->
        <div id="popup-word">Keyword</div> <!-- Removed class="definition-popup-title" -->
        <div id="popup-definition">Loading definition...</div> <!-- Removed class="definition-popup-content" -->
    </div>


    <!-- Reading Time Alert Popup -->
    <div id="reading-time-alert"></div>

    <!-- Iframe Popup -->
    <div id="iframe-popup-backdrop"></div>
    <div id="iframe-popup-modal">
        <button id="close-iframe-popup-btn" title="Close (Esc)">×</button>
        <iframe id="popup-iframe" src="about:blank" title="Embedded Content"></iframe>
    </div>

    <!-- Notes Popup -->
<div id="notes-popup-backdrop"></div>
<div id="notes-popup-container">

    <!-- This is the container FOR the canvas -->
    <div id="notes-pdf-canvas-container">

        <!-- NEW: Local Loader Element (Correctly placed HERE) -->
        <div class="notes-local-loader" style="display: none;">
            <div class="notes-local-spinner"></div>
            <span>Loading Notes...</span>
        </div>

        <!-- The actual Canvas (Correctly placed HERE) -->
        <canvas id="notes-pdf-canvas"></canvas>

        <!-- The Nav Buttons (Correctly placed HERE) -->
        <button id="notes-prev-btn" class="notes-nav-btn" title="Previous Notes Page">ᐸ</button>
        <button id="notes-next-btn" class="notes-nav-btn" title="Next Notes Page">ᐳ</button>

    </div> <!-- End of notes-pdf-canvas-container -->

    <!-- The Instruction (Outside canvas container, but inside main popup container) -->
    <div id="notes-instruction"><em>Copy these notes into your Pyr Notebook before continuing</em></div>

</div> <!-- End of notes-popup-container -->

    <!-- NEW: LO Achievement Pop-up -->
    <div id="lo-achievement-backdrop"></div>
    <div id="lo-achievement-popup">
        <!-- Content is dynamically set by JS, but provide structure -->
        <h3 id="lo-achievement-header">Congratulations 🎉 You've learned:</h3>
        <p id="lo-achievement-text"><strong>Placeholder Learning Outcome</strong></p>
        <em id="lo-achievement-tip">Teach it to a friend or family member to strengthen your understanding!</em>
        <button id="lo-continue-btn">Continue</button>
    </div>


<!-- Script block for initial HTML population (minimal changes) -->
<script>
    // --- START: HTML Population ---
    (function populateInitialHTML() {
        const boxIconSVG = `<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`;
        const clockOnIconSVG = `<svg class="icon icon-clock-on" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`;
        const clockOffIconSVG = `<svg class="icon icon-clock-off" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>`;

        // NOTE: The new code removed the 'Rotate' button from the main toolbar.
        // We keep that change as it wasn't explicitly asked to be reverted.
        // The rotate button is now inside the page element itself.
        document.getElementById('new-toolbar').innerHTML = `
            <button class="new-btn" id="back-btn" title="Go Back">↤</button>
            <button class="new-btn" id="single-page-btn" title="Single Page View" style="font-size: 28px; line-height: 1;">▯</button>
            <button class="new-btn" id="double-page-btn" title="Double Page View">◫</button>
            <button class="new-btn" id="time-capsule-btn" title="Time Capsule (TOC Disabled)">${boxIconSVG}</button>
            `;
            // Note: Return button (#return-view-fixed-btn) is separate HTML outside this toolbar
        // TOC Panel removed from here, handled by Time Capsule button logic elsewhere if needed
        document.getElementById('left-toolbar').innerHTML = `
            <button class="new-btn" id="timelock-toggle-btn" title="Toggle Reading Time Lock (On)">
                ${clockOnIconSVG}
                ${clockOffIconSVG}
            </button>
        `;
        document.getElementById('loading-overlay').innerHTML = `<div class="loading-spinner"></div><div class="loading-message">Processing...</div>`;
        // Page slider container content is now populated by JS (renderSliderMilestones) and base HTML
    })();
    // --- END: HTML Population ---
</script>

<!-- Main application script block (Refactored & Reverted + MODIFIED) -->
<script>
(function() { // IIFE to encapsulate scope
    'use strict';
    let notesNavFadeTimeout = null;
    let isChapterReady = false;

    // --- Constants ---
    const MAX_CACHE_SIZE = 20;
    const TOOLBAR_HIDE_DELAY = 500; // Kept constant
    const SLIDER_HIDE_DELAY = 1750; // Kept constant from new code
    const READING_TIME_ALERT_DURATION = 2500; // Kept constant from new code
    const GAME_OVER_TRANSITION_DELAY = 3000; // Kept constant from new code
    const LOADING_BAR_ANIMATION_BUFFER = 600; // Kept constant from new code (used for button transition timing)
    const NOTES_WIGGLE_DURATION = 500; // Kept constant from new code
    const LO_TOOLTIP_OFFSET_Y = 5; // Offset below emoji for tooltip

    const CSS_CLASS = {
        VISIBLE: 'visible',
        LOADING_GAME_ACTIVE: 'loading-game-active',
        FULLSCREEN_MODE: 'fullscreen-mode',
        CONTENT_ROTATED_MODE: 'content-rotated-mode',
        PLACEHOLDER_PAGE: 'placeholder-page',
        FIRST_KEYWORD_INSTANCE: 'first-keyword-instance',
        TIMELOCK_ON: 'timelock-on',
        TIMELOCK_OFF: 'timelock-off',
        WIGGLE_NOW: 'wiggle-now',
        LOADING_CHAPTER: 'loading-chapter', // Added for button state
        LO_PASSED: 'lo-passed', // New class for passed LO milestones
        HOVER_COLORED: 'hover-colored', // New class for temp coloring on hover
    };

    // --- START: ADD THIS NEW FUNCTION ---
function triggerRotateButtonIndication() {
    if (!ui.returnViewFixedBtn) return;

    const button = ui.returnViewFixedBtn;
    const animationClassName = 'indicate-rotation-block';
    const animationDuration = 600; // Match CSS duration in ms

    // Remove class first to allow re-triggering if called rapidly
    button.classList.remove(animationClassName);

    // Force reflow/repaint to ensure animation restarts
    void button.offsetWidth;

    // Add class to start animation
    button.classList.add(animationClassName);
    updateStatus("Triggered rotate button indication animation.");

    // Set timeout to remove the class after animation completes
    setTimeout(() => {
        button.classList.remove(animationClassName);
    }, animationDuration);
}
// --- END: ADD THIS NEW FUNCTION ---
    
    // --- UI Elements Cache (Keep from New Code, removed loading bar elements, added LO elements) ---
    const ui = {
        body: document.body,
        mainContainer: document.querySelector('.main-container'),
        bookSpread: document.querySelector('.main-container .book-spread'),
        leftPageDiv: document.querySelector('.book-page.left'),
        rightPageDiv: document.querySelector('.book-page.right'),
        leftPageCanvas: document.getElementById('left-page-canvas'),
        rightPageCanvas: document.getElementById('right-page-canvas'),
        leftTextLayer: document.getElementById('left-text-layer'),
        rightTextLayer: document.getElementById('right-text-layer'),
        leftAnnotationLayer: document.getElementById('left-annotation-layer'),
        rightAnnotationLayer: document.getElementById('right-annotation-layer'),
        leftKeywordOverlay: document.getElementById('left-keyword-overlay'),
        rightKeywordOverlay: document.getElementById('right-keyword-overlay'),
        leftPageNumDisplay: document.getElementById('left-page-number'),
        rightPageNumDisplay: document.getElementById('right-page-number'),

        rightToolbar: document.getElementById('new-toolbar'),
        rightToolbarTrigger: document.getElementById('toolbar-trigger-area'),
        leftToolbar: document.getElementById('left-toolbar'),
        leftToolbarTrigger: document.getElementById('left-toolbar-trigger-area'),
        timelockToggleButton: document.getElementById('timelock-toggle-btn'),
        returnViewFixedBtn: document.getElementById('return-view-fixed-btn'),

        sliderContainer: document.getElementById('page-slider-container'),
        sliderTrack: document.querySelector('.page-slider-track'), // Added for milestone positioning
        loMilestonesContainer: document.getElementById('lo-milestones-container'), // Added
        slider: document.getElementById('page-slider'),
        sliderTriggerZone: document.getElementById('page-slider-trigger-zone'),
        currentPageDisplay: document.getElementById('current-page-display'),
        totalPagesDisplay: document.getElementById('total-pages-display'),
        sliderInfo: document.querySelector('.page-slider-info'), // Added

        loadingOverlay: document.getElementById('loading-overlay'),
        loadingMessage: document.querySelector('#loading-overlay .loading-message'),

        definitionPopup: document.getElementById('definition-popup'),
        popupWord: document.getElementById('popup-word'),
        popupDefinition: document.getElementById('popup-definition'),
        closePopupBtn: document.getElementById('close-popup-btn'),

        readingTimeAlert: document.getElementById('reading-time-alert'),

        iframePopupBackdrop: document.getElementById('iframe-popup-backdrop'),
        iframePopupModal: document.getElementById('iframe-popup-modal'),
        popupIframe: document.getElementById('popup-iframe'),
        closeIframePopupBtn: document.getElementById('close-iframe-popup-btn'),

        notesPopupBackdrop: document.getElementById('notes-popup-backdrop'),
        notesPopupContainer: document.getElementById('notes-popup-container'),
        notesPdfCanvasContainer: document.getElementById('notes-pdf-canvas-container'),
        notesPdfCanvas: document.getElementById('notes-pdf-canvas'),
        notesPrevBtn: document.getElementById('notes-prev-btn'),
        notesNextBtn: document.getElementById('notes-next-btn'),
        notesInstruction: document.getElementById('notes-instruction'),
        notesLocalLoader: document.querySelector('#notes-pdf-canvas-container .notes-local-loader'),

        gameContainer: document.getElementById('loading-game-container'),
        gameIframe: document.getElementById('game-iframe'),
        goToChapterBtn: document.getElementById('go-to-chapter-btn'),
        iframeLoadingText: document.getElementById('iframe-loading-text'),

        statusIndicator: document.getElementById('status-indicator'), // Although hidden

        // NEW LO Achievement elements
        loAchievementBackdrop: document.getElementById('lo-achievement-backdrop'),
        loAchievementPopup: document.getElementById('lo-achievement-popup'),
        loAchievementText: document.getElementById('lo-achievement-text'),
        loAchievementTip: document.getElementById('lo-achievement-tip'), // Added reference to tip element
        loContinueBtn: document.getElementById('lo-continue-btn'),

        // Added for HTML Population (though not strictly needed if populated before script run)
        loTooltip: document.getElementById('lo-tooltip'), // Added LO Tooltip
    };

    // --- PDF.js Setup (Keep from New Code) ---
    const { pdfjsLib, pdfjsViewer } = window; // Destructure from window
    if (!pdfjsLib || !pdfjsViewer) {
        console.error("PDF.js library or viewer components not found!");
        document.body.innerHTML = `<div style="color:red;padding:20px;background:white;font-family:sans-serif;">Error: PDF.js failed to load.</div>`;
        return; // Stop execution if PDF.js is missing
    }
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.worker.min.js';
    const linkService = new pdfjsViewer.SimpleLinkService();
    const eventBus = new pdfjsViewer.EventBus(); // Although not directly used, keep for potential compatibility

    // --- Application State (Reverted toolbar/timelock state, added LO state) ---
    const appState = { // Keep non-reverted state from new code
        isReaderReady: false,
        resizeTimer: null,
        sliderHideTimeout: null,
        gameOverTimeoutId: null,
        alertTimeout: null,
        alertWiggleTimeout: null,
        rotatedViewTargetPageNum: null, 
        isDraggingSlider: false,
        pagePadding: 15, // Default, updated on init
        isSliderAreaHovered: false, // NEW: Track hover over trigger zone OR slider container
        learningOutcomes: [], // NEW: Store loaded LOs [{emoji, learning_outcome, page_number}, ...]
        loPopupTargetPage: null, // NEW: Store target page for after LO popup
        originalSliderInfoText: null,
        sliderInfoFadeTimeout: null,
    };
    // REVERTED: Global state variables for toolbar/timer from old code
    let toolbarTimer=null;
    let toolbarHover=!1;
    let leftToolbarTimer=null; // Timer for left toolbar
    let leftToolbarHover=!1;  // Hover state for left toolbar

    // REVERTED: Timelock state variables from old code
    let isTimelockGloballyEnabled = true;
    let currentPageLockStartTime = 0;
    let requiredReadingTime = 0;
    let isTimeLockActive = false;
    let completedTimeLockPages = new Set();
    let currentLockType = null; // NEW: Tracks what the current lock applies to ('pdf', 'notes', 'iframe', or null)

    // --- State related to PDF/Notes/Keywords (Keep from New Code) ---
    const pdfState = {
        pdfDocument: null,
        title: "No Document",
        totalPages: 0,
        currentPage: 1,
        isDoublePageView: true, // Initial assumption, adjusted on load based on screen size
        pageCache: new Map(),
        currentViewports: {}, // Stores viewport used for rendering { canvasId: viewport }
        keywordDefinitions: {}, // Now expects values like ["(pos)", "definition"]
        pageKeywords: {}, // { pageNumStr: [keyword1, keyword2] }
        globalFirstInstanceLocation: {}, // { keywordLower: { pageNum, itemIndex, matchIndex } }
        iframeMappings: {}, // { pageNumStr: urlString }
        notesMapping: {}, // { chapterPageStr: { pdf: path, page: number } }
        notesPdfLoadingTask: null,
        currentNotesPdfDoc: null,
        currentNotesPageNum: 1,
        totalNotesPages: 0,
        outline: [], // Added outline property
    };

    const userState = {
        readingProgress: {
            furthestPage: 1,
        },
    };

   

    // --- Utility Functions (Keep from New Code, added LO popup visibility) ---
    const updateStatus = (message) => console.log(`[Viewer Status] ${message}`);
    // const updateStatus = () => {}; // Production toggle

    const toggleVisibility = (element, show) => {
        if (element) {
            // Special handling for goToChapterBtn to manage loading state class
            if (element === ui.goToChapterBtn) {
                 if (show) {
                     // Logic moved to loadPdf for specific state changes
                     // element.classList.add(CSS_CLASS.VISIBLE);
                 } else {
                     element.classList.remove(CSS_CLASS.VISIBLE, CSS_CLASS.LOADING_CHAPTER);
                 }
             // NEW: Special handling for LO achievement popup
             } else if (element === ui.loAchievementBackdrop || element === ui.loAchievementPopup) {
                 element.classList.toggle(CSS_CLASS.VISIBLE, show);
             // Special handling for LO tooltip using fixed positioning
             } else if (element === ui.loTooltip) {
                 element.classList.toggle(CSS_CLASS.VISIBLE, show);
             } else {
                 element.classList.toggle(CSS_CLASS.VISIBLE, show);
            }
        }
    };


    const resetPopupStates = () => {
        hideDefinitionPopup();
        hideIframePopupIfNeeded();
        hideNotesPopupIfNeeded();
        hideLoAchievementPopup(); // Added
    };

    const getPageElement = (canvasId) => {
        const canvas = (canvasId === 'left-page-canvas') ? ui.leftPageCanvas : ui.rightPageCanvas;
        return canvas?.closest('.book-page');
    };

    const getCanvasContainer = (pageElement) => pageElement?.querySelector('.canvas-container');

    const clearPageLayers = (pageElement) => {
        if (!pageElement) return;
        const textLayer = pageElement.querySelector('.textLayer');
        const annotationLayer = pageElement.querySelector('.annotationLayer');
        const keywordOverlay = pageElement.querySelector('.keyword-overlay-container');
        if (textLayer) textLayer.innerHTML = '';
        if (annotationLayer) annotationLayer.innerHTML = '';
        if (keywordOverlay) keywordOverlay.innerHTML = '';
    };

    const showPageLoading = (canvasId) => {
        const overlay = getPageElement(canvasId)?.querySelector('.page-loading-overlay');
        if (overlay) overlay.style.display = 'flex';
    };

    const hidePageLoading = (canvasId) => {
        const overlay = getPageElement(canvasId)?.querySelector('.page-loading-overlay');
        if (overlay) overlay.style.display = 'none';
    };


    // --- Toolbar Logic (REVERTED from Old Code) ---
    function manageToolbar(s=null){const t=document.getElementById('new-toolbar');if(!t || document.body.classList.contains('loading-game-active'))return;clearTimeout(toolbarTimer);const show=s??toolbarHover;if(show){t.classList.add('visible')}else{toolbarTimer=setTimeout(()=>{if(!toolbarHover)t.classList.remove('visible')},500)}}
    function setupToolbarHover(){const t=document.getElementById('new-toolbar'),a=document.getElementById('toolbar-trigger-area'),h=t;if(!t||!a){console.error("Right Toolbar/trigger missing");return}const enter=()=>{if(document.body.classList.contains('loading-game-active')) return; toolbarHover=true;manageToolbar(true)};const leave=()=>{toolbarHover=false;manageToolbar(false)};a.addEventListener('mouseenter',enter);t.addEventListener('mouseenter',enter);a.addEventListener('mouseleave',leave);t.addEventListener('mouseleave',leave);h.addEventListener('click',e=>{if(document.body.classList.contains('loading-game-active')) return; if(e.target.closest('.new-btn'))return;const r=h.getBoundingClientRect();let c=false;const w=25;/* Removed rotated check as handle is always vertical now */ if(e.clientY>=r.top&&e.clientY<=r.bottom&&e.clientX<r.left&&e.clientX>=r.left-w)c=true; if(c){toolbarHover=!t.classList.contains('visible');manageToolbar()}});updateStatus("Right Toolbar setup.")}

    // --- Left Toolbar Logic (REVERTED from Old Code) ---
    function manageLeftToolbar(s=null){const t=document.getElementById('left-toolbar');if(!t || document.body.classList.contains('loading-game-active'))return;clearTimeout(leftToolbarTimer);const show=s??leftToolbarHover;if(show){t.classList.add('visible')}else{leftToolbarTimer=setTimeout(()=>{if(!leftToolbarHover)t.classList.remove('visible')},500)}}
    function setupLeftToolbarHover(){const t=document.getElementById('left-toolbar'),a=document.getElementById('left-toolbar-trigger-area'),h=t;if(!t||!a){console.error("Left Toolbar/trigger missing");return}const enter=()=>{if(document.body.classList.contains('loading-game-active')) return; leftToolbarHover=true;manageLeftToolbar(true)};const leave=()=>{leftToolbarHover=false;manageLeftToolbar(false)};a.addEventListener('mouseenter',enter);t.addEventListener('mouseenter',enter);a.addEventListener('mouseleave',leave);t.addEventListener('mouseleave',leave);h.addEventListener('click',e=>{if(document.body.classList.contains('loading-game-active')) return; if(e.target.closest('.new-btn'))return;const r=h.getBoundingClientRect();let c=false;const w=25;if(e.clientY>=r.top&&e.clientY<=r.bottom&&e.clientX>r.right&&e.clientX<=r.right+w)c=true; if(c){leftToolbarHover=!t.classList.contains('visible');manageLeftToolbar()}});updateStatus("Left Toolbar setup.")}
    // --- END Reverted Toolbar Logic ---

    // --- Caching (Keep from New Code) ---
    function trimCache() {
        while (pdfState.pageCache.size > MAX_CACHE_SIZE) {
            pdfState.pageCache.delete(pdfState.pageCache.keys().next().value);
        }
    }

    // --- Keyword Overlays (Keep from New Code) ---
    // Replacement createKeywordOverlays function // <<<< CONFIRMED: Correct Block Start
    async function createKeywordOverlays(pageNum, pageElement, viewport) {
        const overlayContainerId = pageElement.classList.contains('left') ? 'left-keyword-overlay' : 'right-keyword-overlay';
        const overlayContainer = document.getElementById(overlayContainerId);
        const canvasContainer = getCanvasContainer(pageElement);

        if (!pdfState.pdfDocument || !overlayContainer || !canvasContainer) {
            console.warn(`Skipping keyword overlay for page ${pageNum}: Missing elements.`); return;
        }
        overlayContainer.innerHTML = ''; // Clear previous highlights

        const keywordsForPage = pdfState.pageKeywords[pageNum.toString()] || [];
        if (keywordsForPage.length === 0) return;

        const lowerCaseKeywords = keywordsForPage.map(k => k.toLowerCase());
        const lowerCaseDefs = {};
        // Prepare definitions map expecting array format: [PoS, Definition]
        for (const key in pdfState.keywordDefinitions) {
            // Store the array directly under the lowercase key
            lowerCaseDefs[key.toLowerCase()] = pdfState.keywordDefinitions[key];
        }

        try {
            const page = await pdfState.pdfDocument.getPage(pageNum);
            const textContent = await page.getTextContent({ normalizeWhitespace: true });
            const items = textContent.items;

            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const item = items[itemIndex];
                const itemText = item.str;
                const itemTextLength = itemText.length;
                if (!itemText || itemText.trim().length === 0 || itemTextLength === 0 || item.width === 0) continue;

                keywordsForPage.forEach((originalKeyword, keywordIndex) => {
                    const keywordLower = lowerCaseKeywords[keywordIndex];
                    const definitionData = lowerCaseDefs[keywordLower]; // This is now expected to be an array

                    // *** Validate the new array structure ***
                    if (!Array.isArray(definitionData) || definitionData.length < 2 || typeof definitionData[1] !== 'string' || !definitionData[1]) {
                        // console.warn(`Invalid/missing definition data for keyword: ${originalKeyword} (lowercase: ${keywordLower}) on page ${pageNum}`);
                        return; // Skip this keyword if data format is wrong or definition is missing
                    }
                    const partOfSpeech = definitionData[0] || ''; // PoS is index 0, default to empty string
                    const actualDefinition = definitionData[1]; // Definition is index 1

                    const escapedKeyword = originalKeyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    const regex = new RegExp(`\\b(${escapedKeyword})\\b`, 'gi');
                    let match;

                    while ((match = regex.exec(itemText)) !== null) {
                        const matchedString = match[1];
                        const matchIndex = match.index;
                        const matchLength = matchedString.length;

                        if (matchLength === 0) { regex.lastIndex++; continue; }

                        const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                        const itemWidth = item.width;
                        const itemHeight = item.height;
                        const itemLeft = tx[4];
                        const itemTop = tx[5] - itemHeight;

                        const highlightOffsetX = (matchIndex / itemTextLength) * itemWidth;
                        const highlightWidth = (matchLength / itemTextLength) * itemWidth;

                        const finalLeft = Math.max(0, itemLeft + highlightOffsetX);
                        const finalTop = Math.max(0, itemTop);
                        const finalWidth = Math.max(1, highlightWidth);
                        const finalHeight = itemHeight > 0 ? itemHeight : parseFloat(getComputedStyle(overlayContainer).fontSize) || 12;

                        const highlightDiv = document.createElement('div');
                        highlightDiv.className = 'keyword-highlight';
                        highlightDiv.style.left = `${finalLeft}px`;
                        highlightDiv.style.top = `${finalTop}px`;
                        highlightDiv.style.width = `${finalWidth}px`;
                        highlightDiv.style.height = `${finalHeight}px`;

                        // *** Store keyword, PoS, and definition separately ***
                        highlightDiv.dataset.keyword = originalKeyword;
                        highlightDiv.dataset.pos = partOfSpeech; // Store Part of Speech
                        highlightDiv.dataset.definition = actualDefinition; // Store Definition text
                        highlightDiv.title = 'Click for definition';
                        
                        const firstLoc = pdfState.globalFirstInstanceLocation[keywordLower];
                        if (firstLoc && firstLoc.pageNum === pageNum && firstLoc.itemIndex === itemIndex && firstLoc.matchIndex === matchIndex) {
                            highlightDiv.classList.add(CSS_CLASS.FIRST_KEYWORD_INSTANCE);
                        }

                        highlightDiv.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE)) return;
                            const currentHighlight = e.currentTarget;
                            // Pass the clicked element itself to showDefinitionPopup
                            showDefinitionPopup(currentHighlight); // *** Pass the element ***
                        });
                        overlayContainer.appendChild(highlightDiv);
                    }
                });
            }
        } catch (error) {
            console.error(`Error processing text content for keyword overlays on page ${pageNum}:`, error);
            overlayContainer.innerHTML = '';
        }
    }
    // <<<< CONFIRMED: Correct Block End

    // --- Text & Annotation Layer Rendering (Keep from New Code) ---
    async function renderAndEnhanceTextLayer(page, container, viewport) {
      if (!page || !container || !viewport) return;
      container.innerHTML = '';
      // Style applied via CSS, no need to set here
      try {
        const textContent = await page.getTextContent({normalizeWhitespace: true});
        const renderTask = pdfjsLib.renderTextLayer({ textContent, container, viewport });
        await renderTask.promise;
      } catch (error) {
        console.error(`Error rendering base text layer for page ${page.pageNumber}:`, error);
        container.innerHTML = '';
      }
    }

    async function renderAnnotationLayer(page, container, viewport) {
        if (!page || !container || !viewport) { console.warn("Skipping annotation layer: params missing."); return }
        container.innerHTML = '';
        try {
            const annotations = await page.getAnnotations();
            if (annotations.length === 0) return;

            pdfjsLib.AnnotationLayer.render({
                viewport: viewport.clone({ dontFlip: true }),
                div: container,
                annotations: annotations,
                page: page,
                linkService: linkService // Use the global linkService instance
            });

            // Ensure links open in a new tab (already correctly targets links)
            requestAnimationFrame(() => {
                const links = container.querySelectorAll('.linkAnnotation > a');
                links.forEach(link => {
                    link.setAttribute('target', '_blank');
                    link.setAttribute('rel', 'noopener noreferrer');
                });
            });

        } catch (error) {
            console.error(`Error rendering annotation layer for page ${page.pageNumber}:`, error);
            container.innerHTML = '';
        }
    }

    // --- Page Rendering (Keep from New Code - Uses new pdfState) ---
    async function renderPage(pageNum, canvasId) {
        const canvas = (canvasId === 'left-page-canvas') ? ui.leftPageCanvas : ui.rightPageCanvas;
        const ctx = canvas?.getContext('2d');
        const pageElement = getPageElement(canvasId);
        const canvasContainer = getCanvasContainer(pageElement);
        const textLayerContainer = pageElement?.querySelector('.textLayer'); // ui.leftTextLayer / ui.rightTextLayer
        const annotationLayerContainer = pageElement?.querySelector('.annotationLayer'); // ui.leftAnnotationLayer / ui.rightAnnotationLayer
        const keywordOverlayContainer = pageElement?.querySelector('.keyword-overlay-container'); // ui.leftKeywordOverlay / ui.rightKeywordOverlay

        delete pdfState.currentViewports[canvasId];
        clearPageLayers(pageElement);

        if (!pdfState.pdfDocument || !canvas || !ctx || !canvasContainer || !textLayerContainer || !annotationLayerContainer || !keywordOverlayContainer || !pageElement || pageNum < 1 || pageNum > pdfState.totalPages) {
            if (canvas && ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (pageElement) pageElement.classList.add(CSS_CLASS.PLACEHOLDER_PAGE);
            hidePageLoading(canvasId);
            return;
        }

        showPageLoading(canvasId);
        pageElement.classList.remove(CSS_CLASS.PLACEHOLDER_PAGE);
        let page;
        let viewport;

        try {
            if (pdfState.pageCache.has(pageNum)) {
                const cachedData = pdfState.pageCache.get(pageNum);
                canvas.width = cachedData.width; canvas.height = cachedData.height;
                canvas.style.width = `${cachedData.styleWidth}px`; canvas.style.height = `${cachedData.styleHeight}px`;
                ctx.putImageData(cachedData.imageData, 0, 0);
                page = await pdfState.pdfDocument.getPage(pageNum); // Still need page object for layers
                viewport = cachedData.viewport;
                pdfState.currentViewports[canvasId] = viewport;
                // Move accessed item to the end (most recently used)
                pdfState.pageCache.delete(pageNum);
                pdfState.pageCache.set(pageNum, cachedData);
                hidePageLoading(canvasId);
            } else {
                page = await pdfState.pdfDocument.getPage(pageNum);
                const containerStyle = getComputedStyle(canvasContainer);
                const availableWidth = parseFloat(containerStyle.width);
                const availableHeight = parseFloat(containerStyle.height);

                if (isNaN(availableWidth) || isNaN(availableHeight) || availableWidth <= 0 || availableHeight <= 0) {
                    console.warn(`Canvas container ${canvasId} has invalid dimensions during renderPage call for page ${pageNum}. Skipping render.`);
                    hidePageLoading(canvasId);
                    return;
                }

                const defaultViewport = page.getViewport({ scale: 1 });
                const scale = Math.min(availableWidth / defaultViewport.width, availableHeight / defaultViewport.height);
                viewport = page.getViewport({ scale: scale });
                pdfState.currentViewports[canvasId] = viewport;

                const outputScale = window.devicePixelRatio || 1;
                canvas.width = Math.floor(viewport.width * outputScale);
                canvas.height = Math.floor(viewport.height * outputScale);
                canvas.style.width = `${Math.floor(viewport.width)}px`;
                canvas.style.height = `${Math.floor(viewport.height)}px`;

                const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
                await page.render({ canvasContext: ctx, transform, viewport }).promise;

                // Cache the rendered image data and viewport info
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                pdfState.pageCache.set(pageNum, {
                    imageData,
                    width: canvas.width,
                    height: canvas.height,
                    styleWidth: Math.floor(viewport.width),
                    styleHeight: Math.floor(viewport.height),
                    viewport
                });
                trimCache(); // Ensure cache doesn't exceed max size
                hidePageLoading(canvasId);
            }

            // Render enhancement layers after canvas is drawn
            await renderAndEnhanceTextLayer(page, textLayerContainer, viewport);
            await renderAnnotationLayer(page, annotationLayerContainer, viewport);
            await createKeywordOverlays(pageNum, pageElement, viewport); // Pass necessary elements

        } catch (error) {
            console.error(`Error rendering page ${pageNum} on ${canvasId}:`, error);
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
            hidePageLoading(canvasId);
            pageElement?.classList.add(CSS_CLASS.PLACEHOLDER_PAGE);
        }
    }

    // --- Reading Time Calculation (Keep from New Code - Uses new pdfState) ---
    async function calculatePageReadingTime(pageNum, viewport) {
        if (!pdfState.pdfDocument || !viewport || pageNum < 1 || pageNum > pdfState.totalPages) {
            return 0;
        }
        try {
            const page = await pdfState.pdfDocument.getPage(pageNum);
            const [textContent, annotations] = await Promise.all([
                page.getTextContent({ normalizeWhitespace: true }),
                page.getAnnotations()
            ]);

            // Filter link annotations and convert their rects to viewport coordinates
            const linkAnnotations = annotations.filter(annot => annot.subtype === 'Link' && annot.rect);
            const linkRectsInViewport = linkAnnotations.map(annot => viewport.convertToViewportRectangle(annot.rect));

            let wordCount = 0;
            for (const item of textContent.items) {
                const itemText = item.str;
                if (!itemText || itemText.trim().length === 0 || item.width === 0) continue;

                // Calculate item's bounding box in viewport coordinates
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                const itemWidth = item.width;
                const itemHeight = item.height > 0 ? item.height : 12; // Estimate height if zero
                const itemLeft = tx[4];
                const itemTop = tx[5] - itemHeight; // Adjust for baseline
                const itemRect = [itemLeft, itemTop, itemLeft + itemWidth, itemTop + itemHeight];

                // Check if the center of the text item falls within any link annotation
                let isInsideLink = false;
                const itemCenterX = itemRect[0] + (itemRect[2] - itemRect[0]) / 2;
                const itemCenterY = itemRect[1] + (itemRect[3] - itemRect[1]) / 2;
                for (const linkRect of linkRectsInViewport) {
                    if (itemCenterX >= linkRect[0] && itemCenterX <= linkRect[2] &&
                        itemCenterY >= linkRect[1] && itemCenterY <= linkRect[3]) {
                        isInsideLink = true;
                        break;
                    }
                }

                // Count words only if not inside a link
                if (!isInsideLink) {
                    wordCount += itemText.trim().split(/\s+/).filter(Boolean).length;
                }
            }
            // Estimate reading time (5 words per second)
            const readingTimeSeconds = Math.ceil(wordCount / 5);
            return readingTimeSeconds;

        } catch (error) {
            console.error(`Error calculating reading time for page ${pageNum}:`, error);
            return 0; // Return 0 on error
        }
    }

    // --- Update Display (REVERTED Timelock Logic, Uses New Code's state/UI, Added LO update) ---
    async function updateDisplay() {
    if (!pdfState.pdfDocument) { updateStatus("UpdateDisplay skipped: No PDF loaded."); return; }

    const leftPageNum = pdfState.currentPage; // This is the current *start* page of the view
    const potentialRightPageNum = pdfState.isDoublePageView ? pdfState.currentPage + 1 : 0;

    // updateStatus(`Updating display for page(s): Start=${leftPageNum}${potentialRightPageNum > 0 ? ' (Intended Double View)' : ''}`);

    if (!ui.leftPageDiv || !ui.rightPageDiv || !ui.leftPageNumDisplay || !ui.rightPageNumDisplay) {
        console.error("Critical page elements missing! Cannot update display."); return;
    }

    const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
    const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE); // Check this first
    const isEffectiveDoublePageView = pdfState.isDoublePageView && !isFullscreen && !isContentRotated;
    // updateStatus(`Effective View Mode: ${isContentRotated ? 'Rotated' : (isEffectiveDoublePageView ? 'Double' : 'Single')}`);

    let renderPromises = [];
    let leftPageNumToRender = pdfState.currentPage; // Default

    // *** START CHANGE: Determine correct page for render ***
    if (isContentRotated && appState.rotatedViewTargetPageNum !== null) {
        leftPageNumToRender = appState.rotatedViewTargetPageNum;
        updateStatus(`Rotated view active. Rendering target page ${leftPageNumToRender} into left canvas.`);
    } else if (!isContentRotated) {
        // Normal logic for non-rotated view
        leftPageNumToRender = pdfState.currentPage;
    } else {
        // Rotated mode, but no target page set? Fallback or log error.
        console.warn("In rotated view but no target page number set in appState. Defaulting to currentPage.");
        leftPageNumToRender = pdfState.currentPage;
    }
    // *** END CHANGE ***

    // *** REVERTED: Reset current lock state before evaluation (uses reverted globals) ***
    isTimeLockActive = false;
    currentPageLockStartTime = 0;
    requiredReadingTime = 0;
    currentLockType = null; // Reset lock type on every display update
    // *** END Reset time lock state ***

    // --- Render Left Page (Using determined page number) ---
    if (leftPageNumToRender >= 1 && leftPageNumToRender <= pdfState.totalPages) {
        // *** USE leftPageNumToRender HERE ***
        ui.leftPageNumDisplay.textContent = String(leftPageNumToRender);
        renderPromises.push(renderPage(leftPageNumToRender, 'left-page-canvas'));
    } else {
        ui.leftPageNumDisplay.textContent = '';
        const lCtx = ui.leftPageCanvas?.getContext('2d');
        if (lCtx) lCtx.clearRect(0, 0, ui.leftPageCanvas.width, ui.leftPageCanvas.height);
        clearPageLayers(ui.leftPageDiv);
        ui.leftPageDiv.classList.add(CSS_CLASS.PLACEHOLDER_PAGE);
        delete pdfState.currentViewports['left-page-canvas'];
    }

    // --- Prepare Right Page (Hide if rotated or single) ---
    ui.rightPageDiv.style.display = 'none'; // Hide initially or if rotated/single
    ui.rightPageDiv.classList.remove(CSS_CLASS.PLACEHOLDER_PAGE);
    const rCtx = ui.rightPageCanvas?.getContext('2d');
    if (rCtx) rCtx.clearRect(0, 0, ui.rightPageCanvas.width, ui.rightPageCanvas.height);
    clearPageLayers(ui.rightPageDiv);
    ui.rightPageNumDisplay.textContent = '';
    delete pdfState.currentViewports['right-page-canvas'];

    let actualRightPageNum = 0; // Initialize

    // --- Render Right Page (ONLY if in effective double-page view) ---
    if (isEffectiveDoublePageView) {
        // *** Keep existing logic for double page view ***
        actualRightPageNum = pdfState.currentPage + 1; // Calculate potential right page
        if (actualRightPageNum >= 1 && actualRightPageNum <= pdfState.totalPages) {
            ui.rightPageNumDisplay.textContent = String(actualRightPageNum);
            ui.rightPageDiv.style.display = 'flex'; // Show right page div ONLY in double view
            renderPromises.push(renderPage(actualRightPageNum, 'right-page-canvas'));
        } else if (pdfState.currentPage >= 1 && pdfState.currentPage <= pdfState.totalPages) {
            // Show placeholder if left exists but right is beyond total (in double view)
            ui.rightPageDiv.style.display = 'flex';
            ui.rightPageDiv.classList.add(CSS_CLASS.PLACEHOLDER_PAGE);
            ui.rightPageNumDisplay.textContent = '';
            actualRightPageNum = 0; // No actual content page rendered
        }
    }
    // *** If not isEffectiveDoublePageView (i.e., single or rotated), right page remains hidden ***

    // Wait for page rendering to complete
    await Promise.all(renderPromises);

    // --- Manage Edge Navigation Button Visibility ---
    const leftEdgeNavLeft = ui.leftPageDiv?.querySelector('.page-edge-left');
    const leftEdgeNavRight = ui.leftPageDiv?.querySelector('.page-edge-right');
    const rightEdgeNavLeft = ui.rightPageDiv?.querySelector('.page-edge-left');
    const rightEdgeNavRight = ui.rightPageDiv?.querySelector('.page-edge-right');

    if (isContentRotated) {
        // Explicitly hide ALL edge navs in rotated view
        if (leftEdgeNavLeft) leftEdgeNavLeft.style.display = 'none';
        if (leftEdgeNavRight) leftEdgeNavRight.style.display = 'none';
        if (rightEdgeNavLeft) rightEdgeNavLeft.style.display = 'none';
        if (rightEdgeNavRight) rightEdgeNavRight.style.display = 'none';
    }
    if (leftEdgeNavLeft) leftEdgeNavLeft.style.display = ''; // Always show left-most edge
    if (rightEdgeNavRight) rightEdgeNavRight.style.display = 'none'; // Hide by default
    if (leftEdgeNavRight) leftEdgeNavRight.style.display = 'none'; // Hide by default
    if (rightEdgeNavLeft) rightEdgeNavLeft.style.display = 'none'; // Hide by default

    if (isEffectiveDoublePageView) {
        if (rightEdgeNavRight && !ui.rightPageDiv?.classList.contains(CSS_CLASS.PLACEHOLDER_PAGE)) {
            rightEdgeNavRight.style.display = ''; // Show right-most edge if not placeholder
        }
        // Hide inner edges in double view
    } else { // Single Page / Rotated View
            if (leftEdgeNavRight) leftEdgeNavRight.style.display = ''; // Show right edge of the single page
    }


    // *** REVERTED: Calculate and set reading time lock based on EFFECTIVE view mode ***
    // *** MODIFIED: Added handling for isContentRotated ***
    if (isTimelockGloballyEnabled) {
        if (isContentRotated) {
            // --- Rotated View Lock Logic ---
            const rotatedPageNum = leftPageNumToRender; // The page actually being viewed
            const rotatedViewport = pdfState.currentViewports['left-page-canvas'];
            let timeRotated = 0;
            if (rotatedPageNum >= 1 && rotatedPageNum <= pdfState.totalPages && rotatedViewport) {
                timeRotated = await calculatePageReadingTime(rotatedPageNum, rotatedViewport);
            }

            // Lock is associated with the specific rotated page number
            if (completedTimeLockPages.has(rotatedPageNum)) {
                updateStatus(`Time lock previously completed for rotated page ${rotatedPageNum}. Skipping set.`);
            } else if (timeRotated > 0) {
                requiredReadingTime = timeRotated;
                currentPageLockStartTime = Date.now();
                isTimeLockActive = true;
                currentLockType = 'pdf'; // Still a PDF lock
                updateStatus(`Time lock SET (Rotated View) for page ${rotatedPageNum}. Time: ${requiredReadingTime}s`);
            } else {
                    updateStatus(`Time lock NOT SET for rotated page ${rotatedPageNum} (time=0 or already completed).`);
            }
                // --- End Rotated View Lock Logic ---
        } else if (isEffectiveDoublePageView) {
            // --- Double Page View Lock Logic (existing reverted logic) ---
                const leftViewport = pdfState.currentViewports['left-page-canvas'];
                const rightViewport = pdfState.currentViewports['right-page-canvas']; // Will be null if right page isn't rendered

                let timeLeft = 0;
                if (pdfState.currentPage >= 1 && pdfState.currentPage <= pdfState.totalPages && leftViewport) {
                    timeLeft = await calculatePageReadingTime(pdfState.currentPage, leftViewport);
                }
                let timeRight = 0;
                // Only add right page time if it was actually rendered (not placeholder)
                if (actualRightPageNum > 0 && rightViewport) {
                    timeRight = await calculatePageReadingTime(actualRightPageNum, rightViewport);
                }

                const timeForPair = timeLeft + timeRight;
                const firstPageOfCurrentPair = pdfState.currentPage; // Lock associated with the ODD starting page

                if (completedTimeLockPages.has(firstPageOfCurrentPair)) {
                    updateStatus(`Time lock previously completed for pair starting ${firstPageOfCurrentPair}. Skipping set.`);
                } else if (timeForPair > 0) {
                    requiredReadingTime = timeForPair;
                    currentPageLockStartTime = Date.now();
                    isTimeLockActive = true;
                    currentLockType = 'pdf';
                    updateStatus(`Time lock SET (Double View - Pair) for pair starting ${firstPageOfCurrentPair}. Time: ${requiredReadingTime}s`);
                } else {
                        updateStatus(`Time lock NOT SET for pair starting ${firstPageOfCurrentPair} (time=0 or already completed).`);
                }
            // --- End Double Page View Lock Logic ---
        } else { // Single (Fullscreen) View
            // --- Single Page (Fullscreen) View Lock Logic (existing reverted logic) ---
            const currentPageNum = pdfState.currentPage; // The single page being displayed
                const isEvenPage = currentPageNum > 0 && currentPageNum % 2 === 0;

                if (isEvenPage) {
                    if (completedTimeLockPages.has(currentPageNum)) {
                        updateStatus(`Time lock previously completed for single page ${currentPageNum}. Skipping set.`);
                    } else {
                        const singlePageViewPort = pdfState.currentViewports['left-page-canvas'];
                        let timeSingle = 0;
                        if (currentPageNum >= 1 && currentPageNum <= pdfState.totalPages && singlePageViewPort) {
                            timeSingle = await calculatePageReadingTime(currentPageNum, singlePageViewPort);
                        }

                        if (timeSingle > 0) {
                            requiredReadingTime = timeSingle;
                            currentPageLockStartTime = Date.now();
                            isTimeLockActive = true;
                            currentLockType = 'pdf';
                            updateStatus(`Time lock SET (Single View - Even Page) for page ${currentPageNum}. Time: ${requiredReadingTime}s`);
                        } else {
                                updateStatus(`Time lock NOT SET for single page ${currentPageNum} (time=0 or already completed).`);
                        }
                    }
                } else {
                    updateStatus(`Time lock NOT APPLICABLE (Single View - Odd/Invalid Page) for page ${currentPageNum}.`);
                }
            // --- End Single Page (Fullscreen) View Lock Logic ---
        }
    } else {
        // Timelock is globally disabled, ensure no lock is set
        isTimeLockActive = false;
        requiredReadingTime = 0;
        currentPageLockStartTime = 0;
        currentLockType = null;
        updateStatus("Time lock globally DISABLED. Skipping lock calculation/set.");
    }
    // --- End REVERTED/MODIFIED Reading Time Logic ---

    // --- Final Updates ---
    preloadAdjacentPages(pdfState.currentPage);
    applyCurrentViewModeStyles(); // Apply scaling/rotation

    // --- Check for Popups (Keep from New Code) ---
    let shouldShowNotesPopup = false;
    const currentPageToCheckPopups = isContentRotated ? leftPageNumToRender : pdfState.currentPage; // Check popups based on the *content* being viewed

    if (currentPageToCheckPopups >= 1 && currentPageToCheckPopups <= pdfState.totalPages) {
        // Check Notes
        const notesInfo = pdfState.notesMapping[currentPageToCheckPopups.toString()];
        if (notesInfo) {
            updateStatus(`Notes Popup found for page ${currentPageToCheckPopups}. Showing.`);
            showNotesPopup(notesInfo.pdf, notesInfo.page);
            shouldShowNotesPopup = true;
        } else {
            hideNotesPopupIfNeeded(); // Hide if no notes for this page
        }

        // Check Iframe (only if Notes not showing)
        if (!shouldShowNotesPopup) {
            const iframeUrl = pdfState.iframeMappings[currentPageToCheckPopups.toString()];
            if (iframeUrl) {
                updateStatus(`Iframe Popup found for page ${currentPageToCheckPopups}. Showing.`);
                showIframePopup(iframeUrl);
            } else {
                hideIframePopupIfNeeded(); // Hide if no iframe for this page
            }
        } else {
                hideIframePopupIfNeeded(); // Hide if notes are showing
        }
    } else {
            hideNotesPopupIfNeeded(); // Hide if current page is invalid
            hideIframePopupIfNeeded();
    }

    updateStatus("Display update complete.");
}

    // --- Preloading (Keep from New Code - Uses new pdfState) ---
     function preloadAdjacentPages(currentPage) {
        if (!pdfState.pdfDocument) return;
        const lookahead = pdfState.isDoublePageView ? 2 : 1; // Look further ahead in double view
        const pagesToPreload = new Set();

        // Preload forward
        for (let i = 1; i <= lookahead; i++) {
            const nextPage = currentPage + (pdfState.isDoublePageView ? i * 2 : i);
            if (nextPage <= pdfState.totalPages) {
                pagesToPreload.add(nextPage);
                if (pdfState.isDoublePageView && nextPage + 1 <= pdfState.totalPages) {
                    pagesToPreload.add(nextPage + 1);
                }
            }
        }
        // Preload backward
        for (let i = 1; i <= lookahead; i++) {
            const prevPage = currentPage - (pdfState.isDoublePageView ? i * 2 : i);
            if (prevPage >= 1) {
                pagesToPreload.add(prevPage);
                if (pdfState.isDoublePageView && prevPage + 1 >= 1 && prevPage + 1 < currentPage) {
                    pagesToPreload.add(prevPage + 1);
                }
            }
        }

        // Filter out pages already loaded/cached or out of bounds
        const uniquePagesToLoad = [...pagesToPreload].filter(p =>
            p > 0 && p <= pdfState.totalPages && !pdfState.pageCache.has(p)
        );

        if (uniquePagesToLoad.length === 0) return;
        // updateStatus(`Preloading pages: ${uniquePagesToLoad.join(', ')}`);

        uniquePagesToLoad.forEach(pageNum => {
            pdfState.pdfDocument.getPage(pageNum).then(page => {
                // Simulate rendering dimensions to create a reasonably sized cache item
                const simWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w')) - (2 * appState.pagePadding);
                const simHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h')) - (2 * appState.pagePadding);
                const defaultViewport = page.getViewport({ scale: 1 });
                const scale = Math.min(simWidth / defaultViewport.width, simHeight / defaultViewport.height, 1); // Cap scale at 1
                const viewport = page.getViewport({ scale: scale });

                // Use a temporary canvas for rendering offscreen
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const outputScale = window.devicePixelRatio || 1;
                tempCanvas.width = Math.floor(viewport.width * outputScale);
                tempCanvas.height = Math.floor(viewport.height * outputScale);
                const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

                page.render({ canvasContext: tempCtx, transform: transform, viewport: viewport }).promise.then(() => {
                    // Add to cache only if not already added by another process
                    if (!pdfState.pageCache.has(pageNum)) {
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        pdfState.pageCache.set(pageNum, {
                             imageData,
                             width: tempCanvas.width,
                             height: tempCanvas.height,
                             styleWidth: Math.floor(viewport.width),
                             styleHeight: Math.floor(viewport.height),
                             viewport
                         });
                        trimCache();
                        // updateStatus(`Preloaded page ${pageNum} into cache.`);
                    }
                }).catch(err => console.warn(`Preloading render failed for page ${pageNum}: ${err.message}`));
            }).catch(err => console.warn(`Failed to get page ${pageNum} for preloading: ${err.message}`));
        });
    }

    // --- Reading Time Alert (Keep from New Code - Trigger logic reverted in checkReadingTimeLock) ---
    function showReadingTimeAlert(message = '<em>Please read the text first!</em>') {
        // Only show alert if timelock is globally enabled and blocking
        if (!isTimelockGloballyEnabled) return; // Use reverted global variable

        clearTimeout(appState.alertTimeout);
        clearTimeout(appState.alertWiggleTimeout);

        ui.readingTimeAlert.innerHTML = message;
        toggleVisibility(ui.readingTimeAlert, true); // Add .visible class (triggers fade-in/move-up and wiggle)

        // Timeout to hide the alert (triggers fade-out/move-down)
        appState.alertTimeout = setTimeout(() => {
            toggleVisibility(ui.readingTimeAlert, false);
        }, READING_TIME_ALERT_DURATION);

        // Timeout to remove wiggle class (animation already runs once via CSS)
        // No need for separate timer if animation-iteration-count: 1
    }


    // --- Reading Time Lock Check (REVERTED from Old Code) ---
    function checkReadingTimeLock() {
        // Called by jumpToPage only when moving forward.

        // *** FIRST: Check if timelock is globally enabled ***
        if (!isTimelockGloballyEnabled) {
            updateStatus(`Time lock check: Globally DISABLED. Allowing navigation.`);
            return false; // Not blocking
        }

        if (!isTimeLockActive) {
            // No lock is currently active (either pair or single even page), so allow navigation.
            updateStatus(`Time lock check: Lock is INACTIVE. Allowing navigation.`);
            return false; // Not blocking
        }

            // *** ADD THIS CHECK: Only block PDF nav if the lock is for PDF ***
    if (currentLockType !== null && currentLockType !== 'pdf') {
        updateStatus(`Time lock check (PDF Nav): Active lock is for '${currentLockType}', not PDF. Allowing PDF navigation.`);
        return false; // Don't block PDF nav because of an active popup lock
    }

        // A lock IS active.
        const elapsedSeconds = (Date.now() - currentPageLockStartTime) / 1000;
        // 'pdfState.currentPage' holds the page number the active lock is associated with
        // (odd start for pair lock, even page num for single lock) as set by updateDisplay.
        const lockAssociatedPage = pdfState.currentPage;

        if (elapsedSeconds < requiredReadingTime) {
            // Time is NOT up. Block navigation.
            updateStatus(`Time lock ACTIVE (Page/Pair ${lockAssociatedPage}): ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Blocking forward nav.`);
            showReadingTimeAlert(); // Alert will only show if globally enabled due to its own check
            return true; // Indicate lock IS preventing navigation
        } else {
            // Time IS up. Allow navigation and handle completion.
            updateStatus(`Time lock FINISHED (Page/Pair ${lockAssociatedPage}): ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Allowing forward nav.`);

            // Mark completion for this page/pair permanently in the Set using the associated page number.
            if (!completedTimeLockPages.has(lockAssociatedPage)) {
                completedTimeLockPages.add(lockAssociatedPage);
                updateStatus(`Page/Pair ${lockAssociatedPage} added to completed time lock set.`);
            }

            // Important: Deactivate lock for this *specific check*.
            // updateDisplay will reset isTimeLockActive anyway before potentially setting a new one for the *next* page view.
            isTimeLockActive = false; // Lock is passed/completed *for this navigation attempt*.
            requiredReadingTime = 0; // Reset required time as well
            currentPageLockStartTime = 0;
            return false; // Indicate lock is NOT preventing navigation for this attempt
        }
    }

    // --- Navigation (MODIFIED for LO popup check) ---
    function nextPage() {
        const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
        const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
        const isEffectiveDoublePageView = pdfState.isDoublePageView && !isFullscreen && !isContentRotated;

        const currentActualPage = pdfState.currentPage;
        const jumpIncrement = isEffectiveDoublePageView ? 2 : 1;
        let targetPageForJump = currentActualPage + jumpIncrement;

        // Clamp target page if it exceeds total pages
        if (targetPageForJump > pdfState.totalPages) {
             if (currentActualPage < pdfState.totalPages && !isEffectiveDoublePageView) {
                 // If in single page view and not on the last page, go to the last page
                 targetPageForJump = pdfState.totalPages;
             } else if (currentActualPage < pdfState.totalPages && isEffectiveDoublePageView && targetPageForJump > pdfState.totalPages && currentActualPage % 2 !== 0) {
                 // If in double page view, on an odd page, and the next pair would exceed total, go to the last page (which will be shown alone)
                 targetPageForJump = pdfState.totalPages;
             } else {
                 // Already on the last possible view, do nothing.
                 updateStatus("NextPage called on last view. No action.");
                 return;
             }
        }

        // --- NEW: Check for LO Achievement ---
        // Find the LO milestone for the current view's LAST page.
        let potentialLoPage = -1;
        const currentRightPage = isEffectiveDoublePageView ? currentActualPage + 1 : -1;
        const lastPageInView = Math.max(currentActualPage, currentRightPage);

        // Find the specific LO matching the last page of the *current* view
        const currentLo = appState.learningOutcomes.find(lo => lo.page_number === lastPageInView);

        if (currentLo) {
             potentialLoPage = currentLo.page_number;
             // Check if this LO has *already been passed* using the milestone's class
             const milestoneElement = ui.loMilestonesContainer?.querySelector(`.lo-milestone[data-lo-page="${potentialLoPage}"]`);
             const alreadyPassed = milestoneElement?.classList.contains(CSS_CLASS.LO_PASSED);

             if (!alreadyPassed) {
                updateStatus(`LO Milestone found on page ${potentialLoPage}. Showing achievement popup before navigating to ${targetPageForJump}.`);
                showLoAchievementPopup(currentLo, targetPageForJump);
                return; // Stop nextPage here, popup handler will call jumpToPage
             } else {
                updateStatus(`LO Milestone on page ${potentialLoPage} already passed. Skipping popup.`);
             }
        }
        // --- END NEW LO CHECK ---

        // If no relevant LO popup, proceed with jump directly
        if (targetPageForJump >= 1 && targetPageForJump <= pdfState.totalPages) {
            jumpToPage(targetPageForJump);
        } else if (targetPageForJump > pdfState.totalPages) {
            // This handles the case where the clamped targetPageForJump was the very last page
            jumpToPage(pdfState.totalPages);
        }
    }

    function prevPage() {
        const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
        const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
        const isEffectiveDoublePageView = pdfState.isDoublePageView && !isFullscreen && !isContentRotated;
        const decrement = isEffectiveDoublePageView ? 2 : 1;
        const targetPage = pdfState.currentPage - decrement;

        if (targetPage >= 1) {
            jumpToPage(targetPage);
        } else if (pdfState.currentPage > 1) {
            // If decrement goes below 1, just jump to page 1
            jumpToPage(1);
        }
        // Otherwise, already on page 1, do nothing.
    }

    // --- JumpToPage (REVERTED Timelock Logic, uses new pdfState/UI) ---
    function jumpToPage(pageNum){
        if (!pdfState.pdfDocument || pageNum < 1 || pageNum > pdfState.totalPages){
            console.warn(`Jump to page ${pageNum} out of bounds (1-${pdfState.totalPages})`);
            return;
        }

        let targetStartPage = pageNum;
        // Ensure targetStartPage is always odd for double page view (unless it's page 1 or the very last page if odd)
        const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
        const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
        const isEffectiveDoublePageView = pdfState.isDoublePageView && !isFullscreen && !isContentRotated;

        if (isEffectiveDoublePageView && targetStartPage > 1 && targetStartPage % 2 === 0) {
            targetStartPage--;
        }

        const currentStartPage = pdfState.currentPage;
        if (targetStartPage === currentStartPage) {
             updateStatus(`Jump target (${targetStartPage}) is same as current (${currentStartPage}). No action.`);
             // Keep slider updated if user clicked the current page value on the slider
             if (document.activeElement === ui.slider) {
                 updateSliderPosition();
             }
             return;
        }

        const isMovingForward = targetStartPage > currentStartPage;

        // *** REVERTED Lock Check Logic ***
        if (isMovingForward) {
            updateStatus(`Moving forward from ${currentStartPage} to ${targetStartPage}. Checking time lock...`);
            if (checkReadingTimeLock()) { // Calls the reverted function
                updateStatus(`Navigation blocked by time lock.`);
                if (ui.slider && (document.activeElement === ui.slider || (typeof event !== 'undefined' && event?.target === ui.slider))) {
                    updateSliderPosition(); // Reset slider if it triggered the block
                }
                return; // Block the jump
            }
            updateStatus(`Time lock passed/completed/disabled. Proceeding with jump.`);
        } else { // Moving backward
            updateStatus(`Moving backward from ${currentStartPage} to ${targetStartPage}. Skipping time lock check.`);
            // Clear any active lock if moving backward (using reverted globals)
            if (isTimeLockActive) {
                 currentLockType = null; // *** Reset type ***
                 updateStatus("Clearing active time lock due to backward navigation.");
                 isTimeLockActive = false;
                 requiredReadingTime = 0;
                 currentPageLockStartTime = 0;
            }
        }
        // *** End REVERTED Lock Check Logic ***

        // --- Perform Navigation (Uses New Code State) ---
        updateStatus(`Jumping to page ${targetStartPage} (requested ${pageNum})`);
        pdfState.currentPage = targetStartPage;
        updateSliderPosition(targetStartPage);
        
        // Update furthest read page if moving forward (tracks highest *starting* page of a view)
        if (isMovingForward && targetStartPage > userState.readingProgress.furthestPage) {
            userState.readingProgress.furthestPage = targetStartPage;
            updateStatus(`Furthest page updated to: ${userState.readingProgress.furthestPage}`);
            // In a real app, you might save userState.readingProgress here
        }

        resetPopupStates(); // Hide any open popups (including LO popup)

        updateDisplay(); // Render new page(s), calculates next lock state (using reverted logic), check for popups
        manageToolbar(false); // Hide toolbars (using reverted function)
        manageLeftToolbar(false); // Hide toolbars (using reverted function)
    }

    // --- START: New function to check handle state ---
    function checkAndApplyHandleState() {
        if (!ui.bookSpread || !ui.rightToolbar || !ui.leftToolbar) return; // Elements needed

        const viewportWidth = window.innerWidth;
        const bookRect = ui.bookSpread.getBoundingClientRect();
        // Get the CURRENT width of the book spread as displayed on screen
        const scaledBookWidth = bookRect.width;

        // Threshold: If book takes up > 85% of viewport width, float handles
        const overlapThreshold = 0.85;
        const shouldFloat = (scaledBookWidth > viewportWidth * overlapThreshold);

        // Toggle classes on toolbars AND body
        ui.rightToolbar.classList.toggle('handle-floated-top-right', shouldFloat);
        ui.leftToolbar.classList.toggle('handle-floated-top-left', shouldFloat);
        ui.body.classList.toggle('right-handle-floated', shouldFloat);
        ui.body.classList.toggle('left-handle-floated', shouldFloat);

        // Optional: Log status
        // updateStatus(`Handles floated: ${shouldFloat} (Book: ${Math.round(scaledBookWidth)}px, Viewport: ${viewportWidth}px)`);

        // If handles are floated, ensure main toolbars are hidden unless explicitly shown
        // This prevents hover on the *edge* from showing the main bar when handle is floated
        if (shouldFloat) {
            // If toolbar isn't explicitly visible (via click), hide it.
            if (!ui.rightToolbar.classList.contains('visible')) {
                manageToolbar(false);
            }
             if (!ui.leftToolbar.classList.contains('visible')) {
                manageLeftToolbar(false);
            }
        }
    }
    // --- END: New function ---

    // --- View Modes (Keep from New Code, uses new state/UI) ---
    function applyCurrentViewModeStyles() {
        if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE) || !ui.bookSpread) return;

        const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
        const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
        const isEffectiveSinglePage = isFullscreen || isContentRotated || !pdfState.isDoublePageView;

        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const bookWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w'));
        const bookHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h'));

        let scale = 1;
        let transformValue = 'translate(-50%, -50%)'; // Base centering

        if (isContentRotated) {
            // Calculate scale based on rotated dimensions
            const scaleX = viewportWidth / bookHeight;
            const scaleY = viewportHeight / bookWidth;
            scale = Math.min(scaleX, scaleY) * 0.98; // Add padding
            transformValue = `translate(-50%, -50%) rotate(90deg) scale(${scale})`;
        } else {
            // Calculate scale based on normal dimensions
            const totalWidth = isEffectiveSinglePage ? bookWidth : bookWidth * 2;
            const scaleX = viewportWidth / totalWidth;
            const scaleY = viewportHeight / bookHeight;
            scale = Math.min(scaleX, scaleY) * 0.98; // Add padding
            transformValue = `translate(-50%, -50%) scale(${scale})`;
        }

        ui.bookSpread.style.transformOrigin = 'center center';
        ui.bookSpread.style.transform = transformValue;
        // Visibility of #return-view-fixed-btn is controlled purely by CSS based on body classes
        checkAndApplyHandleState(); // Check if handles need floating after scaling
    }

    async function setRotatedView(targetPageNum = null) { // Accept optional target page
    const wasRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);

    if (wasRotated) {
        updateStatus("Setting back to previous view (Double/Single)");
        ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE);
        appState.rotatedViewTargetPageNum = null; // Clear target when leaving rotated view
        // Restore intended view mode (fullscreen if book was set to single page)
        if (!pdfState.isDoublePageView) {
            ui.body.classList.add(CSS_CLASS.FULLSCREEN_MODE);
        }
         // Adjust current page if needed when going back TO double view from rotated
         if (pdfState.isDoublePageView && pdfState.currentPage > 1 && pdfState.currentPage % 2 === 0) {
             updateStatus(`Adjusting current page from ${pdfState.currentPage} to ${pdfState.currentPage - 1} for double view restore.`);
             pdfState.currentPage--;
         }
    } else if (targetPageNum !== null) { // Only rotate if a valid target was provided
        updateStatus(`Setting Content Rotated View for page ${targetPageNum}`);
        appState.rotatedViewTargetPageNum = targetPageNum; // Store the target page
        ui.body.classList.remove(CSS_CLASS.FULLSCREEN_MODE); // Ensure fullscreen is off
        ui.body.classList.add(CSS_CLASS.CONTENT_ROTATED_MODE);
    } else {
         console.warn("setRotatedView called without a target page number when entering rotated mode.");
         return; // Don't proceed if no target page provided
    }

    resetPopupStates();
    await updateDisplay(); // Recalculates lock (using reverted logic), renders based on new classes
    manageToolbar(false); manageLeftToolbar(false); // Use reverted functions
    updateSliderTotalPages(); // Slider max might change if view conceptually changes pages displayed
    updateSliderPosition();
}

    async function setSinglePageView() {
        const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
        const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
        // If already in the desired state (single page view = fullscreen, not rotated)
        if (!pdfState.isDoublePageView && isFullscreen && !isContentRotated) return;

        updateStatus("Setting Single Page View (Fullscreen Mode)");
        pdfState.isDoublePageView = false; // Set the book's *intended* view state
        ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE);
        ui.body.classList.add(CSS_CLASS.FULLSCREEN_MODE);

        resetPopupStates();
        await updateDisplay(); // Render based on new state (calls reverted lock logic)
        manageToolbar(false); manageLeftToolbar(false); // Use reverted functions
        updateSliderTotalPages(); updateSliderPosition();
    }

    async function setDoublePageView() {
        const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
        const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
        // If already in the desired state (double page intended, not fullscreen, not rotated)
        if (pdfState.isDoublePageView && !isFullscreen && !isContentRotated) return;

        updateStatus("Setting Double Page View");
        pdfState.isDoublePageView = true; // Set the book's *intended* view state
        ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE, CSS_CLASS.FULLSCREEN_MODE);

        // If current page is even, adjust to the previous odd page for double view start
        if (pdfState.currentPage > 1 && pdfState.currentPage % 2 === 0) {
            updateStatus(`Adjusting current page from ${pdfState.currentPage} to ${pdfState.currentPage - 1} for double view.`);
            pdfState.currentPage--;
        }

        resetPopupStates();
        await updateDisplay(); // Render based on new state (calls reverted lock logic)
        manageToolbar(false); manageLeftToolbar(false); // Use reverted functions
        updateSliderTotalPages(); updateSliderPosition(); // Update slider value and text
    }

// --- NEW: Calculate Video Duration for Timelock ---
function calculateVideoDuration(url) {
    const DEFAULT_VIDEO_LOCK_TIME = 60; // Default seconds if times can't be parsed
    try {
        const urlObj = new URL(url);
        const params = urlObj.searchParams;

        // Common parameters (YouTube: t=start_seconds, Vimeo: t=start_seconds)
        // YouTube also uses start=seconds, end=seconds in embed URLs often
        let startTime = null;
        let endTime = null;

        if (params.has('start')) {
            startTime = parseInt(params.get('start'), 10);
        } else if (params.has('t')) {
             // Handle formats like 1m30s or just seconds
             const tParam = params.get('t');
             if (tParam.includes('m') || tParam.includes('s')) {
                 let totalSeconds = 0;
                 const minutesMatch = tParam.match(/(\d+)m/);
                 const secondsMatch = tParam.match(/(\d+)s/);
                 if (minutesMatch) totalSeconds += parseInt(minutesMatch[1], 10) * 60;
                 if (secondsMatch) totalSeconds += parseInt(secondsMatch[1], 10);
                 startTime = totalSeconds > 0 ? totalSeconds : null;
             } else {
                 startTime = parseInt(tParam, 10);
             }
        }

        if (params.has('end')) {
            endTime = parseInt(params.get('end'), 10);
        }

        // Clean up NaN values
        startTime = isNaN(startTime) ? null : startTime;
        endTime = isNaN(endTime) ? null : endTime;

        if (startTime !== null && endTime !== null && endTime > startTime) {
            updateStatus(`Timelock duration from start/end params: ${endTime - startTime}s`);
            return endTime - startTime;
        } else if (startTime !== null) {
            // If only start time is given, we can't know the intended end. Use default.
            updateStatus(`Timelock duration using default (only start time found).`);
            return DEFAULT_VIDEO_LOCK_TIME;
        } else {
            // No valid start/end times found. Use default.
            // We cannot reliably get the video length from the parent window.
            updateStatus(`Timelock duration using default (no time params found).`);
            return DEFAULT_VIDEO_LOCK_TIME;
        }
    } catch (e) {
        console.warn("Error parsing video URL for timelock duration, using default.", e);
        return DEFAULT_VIDEO_LOCK_TIME;
    }
}
// --- End NEW Video Duration Calculation ---
    
    // --- UI Toggles (Keep from New Code) ---

    function showLoading(msg = 'Processing...') {
        if (ui.loadingOverlay && ui.loadingMessage) {
            ui.loadingMessage.textContent = msg;
            toggleVisibility(ui.loadingOverlay, true);
        }
    }
    function hideLoading() { toggleVisibility(ui.loadingOverlay, false); }

    // --- Slider Logic (Keep from New Code - Uses reverted jumpToPage internally, MODIFIED for LOs) ---
    function showPageSlider() {
        if (!ui.sliderContainer || ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;
        clearTimeout(appState.sliderHideTimeout); // Always clear timer when showing
        toggleVisibility(ui.sliderContainer, true); // Add .visible class
    }

    function hidePageSlider() {
        // Only hide if not dragging and not hovered
        if (!appState.isDraggingSlider && !appState.isSliderAreaHovered) {
            toggleVisibility(ui.sliderContainer, false);
        }
    }

    function startSliderHideTimer() {
        clearTimeout(appState.sliderHideTimeout);
        appState.sliderHideTimeout = setTimeout(hidePageSlider, SLIDER_HIDE_DELAY);
    }

    function initPageSlider() {
        if (!ui.slider || !ui.sliderContainer || !ui.sliderTriggerZone || !ui.loMilestonesContainer || !ui.loTooltip) {
            console.error("Slider elements, trigger zone, LO container, or LO tooltip not found"); return;
        }

        setTimeout(checkAndApplyHandleState, 500);

        // --- Hover Logic ---
        const handleSliderAreaEnter = () => {
            if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;
            appState.isSliderAreaHovered = true;
            showPageSlider(); // This also clears the hide timer
        };

        const handleSliderAreaLeave = () => {
            appState.isSliderAreaHovered = false;
            // Start timer only if not currently dragging the slider thumb
            if (!appState.isDraggingSlider) {
                startSliderHideTimer();
            }
        };

        // Apply hover logic to BOTH the trigger zone and the slider container itself
        ui.sliderTriggerZone.addEventListener('mouseenter', handleSliderAreaEnter);
        ui.sliderTriggerZone.addEventListener('mouseleave', handleSliderAreaLeave);
        ui.sliderContainer.addEventListener('mouseenter', handleSliderAreaEnter);
        ui.sliderContainer.addEventListener('mouseleave', handleSliderAreaLeave);

        // --- Drag/Input Logic ---
        const handleSliderInput = () => {
            if (!appState.isDraggingSlider) return; // Only update display during drag
            const targetPageValue = parseInt(ui.slider.value, 10);
            updateSliderInfoText(targetPageValue); // Update text dynamically
            updateSliderStyle(ui.slider, targetPageValue);
            updateMilestoneColors(targetPageValue); // Update LO colors during drag
            // clearTimeout(appState.sliderHideTimeout); // Keep slider visible while interacting // Already done in handlePointerDown
        };

        const handlePointerDown = () => {
             if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;
             appState.isDraggingSlider = true;
             clearTimeout(appState.sliderHideTimeout); // Prevent hiding while dragging
             // Add class to body? Optional, for styling during drag

        };

        const handlePointerUpOrChange = (event) => { // Added event
            
            if (ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE)) {
        updateStatus("Slider interaction blocked: Content Rotated Mode active.");
        triggerRotateButtonIndication(); // Trigger the glow/wiggle effect
        // Reset slider visually to the actual current page immediately
        updateSliderPosition(pdfState.currentPage);
        event.preventDefault(); // Stop any potential default slider behavior
        event.stopPropagation(); // Stop the event from bubbling further
        // If dragging ended, ensure the state is reset
        if (appState.isDraggingSlider) {
             appState.isDraggingSlider = false;
             // Restart hide timer if needed (mouse might be outside area now)
             if (!appState.isSliderAreaHovered) {
                startSliderHideTimer();
             }
        }
        return; // Stop further processing for this event
    } 
            if (ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE)) return; // Prevent updates if rotated
             if (!appState.isDraggingSlider && event.type !== 'change') return;
             const wasDragging = appState.isDraggingSlider;
             appState.isDraggingSlider = false;
             // Remove class from body?

             const targetPageValue = parseInt(ui.slider.value, 10);
             updateStatus(`Slider action ended at value: ${targetPageValue}`);
             jumpToPage(targetPageValue); // Navigate (calls reverted lock logic)

             // Restart hide timer if the mouse isn't still over the slider area
             if (!appState.isSliderAreaHovered) {
                 startSliderHideTimer();
             }
         };

         const handleLostPointer = () => {
            if (appState.isDraggingSlider) {
                appState.isDraggingSlider = false;
                // Remove class from body?
                const targetPageValue = parseInt(ui.slider.value, 10);
                updateStatus(`Slider lost capture at value: ${targetPageValue}`);
                jumpToPage(targetPageValue); // Navigate (calls reverted lock logic)
                 // Restart hide timer if the mouse isn't still over the slider area
                 if (!appState.isSliderAreaHovered) {
                    startSliderHideTimer();
                 }
            }
        };

        ui.slider.addEventListener('input', handleSliderInput);
        ui.slider.addEventListener('pointerdown', handlePointerDown);
        ui.slider.addEventListener('pointerup', handlePointerUpOrChange);
        ui.slider.addEventListener('change', handlePointerUpOrChange); // Handles clicks without drag
        ui.slider.addEventListener('lostpointercapture', handleLostPointer);

        renderSliderMilestones(); // Initial render of milestones
        updateSliderTotalPages();
        updateSliderPosition(); // Set initial state including milestone colors
    }

    function updateSliderInfoText(pageValue) {
    // Ensure the function only runs if the necessary elements exist.
    if (!ui.currentPageDisplay || !ui.totalPagesDisplay) {
        console.warn("updateSliderInfoText: Missing UI elements for page display.");
        return;
    }

    // Validate pageValue is a usable number, default to 1 if not
    const currentPageValue = Number.isInteger(pageValue) && pageValue >= 1 ? pageValue : 1;

    // Determine the current effective view mode
    const isFullscreenCurrent = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
    const isContentRotatedCurrent = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
    const isSingleEffective = isFullscreenCurrent || isContentRotatedCurrent || !pdfState.isDoublePageView;
    const isDoubleEffective = !isSingleEffective;

    let pageText; // Variable to hold the final display text

    if (isDoubleEffective) {
        // --- Double Page View Logic ---
        let displayPageStart = currentPageValue;
        // If the slider value corresponds to an even page, adjust the display
        // to show the pair starting from the previous odd page.
        if (displayPageStart > 1 && displayPageStart % 2 === 0) {
            displayPageStart--;
        }

        // Check if the *next* page exists to form a valid pair
        if (displayPageStart + 1 <= pdfState.totalPages) {
            // Display as a pair "Page X-Y"
            pageText = `Page ${displayPageStart}-${displayPageStart + 1}`;
        } else {
            // It's the very last page, display singly "Page X" using the actual last page number
            pageText = `Page ${pdfState.totalPages}`; // Use pdfState.totalPages directly here
        }
    } else {
        // --- Single Page View Logic ---
        // Display singly "Page X" using the exact value from the slider/navigation
        pageText = `Page ${currentPageValue}`;
    }

    // Update the text content of the span
    ui.currentPageDisplay.textContent = pageText;
}

    function updateSliderTotalPages() {
        if (ui.slider && ui.totalPagesDisplay) {
            const total = pdfState.totalPages > 0 ? pdfState.totalPages : 1;
            ui.slider.max = total;
            ui.totalPagesDisplay.textContent = total;
            renderSliderMilestones(); // Re-render milestones if total pages changes
            updateSliderStyle(ui.slider, ui.slider.value); // Update visual style
            updateMilestoneColors(parseInt(ui.slider.value, 10)); // Update colors based on current value
        }
    }

        function updateSliderPosition(currentPageForSlider) { // Takes page number as argument
        // Ensure all necessary UI elements and the PDF state are ready
        if (!ui.slider || !ui.currentPageDisplay || !ui.totalPagesDisplay) {
             console.warn("updateSliderPosition: Missing UI elements.");
             return; // Exit if essential UI is missing
        }

        let pageToUpdate = 1; // Default fallback

        // Determine the page number to use for the update
        if (pdfState.totalPages > 0 && currentPageForSlider !== undefined && currentPageForSlider !== null) {
            // Prioritize the passed argument if valid
            pageToUpdate = Math.max(1, Math.min(currentPageForSlider, pdfState.totalPages));
        } else if (pdfState.totalPages > 0) {
            // Fallback to current state if argument missing/invalid but PDF is loaded
            pageToUpdate = Math.max(1, Math.min(pdfState.currentPage, pdfState.totalPages));
             if (currentPageForSlider === undefined && appState.isReaderReady) {
                 // Only warn if called without argument when reader should be ready
                 console.warn("updateSliderPosition called without page number argument during active state. Using pdfState.currentPage as fallback.");
             }
        } else {
            // Fallback if PDF isn't loaded or totalPages is 0
            pageToUpdate = parseInt(ui.slider.min || 1);
        }

        // --- Perform the UI Updates ---

        // 1. Update the slider handle's numerical value
        ui.slider.value = pageToUpdate;

        // 2. Update the display text (e.g., "Page 5" or "Page 6-7")
        updateSliderInfoText(pageToUpdate); // Use the determined page number

        // 3. Update the slider's track fill style (visual progress)
        updateSliderStyle(ui.slider, pageToUpdate); // Use the determined page number

        // 4. Update the Learning Outcome milestone colors
        updateMilestoneColors(pageToUpdate); // Use the determined page number
    }

    // Updates the slider's track fill percentage
    function updateSliderStyle(slider, value) {
        if (!slider) return;
        const min = parseInt(slider.min || 1);
        const max = parseInt(slider.max || 1);
        const range = max > min ? max - min : 1;
        const percentage = ((parseInt(value) - min) / range) * 100;
        slider.style.setProperty('--slider-percent', `${Math.max(0, Math.min(100, percentage))}%`);
    }

    // --- NEW: LO Milestone Functions ---
    function renderSliderMilestones() {
        if (!ui.loMilestonesContainer || !ui.sliderTrack) return;
        ui.loMilestonesContainer.innerHTML = ''; // Clear existing

        if (appState.learningOutcomes.length === 0 || pdfState.totalPages <= 1) {
            return; // No LOs or not enough pages to display them meaningfully
        }

        const sliderWidth = ui.sliderTrack.offsetWidth; // Get width for positioning

        appState.learningOutcomes.forEach(lo => {
            const pageNum = lo.page_number;
            if (pageNum < 1 || pageNum > pdfState.totalPages) {
                console.warn(`LO for page ${pageNum} is out of bounds (1-${pdfState.totalPages}). Skipping.`);
                return;
            }

            const milestone = document.createElement('span');
            milestone.className = 'lo-milestone';
            milestone.textContent = lo.emoji;
            milestone.dataset.loText = lo.learning_outcome;
            milestone.dataset.loPage = pageNum;

            // Calculate position (percentage based)
            const percentage = pdfState.totalPages > 1 ? ((pageNum - 1) / (pdfState.totalPages - 1)) * 100 : 0;
            milestone.style.left = `${Math.max(0, Math.min(100, percentage))}%`;

            // Add hover listeners
            milestone.addEventListener('mouseenter', handleMilestoneEnter);
            milestone.addEventListener('mouseleave', handleMilestoneLeave);

            ui.loMilestonesContainer.appendChild(milestone);
        });

        updateMilestoneColors(pdfState.currentPage); // Ensure initial colors are set
    }

    function updateMilestoneColors(currentPage) {
        const milestones = ui.loMilestonesContainer?.querySelectorAll('.lo-milestone');
        if (!milestones) return;

        milestones.forEach(milestone => {
            const loPage = parseInt(milestone.dataset.loPage, 10);
            // Color if the user's *current starting page* is strictly GREATER than the LO page.
            // This means the user has navigated *past* the page where the LO occurs.
            milestone.classList.toggle(CSS_CLASS.LO_PASSED, currentPage > loPage);
        });
    }

    function handleMilestoneEnter(event) {
        const milestone = event.currentTarget;
        const loText = milestone.dataset.loText;
        const isPassed = milestone.classList.contains(CSS_CLASS.LO_PASSED); // Check if LO is passed

        // Apply temporary coloring only if it's NOT passed
        if (!isPassed) {
            milestone.classList.add(CSS_CLASS.HOVER_COLORED);
        }

        if (ui.loTooltip) {
             // Construct display text conditionally
            let displayText;
            const fallbackText = 'Learning Outcome';
            const checkmarkEmoji = '✅'; // Use the actual emoji

            if (isPassed) {
                // If passed: BOLD text + Emoji checkmark
                displayText = `<strong>${loText || fallbackText}</strong> ${checkmarkEmoji}`;
            } else {
                // If not passed: ITALIC text with LIGHTER FONT WEIGHT
                displayText = `<em><span style="font-weight: 400;">${loText || fallbackText}</span></em>`;
            }
            ui.loTooltip.innerHTML = displayText;

            // Position tooltip
            const milestoneRect = milestone.getBoundingClientRect();
            const tooltipRect = ui.loTooltip.getBoundingClientRect(); // Get current size
            let left = milestoneRect.left + (milestoneRect.width / 2) - (tooltipRect.width / 2);
            let top = milestoneRect.top - tooltipRect.height - LO_TOOLTIP_OFFSET_Y; // Position above

            // Prevent viewport overflow
            left = Math.max(5, Math.min(left, window.innerWidth - tooltipRect.width - 5));
            top = Math.max(5, top); // Prevent top overflow

            ui.loTooltip.style.left = `${left}px`;
            ui.loTooltip.style.top = `${top}px`;
            toggleVisibility(ui.loTooltip, true);
        }

        // Handle slider info text change (with fade)
        if (ui.sliderInfo) {
            clearTimeout(appState.sliderInfoFadeTimeout);
            appState.sliderInfoFadeTimeout = null; // Reset timeout ID
            if (appState.originalSliderInfoText === null && !ui.sliderInfo.innerHTML.includes('<em') && !ui.sliderInfo.innerHTML.includes('<strong')) {
                appState.originalSliderInfoText = ui.sliderInfo.innerHTML;
            }
            ui.sliderInfo.style.opacity = 0; // Start fade out
            appState.sliderInfoFadeTimeout = setTimeout(() => {
                // Use the same display text logic as the tooltip for consistency
                let infoDisplayText;
                const fallbackText = 'Learning Outcome';
                const checkmarkEmoji = '✅';
                if (isPassed) { infoDisplayText = `<strong>${loText || fallbackText}</strong> ${checkmarkEmoji}`; }
                else { infoDisplayText = `<em><span style="font-weight: 400;">${loText || fallbackText}</span></em>`; }
                ui.sliderInfo.innerHTML = infoDisplayText;
                ui.sliderInfo.style.opacity = ''; // Let CSS handle base opacity (fade in)
                appState.sliderInfoFadeTimeout = null;
            }, 125); // Short delay
        }
    }

    function handleMilestoneLeave(event) {
        const milestone = event.currentTarget;
        milestone.classList.remove(CSS_CLASS.HOVER_COLORED);

        // Hide tooltip
        if (ui.loTooltip) {
            toggleVisibility(ui.loTooltip, false);
        }

        // Restore slider info text (with fade)
        if (ui.sliderInfo && appState.originalSliderInfoText !== null) {
            clearTimeout(appState.sliderInfoFadeTimeout);
            appState.sliderInfoFadeTimeout = null;
            ui.sliderInfo.style.opacity = 0; // Start fade out
            appState.sliderInfoFadeTimeout = setTimeout(() => {
                ui.sliderInfo.innerHTML = appState.originalSliderInfoText;
                appState.originalSliderInfoText = null; // Clear stored text
                ui.sliderInfo.style.opacity = ''; // Let CSS handle base opacity (fade in)
                appState.sliderInfoFadeTimeout = null;
            }, 200); // Slightly longer delay to restore
        } else if (ui.sliderInfo && !appState.sliderInfoFadeTimeout) {
             // Safety check: If mouse leaves and we weren't showing LO text, ensure opacity is correct
             ui.sliderInfo.style.opacity = ''; // Restore default opacity
        }
    }
    // --- END: LO Milestone Functions ---

    // --- NEW: LO Achievement Popup Functions ---
    function showLoAchievementPopup(learningOutcomeObject, nextPageTarget) {
        if (!ui.loAchievementBackdrop || !ui.loAchievementPopup || !ui.loAchievementText || !ui.loContinueBtn) {
            console.error("Cannot show LO achievement popup: Missing elements.");
            jumpToPage(nextPageTarget);
            return;
        }

        appState.loPopupTargetPage = nextPageTarget;

        const emoji = learningOutcomeObject?.emoji || '💡';
        const loText = learningOutcomeObject?.learning_outcome || "A key concept!";

        // Create HTML with spans for styling: Emoji first, then Text
        const formattedText = `
            <span class="lo-popup-emoji">${emoji}</span>
            <span class="lo-popup-text"><strong>${loText}</strong></span>
        `;
        // Put this HTML inside the paragraph with id="lo-achievement-text"
        ui.loAchievementText.innerHTML = formattedText;

        // Show the popup
        toggleVisibility(ui.loAchievementBackdrop, true);
        toggleVisibility(ui.loAchievementPopup, true);
        ui.loContinueBtn.focus();
    }

    function hideLoAchievementPopup() {
        if (ui.loAchievementPopup?.classList.contains(CSS_CLASS.VISIBLE)) {
            toggleVisibility(ui.loAchievementBackdrop, false);
            toggleVisibility(ui.loAchievementPopup, false);
            if (appState.loPopupTargetPage !== null) {
                const targetPage = appState.loPopupTargetPage;
                appState.loPopupTargetPage = null;
                updateStatus(`LO Popup closed. Proceeding to page ${targetPage}.`);
                jumpToPage(targetPage);
            } else {
                 updateStatus("LO Popup closed (no target page stored).");
            }
        } else {
            appState.loPopupTargetPage = null;
        }
    }
    // --- END: LO Achievement Popup Functions ---


    // --- Data Loading (MODIFIED to load LO JSON) ---
    async function loadOverlayData(pdfUrl) {
        const overlayUrl = pdfUrl.replace(/\.pdf$/i, '.overlay.json');
        updateStatus(`Attempting to load overlay from: ${overlayUrl}`);
        pdfState.keywordDefinitions = {}; pdfState.pageKeywords = {}; pdfState.globalFirstInstanceLocation = {}; // Reset more state
        try {
            const response = await fetch(overlayUrl);
            if (!response.ok) {
                if (response.status !== 404) { console.warn(`Overlay fetch failed: HTTP ${response.status} for ${overlayUrl}`); }
                else { updateStatus(`No overlay file found at ${overlayUrl}.`); }
                return false;
            }
            const data = await response.json();
            // *** MODIFICATION START: Validate new structure ***
            if (!data || typeof data.keywords !== 'object' || typeof data.pages !== 'object') {
                console.warn("Invalid overlay structure in JSON file."); return false;
            }
            // Process keywords expecting array format: [PoS, Definition]
            const processedKeywords = {};
            for (const [key, value] of Object.entries(data.keywords)) {
                 // Validate the array format for each keyword
                if (key && Array.isArray(value) && value.length >= 2 && typeof value[1] === 'string' && value[1]) {
                     processedKeywords[key] = value; // Store the array directly
                } else {
                     console.warn(`Invalid keyword entry skipped: Key='${key}', Value=${JSON.stringify(value)}. Expected ["(pos)", "definition"]`);
                }
            }
            pdfState.keywordDefinitions = processedKeywords; // Now stores { Keyword: ["(pos)", "definition"] }
            // *** MODIFICATION END ***

            // Process page keywords (keys as strings)
            const processedPages = {};
            for (const [pageNum, pageWords] of Object.entries(data.pages)) {
                if (pageNum && !isNaN(parseInt(pageNum)) && Array.isArray(pageWords) && pageWords.every(w => typeof w === 'string')) {
                    processedPages[pageNum.toString()] = pageWords;
                } else { console.warn(`Invalid page entry skipped: Page='${pageNum}'`); }
            }
            pdfState.pageKeywords = processedPages;
            updateStatus(`Overlay loaded: ${Object.keys(pdfState.keywordDefinitions).length} keywords, ${Object.keys(pdfState.pageKeywords).length} pages defined.`);
            return true;
        } catch (error) {
            console.warn(`Overlay fetch/parse error for ${overlayUrl}: ${error.message}.`);
            pdfState.keywordDefinitions = {}; pdfState.pageKeywords = {}; pdfState.globalFirstInstanceLocation = {}; return false;
        }
    }


    async function loadIframeData(pdfUrl) {
        const iframeDataUrl = pdfUrl.replace(/\.pdf$/i, '-iframes.json');
        updateStatus(`Attempting to load iframe data from: ${iframeDataUrl}`);
        pdfState.iframeMappings = {}; // Reset
        try {
            const response = await fetch(iframeDataUrl);
            if (!response.ok) {
                if (response.status === 404) {
                    updateStatus(`Iframe data file not found at ${iframeDataUrl}. No iframe popups will be shown.`);
                } else {
                    console.warn(`Iframe data fetch failed: HTTP error ${response.status} for ${iframeDataUrl}`);
                }
                return false;
            }
            const data = await response.json();
            if (!data || typeof data !== 'object' || Array.isArray(data)) {
                 console.warn("Invalid iframe data structure in JSON file. Expected an object { pageNum: urlString }.");
                 return false;
            }
            const validMappings = {};
            let count = 0;
            for (const [key, value] of Object.entries(data)) {
                const pageNum = parseInt(key, 10);
                if (!isNaN(pageNum) && pageNum > 0 && typeof value === 'string' && value.trim() !== '') {
                    validMappings[key.toString()] = value.trim(); // Store page num as string key
                    count++;
                } else {
                    console.warn(`Invalid iframe mapping skipped: Key='${key}', Value='${value}'`);
                }
            }
            pdfState.iframeMappings = validMappings;
            updateStatus(`Iframe data loaded successfully: ${count} mappings found.`);
            return true;
        } catch (error) {
            console.warn(`Iframe data fetch/parse error for ${iframeDataUrl}: ${error.message}. No iframe popups will be shown.`);
            pdfState.iframeMappings = {}; return false;
        }
    }

    // NEW: Load Learning Outcomes Data
    async function loadLearningOutcomes(pdfUrl) {
        // Assumes LO file follows pattern like chapter-2.LOs.json
        let loFileName = 'chapter-2.LOs.json'; // Default fallback
        try {
            const pathParts = pdfUrl.split('/');
            const pdfFileName = pathParts.pop() || ''; // Get filename
            const chapterMatch = pdfFileName.match(/chapter-(\d+)/i);
            if (chapterMatch && chapterMatch[0]) {
                loFileName = `${chapterMatch[0]}.LOs.json`;
            } else {
                 console.warn(`Could not derive chapter name from PDF URL '${pdfUrl}'. Using default LO file name: ${loFileName}`);
            }
        } catch (e) { console.warn("Error deriving LO file name:", e); }

        // Construct URL relative to the PDF's directory
        const pdfDir = pdfUrl.substring(0, pdfUrl.lastIndexOf('/') + 1);
        const loUrl = pdfDir + loFileName;

        updateStatus(`Attempting to load Learning Outcomes from: ${loUrl}`);
        appState.learningOutcomes = []; // Reset

        try {
            const response = await fetch(loUrl);
            if (!response.ok) {
                if (response.status === 404) {
                    updateStatus(`LO file not found at ${loUrl}. No LO milestones will be shown.`);
                } else {
                    console.warn(`LO data fetch failed: HTTP error ${response.status} for ${loUrl}`);
                }
                return false;
            }
            const data = await response.json();
            if (!Array.isArray(data)) {
                 console.warn("Invalid LO data structure in JSON file. Expected an array.");
                 return false;
            }

            const validLOs = [];
            let count = 0;
            data.forEach(item => {
                if (item && typeof item.emoji === 'string' && typeof item.learning_outcome === 'string' && typeof item.page_number === 'number' && Number.isInteger(item.page_number) && item.page_number > 0) {
                    validLOs.push({
                        emoji: item.emoji,
                        learning_outcome: item.learning_outcome,
                        page_number: item.page_number
                    });
                    count++;
                } else {
                     console.warn("Invalid LO item skipped:", item);
                }
            });

            // Sort LOs by page number for ordered processing/display
            validLOs.sort((a, b) => a.page_number - b.page_number);
            appState.learningOutcomes = validLOs;
            updateStatus(`LO data loaded successfully: ${count} valid outcomes found.`);
            return true;
        } catch (error) {
            console.warn(`LO data fetch/parse error for ${loUrl}: ${error.message}. No LO milestones will be shown.`);
            appState.learningOutcomes = []; return false;
        }
    }
    // --- END NEW ---

    async function findFirstKeywordInstances() {
        updateStatus("Starting pre-scan for first keyword instances...");
        pdfState.globalFirstInstanceLocation = {}; // Reset
        const lowerCaseKeywordsToFind = new Set(Object.keys(pdfState.keywordDefinitions).map(k => k.toLowerCase()));

        if (lowerCaseKeywordsToFind.size === 0 || !pdfState.pdfDocument) {
            updateStatus("Pre-scan skipped: No keywords defined or PDF not loaded.");
            return;
        }

        const totalPages = pdfState.pdfDocument.numPages;
        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
            if (lowerCaseKeywordsToFind.size === 0) {
                updateStatus("Pre-scan finished early: All first instances found."); break;
            }
            try {
                const page = await pdfState.pdfDocument.getPage(pageNum);
                const textContent = await page.getTextContent({ normalizeWhitespace: true });
                const items = textContent.items;

                for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                    const item = items[itemIndex];
                    const itemText = item.str;
                    if (!itemText || itemText.trim().length === 0) continue;

                    // Iterate over remaining keywords to find
                    const currentKeywordsToCheck = Array.from(lowerCaseKeywordsToFind); // Copy the set for iteration
                    for (const keywordLower of currentKeywordsToCheck) {
                        // Find the original casing from the definitions keys (since pageKeywords might not have it if it's not on this page)
                         let originalKeywordForRegex = keywordLower; // Fallback
                         const originalDefKey = Object.keys(pdfState.keywordDefinitions).find(k => k.toLowerCase() === keywordLower);
                         if (originalDefKey) originalKeywordForRegex = originalDefKey;

                        // Use original casing for regex boundary check but lowercase for tracking
                        const escapedKeyword = originalKeywordForRegex.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                        // Ensure the regex matches the specific keyword as a whole word, case-insensitively
                        const regex = new RegExp(`\\b(${escapedKeyword})\\b`, 'gi');
                        let match;

                        // Check all matches within the current text item
                        while ((match = regex.exec(itemText)) !== null) {
                            // Check if we've already found this keyword
                            if (pdfState.globalFirstInstanceLocation[keywordLower]) continue;

                            // Check if the *matched* string is exactly the keyword (case-insensitive)
                            // This avoids partial matches if the regex accidentally captures more
                            if (match[1].toLowerCase() === keywordLower) {
                                const matchIndex = match.index;
                                pdfState.globalFirstInstanceLocation[keywordLower] = { pageNum, itemIndex, matchIndex };
                                lowerCaseKeywordsToFind.delete(keywordLower); // Remove found keyword
                                // console.log(`Found first instance of '${keywordLower}' on page ${pageNum}, item ${itemIndex}, index ${matchIndex}`);
                                if (lowerCaseKeywordsToFind.size === 0) break; // Exit inner loop if all found
                            }
                        }
                         if (lowerCaseKeywordsToFind.size === 0) break; // Exit outer loop if all found
                    }
                }
                 if (lowerCaseKeywordsToFind.size === 0) break; // Exit page loop if all found
            } catch (error) {
                console.warn(`Error processing page ${pageNum} during keyword pre-scan:`, error);
            }
        }
        updateStatus(`Pre-scan complete. Found first instances for ${Object.keys(pdfState.globalFirstInstanceLocation).length} keywords.`);
    }

    // --- NEW: Load Notes Data from External JSON ---
async function loadNotesData(pdfUrl) {
    let notesJsonUrl = '';
    try {
        // Derive notes JSON filename from PDF filename
        const pdfPathParts = pdfUrl.split('/');
        const pdfFilename = pdfPathParts.pop() || '';
        const baseFilename = pdfFilename.replace(/\.pdf$/i, '');
        const notesJsonFilename = `${baseFilename}-notes.json`;
        // Reconstruct URL in the same directory
        const pdfDir = pdfUrl.substring(0, pdfUrl.lastIndexOf('/') + 1);
        notesJsonUrl = pdfDir + notesJsonFilename;

        updateStatus(`Attempting to load notes data from: ${notesJsonUrl}`);
        pdfState.notesMapping = {}; // Reset mapping before load attempt

        const response = await fetch(notesJsonUrl);

        if (!response.ok) {
            if (response.status === 404) {
                updateStatus(`Notes data file not found at ${notesJsonUrl}. No notes popups will be configured for this chapter.`);
                // It's okay if the file doesn't exist, just means no notes.
                return false; // Indicate no notes loaded
            } else {
                // Other HTTP error
                console.warn(`Notes data fetch failed: HTTP error ${response.status} for ${notesJsonUrl}`);
                return false; // Indicate failure
            }
        }

        const data = await response.json();

        // Validate that the fetched data is an array
        if (!Array.isArray(data)) {
            console.warn(`Invalid notes data structure in ${notesJsonUrl}. Expected an array.`);
            pdfState.notesMapping = {}; // Ensure mapping is empty on error
            return false; // Indicate failure
        }

        // Use the existing processing function
        pdfState.notesMapping = processNotesData(data); // Populates pdfState.notesMapping
        updateStatus(`Notes data loaded successfully from ${notesJsonUrl}.`);
        return true; // Indicate success

    } catch (error) {
        console.warn(`Notes data fetch/parse error for ${notesJsonUrl}: ${error.message}.`);
        pdfState.notesMapping = {}; // Ensure mapping is empty on error
        return false; // Indicate failure
    }
}
// --- END NEW ---
    
    // --- PDF Loading (MODIFIED Timelock Reset, uses new pdfState otherwise + Button Logic + LO Load) ---
    async function loadPdf(pdfUrl) {
    updateStatus(`loadPdf started for: ${pdfUrl}`);
    // --- Reset State ---
    pdfState.pageCache.clear(); pdfState.currentViewports = {}; pdfState.keywordDefinitions = {}; pdfState.pageKeywords = {}; pdfState.globalFirstInstanceLocation = {}; pdfState.iframeMappings = {}; pdfState.outline = []; appState.learningOutcomes = []; // Reset LOs
    pdfState.notesMapping = {}; // *** Ensure notes mapping is also reset ***
    if (pdfState.pdfDocument) { try { pdfState.pdfDocument.destroy(); } catch (e) { console.warn("Error destroying previous PDF doc:", e); } pdfState.pdfDocument = null; }
    pdfState.totalPages = 0; pdfState.currentPage = 1; pdfState.title = "No Document"; pdfState.isDoublePageView = true; // Reset intended view

    // Reset time lock state completely on new PDF load
    updateStatus("Resetting time lock state for new PDF.");
    isTimelockGloballyEnabled = true;
    updateTimelockButtonVisuals();
    isTimeLockActive = false;
    completedTimeLockPages.clear();
    currentPageLockStartTime = 0;
    requiredReadingTime = 0;
    currentLockType = null; // Make sure lock type is reset

    // --- Reset Notes Specific State (already handled by general resets, but good practice) ---
    pdfState.currentNotesPdfDoc = null; pdfState.currentNotesPageNum = 1; pdfState.totalNotesPages = 0;
    if (pdfState.notesPdfLoadingTask?.destroy) { pdfState.notesPdfLoadingTask.destroy(); pdfState.notesPdfLoadingTask = null; }

    // --- Reset User Progress ---
    userState.readingProgress.furthestPage = 1;
    // --- Reset UI ---
    resetPopupStates();
    document.title = "Pyr Course Viewer";

    // --- Set 'Go To Chapter' button to loading state ---
    if (ui.goToChapterBtn) {
        updateStatus("Setting button to 'Loading Chapter...' state.");
        ui.goToChapterBtn.textContent = 'Loading Chapter...';
        ui.goToChapterBtn.classList.add(CSS_CLASS.LOADING_CHAPTER);
        ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE);
    }

    let filename = "Document";
    try { filename = decodeURIComponent(pdfUrl.split('/').pop() || filename).replace(/\.pdf$/i, ''); } catch (e) { console.warn("Error parsing filename from URL"); }
    pdfState.title = filename;

    try {
        updateStatus("Starting background PDF document loading...");
        console.log("Internal Status: Loading PDF document...");
        const loadingTask = pdfjsLib.getDocument(pdfUrl);

        // Load overlay/iframe/LO/Notes data concurrently with PDF document
        const overlayPromise = loadOverlayData(pdfUrl);
        const iframeDataPromise = loadIframeData(pdfUrl);
        const loPromise = loadLearningOutcomes(pdfUrl);
        const notesDataPromise = loadNotesData(pdfUrl); // *** This promise loads external notes ***

        pdfState.pdfDocument = await loadingTask.promise;
        pdfState.totalPages = pdfState.pdfDocument.numPages;
        pdfState.currentPage = 1; // Start at page 1
        updateStatus(`PDF loaded: ${pdfState.title}, Pages: ${pdfState.totalPages}`);
        document.title = `${pdfState.title} - Pyr Course Viewer`;
        updateSliderTotalPages(); // Update slider max value (will also render milestones now)

        // Wait for overlay/iframe/LO/Notes data loading
        // *** Corrected Promise.all handling ***
        const [overlayLoaded, iframeDataLoaded, loLoaded, notesDataLoaded] = await Promise.all([
            overlayPromise,
            iframeDataPromise,
            loPromise,
            notesDataPromise // Wait for notes data too
        ]);
        updateStatus(`Overlay data loaded: ${overlayLoaded}`);
        updateStatus(`Iframe data loaded: ${iframeDataLoaded}`);
        updateStatus(`LO data loaded: ${loLoaded}`);
        updateStatus(`External Notes data loaded: ${notesDataLoaded}`); // Log status for notes

        // Re-render milestones after LO data is loaded (if total pages was already set)
        renderSliderMilestones();

        // Pre-scan for keywords if overlay data was loaded
        if (overlayLoaded && pdfState.pdfDocument) {
            console.log("Internal Status: Scanning for keywords...");
            await findFirstKeywordInstances();
        }

        // Determine initial view mode based on window size
        if (window.innerWidth < 1000) {
            updateStatus("Initial setup: Small screen detected, setting intended view to Single Page (Fullscreen).");
            pdfState.isDoublePageView = false;
            ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE);
            ui.body.classList.add(CSS_CLASS.FULLSCREEN_MODE);
        } else {
             updateStatus("Initial setup: Large screen detected, setting intended view to Double Page.");
            pdfState.isDoublePageView = true;
            ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE, CSS_CLASS.FULLSCREEN_MODE);
             pdfState.currentPage = 1; // Ensure starting on page 1 for double view
        }

        updateSliderPosition(); // Set initial slider position/text/LO colors

        // Wait for next frame before initial render to ensure layout is stable
        await new Promise(resolve => requestAnimationFrame(resolve));
        await updateDisplay(); // Perform initial render

        // --- READER IS READY ---
        appState.isReaderReady = true;
        updateStatus("Reader is ready!");
        // Notify game iframe that the chapter is ready
        if (ui.gameIframe?.contentWindow) {
            try {
                ui.gameIframe.contentWindow.postMessage({ type: 'chapterReady' }, '*');
                updateStatus("Sent 'chapterReady' message to game iframe.");
            } catch (e) {
                console.error("Error posting 'chapterReady' message to iframe:", e);
            }
        } else {
            console.warn("Cannot send 'chapterReady' message: Game iframe or contentWindow not accessible.");
        }

        // --- Show 'Go to Chapter' button with animation ---
        setTimeout(() => {
            if (ui.goToChapterBtn && ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) {
                updateStatus("Reader ready, updating button to 'Go to Chapter' state and animating.");
                ui.goToChapterBtn.textContent = 'Go to Chapter';
                ui.goToChapterBtn.classList.remove(CSS_CLASS.LOADING_CHAPTER);
                ui.goToChapterBtn.classList.add(CSS_CLASS.VISIBLE);
            }
        }, LOADING_BAR_ANIMATION_BUFFER);

        // Notify game iframe that reader is ready (to prevent auto-restart)
        if (ui.gameIframe?.contentWindow) {
                    try {
                        ui.gameIframe.contentWindow.postMessage({ type: 'disableRestart' }, '*');
                        updateStatus("Sent disableRestart message to game iframe.");
                    } catch (e) { console.error("Error posting disableRestart message to iframe:", e); }
                } else {
                    console.warn("Cannot send disableRestart message: iframe or contentWindow not accessible.");
                }

    } catch (error) {
        console.error("FATAL: Error loading PDF document:", error);
        appState.isReaderReady = false;
        // Reset all state again on critical failure
        pdfState.pdfDocument=null; pdfState.totalPages=0; pdfState.currentPage=1; pdfState.title="Error Loading"; pdfState.keywordDefinitions={}; pdfState.pageKeywords={}; pdfState.globalFirstInstanceLocation = {}; pdfState.iframeMappings = {}; appState.learningOutcomes = []; pdfState.notesMapping = {};
        completedTimeLockPages.clear(); isTimeLockActive = false; requiredReadingTime = 0; currentPageLockStartTime = 0; isTimelockGloballyEnabled = true; updateTimelockButtonVisuals(); currentLockType = null;
        pdfState.currentNotesPdfDoc = null; pdfState.currentNotesPageNum = 1; pdfState.totalNotesPages = 0;
        document.title="Pyr Course Viewer - Error";
        updateSliderTotalPages(); updateSliderPosition();
        if (ui.bookSpread) {
            ui.bookSpread.innerHTML = `<div style="color: red; background: white; padding: 30px; text-align: center; width: 100%; border: 1px solid red; border-radius: 5px;">Failed to load document: ${error.message}</div>`;
        }
        updateStatus("loadPdf failed. Reader will not be available.");
        ui.body.classList.add(CSS_CLASS.LOADING_GAME_ACTIVE);
        if (ui.goToChapterBtn) {
            ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE, CSS_CLASS.LOADING_CHAPTER);
        }
        if (ui.gameContainer) ui.gameContainer.style.display = 'none';
         if(ui.iframeLoadingText) ui.iframeLoadingText.textContent = `Error loading PDF: ${error.message}`;
         if(ui.iframeLoadingText) ui.iframeLoadingText.style.display = 'block';

    } finally {
         updateStatus("loadPdf finished (background process).");
    }
}

    // --- Popup Handling (Keep from New Code) ---
    // Replacement showDefinitionPopup function // <<<< CONFIRMED: Correct Block Start
    function showDefinitionPopup(clickedHighlightElement) {
        // Get data directly from the clicked element's dataset attributes
        const word = clickedHighlightElement?.dataset?.keyword;
        const pos = clickedHighlightElement?.dataset?.pos || ''; // Default to empty if missing
        const definition = clickedHighlightElement?.dataset?.definition;
        const rect = clickedHighlightElement?.getBoundingClientRect(); // Get rect from the element

        if (!ui.definitionPopup || !ui.popupWord || !ui.popupDefinition || !word || !definition || !rect) {
            console.error("Cannot show definition popup: Missing element, data, or rect.");
            return;
        }
        if (ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE)) {
            updateStatus("Definition popup suppressed in rotated mode."); return;
        }

        hideIframePopupIfNeeded(); hideNotesPopupIfNeeded(); // Hide other popups

        // *** Set the innerHTML for the header using spans ***
        ui.popupWord.innerHTML = `
            <span class="keyword-term">${word}</span>
            <span class="part-of-speech">${pos}</span>
        `;
        // Set the definition text
        ui.popupDefinition.innerHTML = definition; // Definition is already just the text
        ui.popupDefinition.scrollTop = 0;

        // --- Positioning Logic (from previous step, keep this) ---
        const estPopupWidth = Math.min(ui.definitionPopup.offsetWidth || 320, 320);
        const estPopupHeight = Math.min(ui.definitionPopup.offsetHeight || 200, 200);
        const margin = 10;
        const verticalOffset = 8;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let targetLeft = rect.left + (rect.width / 2) - (estPopupWidth / 2);
        targetLeft = Math.max(margin, targetLeft);
        targetLeft = Math.min(targetLeft, viewportWidth - estPopupWidth - margin);
        targetLeft = Math.max(margin, targetLeft);

        let targetTop = rect.top - estPopupHeight - verticalOffset;
        let transformOrigin = 'bottom center';

        if (targetTop < margin || rect.top < viewportHeight * 0.4) {
            targetTop = rect.bottom + verticalOffset;
            transformOrigin = 'top center';
            if (targetTop + estPopupHeight > viewportHeight - margin) {
                targetTop = viewportHeight - estPopupHeight - margin;
                targetTop = Math.max(margin, targetTop);
            }
        }

        ui.definitionPopup.style.left = `${Math.round(targetLeft)}px`;
        ui.definitionPopup.style.top = `${Math.round(targetTop)}px`;
        ui.definitionPopup.style.transformOrigin = transformOrigin;

        toggleVisibility(ui.definitionPopup, true);
    }
    // <<<< CONFIRMED: Correct Block End

    function hideDefinitionPopup() { toggleVisibility(ui.definitionPopup, false); }

    // --- Iframe Popup Handling (Keep from New Code) ---
    function showIframePopup(url) {
        if (!ui.iframePopupBackdrop || !ui.iframePopupModal || !ui.popupIframe || !ui.closeIframePopupBtn || !url) {
            console.error("Cannot show iframe popup: Missing element or URL."); return;
        }
        hideDefinitionPopup(); hideNotesPopupIfNeeded(); // Hide other popups

        // Avoid reloading if already visible with the same URL
        if (ui.iframePopupModal.classList.contains(CSS_CLASS.VISIBLE) && ui.popupIframe.src === url) {
            updateStatus("Iframe popup already visible with the same URL."); return;
        }

        updateStatus(`Showing iframe popup for URL: ${url}`);
        ui.popupIframe.src = url;
        toggleVisibility(ui.iframePopupBackdrop, true);
        toggleVisibility(ui.iframePopupModal, true);
            // --- Activate Iframe Timelock (if globally enabled) ---
    if (isTimelockGloballyEnabled) {
        requiredReadingTime = calculateVideoDuration(url); // Calculate duration
        currentPageLockStartTime = Date.now();
        isTimeLockActive = true;
        currentLockType = 'iframe';
        updateStatus(`Iframe timelock ACTIVATED. Type: ${currentLockType}, Duration: ${requiredReadingTime}s`);
    } else {
        // Ensure lock is inactive if globally disabled when popup opens
        isTimeLockActive = false;
        currentLockType = null;
        updateStatus(`Iframe timelock NOT ACTIVATED (Globally disabled).`);
    }
    // --- End Iframe Timelock Activation ---
    }

    function hideIframePopup() {
        // --- Timelock Check ---
if (isTimelockGloballyEnabled && isTimeLockActive && currentLockType === 'iframe') {
    const elapsedSeconds = (Date.now() - currentPageLockStartTime) / 1000;
    if (elapsedSeconds < requiredReadingTime) {
        updateStatus(`Iframe timelock ACTIVE: ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Preventing close.`);
        showReadingTimeAlert('<em>Please watch the video first!</em>'); // Show the video-specific alert
        return; // *** Prevent closing ***
    } else {
        updateStatus(`Iframe timelock COMPLETED (${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s). Allowing close.`);
        // Lock is finished, reset state before proceeding to close
        isTimeLockActive = false;
        currentLockType = null;
        requiredReadingTime = 0;
        currentPageLockStartTime = 0;
    }
} else if (currentLockType === 'iframe') {
     // Lock type was 'iframe' but it wasn't active, ensure state is reset.
     updateStatus("Iframe timelock was inactive or globally disabled. Resetting state.");
     isTimeLockActive = false;
     currentLockType = null;
     requiredReadingTime = 0;
     currentPageLockStartTime = 0;
}
// --- End Timelock Check ---
        if (!ui.iframePopupBackdrop || !ui.iframePopupModal || !ui.popupIframe) return;
        if (ui.iframePopupModal.classList.contains(CSS_CLASS.VISIBLE)) {
             updateStatus("Hiding iframe popup.");
             toggleVisibility(ui.iframePopupBackdrop, false);
             toggleVisibility(ui.iframePopupModal, false);
            // Final cleanup: Ensure lock state is reset if it was for iframe
if (currentLockType === 'iframe') {
     isTimeLockActive = false;
     currentLockType = null;
     requiredReadingTime = 0;
     currentPageLockStartTime = 0;
}
             ui.popupIframe.src = 'about:blank'; // Clear content to free resources
        }
    }
    function hideIframePopupIfNeeded() {
        
        if (ui.iframePopupModal?.classList.contains(CSS_CLASS.VISIBLE)) {
            hideIframePopup();
        }
    }

    // --- Notes Data Processing (Keep from New Code) ---
    function processNotesData(rawData) {
        const mapping = {};
        if (!Array.isArray(rawData)) {
            console.error("Invalid raw notes data: Expected an array."); return mapping;
        }
        rawData.forEach((entry, index) => {
            if (typeof entry === 'object' && entry !== null &&
                typeof entry.chapterPage === 'number' && Number.isInteger(entry.chapterPage) && entry.chapterPage > 0 &&
                typeof entry.path === 'string' && entry.path.trim() !== '' &&
                typeof entry.notesPage === 'number' && Number.isInteger(entry.notesPage) && entry.notesPage > 0)
            {
                const chapterPageStr = entry.chapterPage.toString();
                if (mapping[chapterPageStr]) {
                    console.warn(`Duplicate chapterPage ${entry.chapterPage} found in notes data at index ${index}. Overwriting previous entry.`);
                }
                mapping[chapterPageStr] = { pdf: entry.path, page: entry.notesPage };
            } else {
                console.warn(`Invalid notes data entry at index ${index}. Skipping:`, entry);
            }
        });
        updateStatus(`Notes mapping processed: ${Object.keys(mapping).length} valid entries found.`);
        return mapping;
    }

    // --- Notes Popup Handling (Keep from New Code) ---
    async function showNotesPopup(pdfUrl, pageNum = 1) {
    // *** Check for required elements including the new loader ***
    if (!ui.notesPopupBackdrop || !ui.notesPopupContainer || !ui.notesPdfCanvas || !ui.notesLocalLoader) {
        console.error("Cannot show notes popup: Missing elements.");
        return;
    }
    hideDefinitionPopup(); hideIframePopupIfNeeded(); // Hide other popups
    updateStatus(`Showing notes popup for PDF: ${pdfUrl}, page: ${pageNum}`);

    // *** Show popup container and backdrop (triggers CSS transitions) ***
    toggleVisibility(ui.notesPopupBackdrop, true);
    toggleVisibility(ui.notesPopupContainer, true);

    // *** Show the LOCAL loader immediately ***
    ui.notesLocalLoader.classList.add(CSS_CLASS.VISIBLE);

    const ctx = ui.notesPdfCanvas.getContext('2d');
    ctx.clearRect(0, 0, ui.notesPdfCanvas.width, ui.notesPdfCanvas.height);
    ui.notesPdfCanvas.style.opacity = 0; // *** Hide canvas until rendered ***
    ui.notesPrevBtn.disabled = true;
    ui.notesNextBtn.disabled = true;
    ui.notesInstruction?.classList.remove(CSS_CLASS.WIGGLE_NOW); // Reset wiggle

    // Cancel any previous loading task and destroy old document
    if (pdfState.notesPdfLoadingTask?.destroy) { pdfState.notesPdfLoadingTask.destroy(); }
    if (pdfState.currentNotesPdfDoc?.destroy) { try { pdfState.currentNotesPdfDoc.destroy(); } catch (e) { console.warn("Error destroying previous notes PDF", e); } }
    pdfState.currentNotesPdfDoc = null;
    pdfState.notesPdfLoadingTask = null; // Ensure it's null initially

    try {
    // *** REMOVED global showLoading() ***
    pdfState.notesPdfLoadingTask = pdfjsLib.getDocument(pdfUrl);
    pdfState.currentNotesPdfDoc = await pdfState.notesPdfLoadingTask.promise;
    pdfState.totalNotesPages = pdfState.currentNotesPdfDoc.numPages;
    pdfState.currentNotesPageNum = Math.max(1, Math.min(pageNum, pdfState.totalNotesPages)); // Clamp page num

    updateStatus(`Notes PDF loaded: ${pdfState.totalNotesPages} pages. Rendering page ${pdfState.currentNotesPageNum}.`);
    await renderNotesPage(pdfState.currentNotesPageNum); // Render the target page

    // --- Activate Notes Timelock (if globally enabled) ---
    if (isTimelockGloballyEnabled) {
        requiredReadingTime = 45; // Fixed 45 seconds for notes
        currentPageLockStartTime = Date.now();
        isTimeLockActive = true;
        currentLockType = 'notes';
        updateStatus(`Notes timelock ACTIVATED. Type: ${currentLockType}, Duration: ${requiredReadingTime}s`);
    } else {
        // Ensure lock is inactive if globally disabled when popup opens
        isTimeLockActive = false;
        currentLockType = null;
         updateStatus(`Notes timelock NOT ACTIVATED (Globally disabled).`);
    }
    // --- End Notes Timelock Activation ---


    // *** Hide LOCAL loader only AFTER successful render ***
    // (renderNotesPage now handles showing the canvas)
    ui.notesLocalLoader.classList.remove(CSS_CLASS.VISIBLE);

} catch (error) {
        console.error(`Error loading or rendering notes PDF ${pdfUrl}:`, error);
        // Display error message *on the canvas* (optional)
        ctx.fillStyle = '#8B0000'; // Dark red
        ctx.font = '16px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText('Error loading notes.', ui.notesPdfCanvas.width / 2, ui.notesPdfCanvas.height / 2);
        ui.notesPdfCanvas.style.opacity = 1; // Show error message

        // Hide the popup after a short delay on error
        setTimeout(hideNotesPopup, 1500);

    } finally {
         // *** Ensure loader is hidden in finally block as a safeguard ***
         ui.notesLocalLoader.classList.remove(CSS_CLASS.VISIBLE);
         pdfState.notesPdfLoadingTask = null; // Clear loading task reference
         // *** REMOVED global hideLoading() ***
    }
}

    function hideNotesPopup() {

    // --- Timelock Check ---
if (isTimelockGloballyEnabled && isTimeLockActive && currentLockType === 'notes') {
    const elapsedSeconds = (Date.now() - currentPageLockStartTime) / 1000;
    if (elapsedSeconds < requiredReadingTime) {
        updateStatus(`Notes timelock ACTIVE: ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Preventing close.`);
        showReadingTimeAlert(); // Show the generic alert

        // --- Trigger Wiggle on Blocked Close ---
        if (ui.notesInstruction) {
            // Ensure animation restarts if triggered again quickly
            ui.notesInstruction.classList.remove(CSS_CLASS.WIGGLE_NOW);
            void ui.notesInstruction.offsetWidth; // Force reflow

            ui.notesInstruction.classList.add(CSS_CLASS.WIGGLE_NOW);
            updateStatus("Triggering notes instruction wiggle (blocked close).");
            // Optional: remove class after animation duration if CSS doesn't handle it (usually iteration-count: 1 does)
            // setTimeout(() => {
            //    ui.notesInstruction?.classList.remove(CSS_CLASS.WIGGLE_NOW);
            // }, 500); // Match CSS animation duration if needed
        }
        // --- End Trigger Wiggle ---
        return; // *** Prevent closing ***
        return; // *** Prevent closing ***
    } else {
        updateStatus(`Notes timelock COMPLETED (${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s). Allowing close.`);
        // Lock is finished for this popup instance, reset state before proceeding to close
        isTimeLockActive = false;
        currentLockType = null;
        requiredReadingTime = 0;
        currentPageLockStartTime = 0;
    }
} else if (currentLockType === 'notes') {
     // Lock type was 'notes' but it wasn't active (e.g., globally disabled after opening), ensure state is reset.
     updateStatus("Notes timelock was inactive or globally disabled. Resetting state.");
     isTimeLockActive = false;
     currentLockType = null;
     requiredReadingTime = 0;
     currentPageLockStartTime = 0;
}
// --- End Timelock Check ---
    // Check for required elements
    if (!ui.notesPopupBackdrop || !ui.notesPopupContainer || !ui.notesPdfCanvas || !ui.notesLocalLoader) return;

    if (ui.notesPopupContainer.classList.contains(CSS_CLASS.VISIBLE)) {
        updateStatus("Hiding notes popup.");
        // Clear the fade timer & reset button visibility
        clearTimeout(notesNavFadeTimeout);
        notesNavFadeTimeout = null;
        ui.notesPrevBtn?.classList.remove('notes-nav-faded');
        ui.notesNextBtn?.classList.remove('notes-nav-faded');

        toggleVisibility(ui.notesPopupBackdrop, false);
        toggleVisibility(ui.notesPopupContainer, false);

        // Hide the local loader as well when popup closes
        ui.notesLocalLoader.classList.remove(CSS_CLASS.VISIBLE);

        // Clear canvas after a short delay to allow fade out
        setTimeout(() => {
            const ctx = ui.notesPdfCanvas.getContext('2d');
            if (ctx) { // Check if context exists
               ctx.clearRect(0, 0, ui.notesPdfCanvas.width, ui.notesPdfCanvas.height);
            }
            ui.notesPdfCanvas.style.opacity = 0; // Ensure canvas is hidden
             ui.notesInstruction?.classList.remove(CSS_CLASS.WIGGLE_NOW); // Ensure wiggle class is removed
        }, 300); // Delay slightly longer than transition (0.25s)

        // Clean up PDF resources

    // Final cleanup: Ensure lock state is reset if it was for notes
if (currentLockType === 'notes') {
     isTimeLockActive = false;
     currentLockType = null;
     requiredReadingTime = 0;
     currentPageLockStartTime = 0;
}
        if (pdfState.notesPdfLoadingTask?.destroy) { pdfState.notesPdfLoadingTask.destroy(); pdfState.notesPdfLoadingTask = null; }
        if (pdfState.currentNotesPdfDoc?.destroy) {
            try { pdfState.currentNotesPdfDoc.destroy(); updateStatus("Destroyed notes PDF document object."); }
            catch (e) { console.warn("Error destroying notes PDF doc:", e); }
        }
        pdfState.currentNotesPdfDoc = null;
        pdfState.currentNotesPageNum = 1;
        pdfState.totalNotesPages = 0;
    }
}
    function hideNotesPopupIfNeeded() {
        if (ui.notesPopupContainer?.classList.contains(CSS_CLASS.VISIBLE)) {
            hideNotesPopup();
        }
    }

    async function renderNotesPage(pageNum) {
    // Check for required elements
    if (!pdfState.currentNotesPdfDoc || pageNum < 1 || pageNum > pdfState.totalNotesPages || !ui.notesPdfCanvas || !ui.notesPdfCanvasContainer || !ui.notesLocalLoader) {
         console.warn("Cannot render notes page: Invalid state or elements.");
         ui.notesLocalLoader?.classList.remove(CSS_CLASS.VISIBLE); // Hide loader if error
         return;
    }
    updateStatus(`Rendering notes page ${pageNum} of ${pdfState.totalNotesPages}`);
    const canvas = ui.notesPdfCanvas; const ctx = canvas.getContext('2d');

    // *** Ensure canvas is hidden initially for the render ***
    canvas.style.opacity = 0;
    ui.notesInstruction?.classList.remove(CSS_CLASS.WIGGLE_NOW); // Remove previous wiggle
    ui.notesLocalLoader?.classList.add(CSS_CLASS.VISIBLE); // Show loader for render

    try {
        const page = await pdfState.currentNotesPdfDoc.getPage(pageNum);
        const containerStyle = getComputedStyle(ui.notesPdfCanvasContainer);
        const availableWidth = parseFloat(containerStyle.width);
        const availableHeight = parseFloat(containerStyle.height);
        if (isNaN(availableWidth) || isNaN(availableHeight) || availableWidth <= 0 || availableHeight <= 0) {
            console.warn("Notes canvas container has invalid dimensions."); throw new Error("Invalid container dimensions");
        }
        const defaultViewport = page.getViewport({ scale: 1 });
        const scale = Math.min(availableWidth / defaultViewport.width, availableHeight / defaultViewport.height);
        const viewport = page.getViewport({ scale: scale });
        const outputScale = window.devicePixelRatio || 1;

        canvas.width = Math.floor(viewport.width * outputScale);
        canvas.height = Math.floor(viewport.height * outputScale);
        canvas.style.width = `${Math.floor(viewport.width)}px`;
        canvas.style.height = `${Math.floor(viewport.height)}px`;

        const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
        const renderContext = { canvasContext: ctx, transform: transform, viewport: viewport };

        await page.render(renderContext).promise;
        pdfState.currentNotesPageNum = pageNum; // Update state *after* successful render

        // *** Fade in the canvas AFTER rendering is complete ***
        canvas.style.opacity = 1; // Make canvas visible

        // Update navigation button states
        ui.notesPrevBtn.disabled = (pdfState.currentNotesPageNum <= 1);
        ui.notesNextBtn.disabled = (pdfState.currentNotesPageNum >= pdfState.totalNotesPages);
        updateStatus(`Notes page ${pageNum} rendered successfully.`);

        // Make buttons visible and start fade timer
        showNotesNavAndResetTimer();

        // Trigger instruction wiggle (keep this)
        if (ui.notesInstruction) {
            updateStatus("Triggering notes instruction wiggle.");
            // Use a slight delay to ensure canvas is visible first
            setTimeout(() => {
               ui.notesInstruction.classList.add(CSS_CLASS.WIGGLE_NOW);
            }, 50);
        }

    } catch (error) {
        console.error(`Error rendering notes page ${pageNum}:`, error);
        ctx.fillStyle = '#8B0000'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(`Error rendering page ${pageNum}.`, canvas.width / 2, canvas.height / 2);
        canvas.style.opacity = 1; // Show error
        ui.notesPrevBtn.disabled = true; ui.notesNextBtn.disabled = true;
        throw error; // Re-throw error so showNotesPopup catch block handles it
    } finally {
        ui.notesLocalLoader?.classList.remove(CSS_CLASS.VISIBLE); // Hide loader after render attempt
    }
}

    function notesPrevPage() { if (pdfState.currentNotesPageNum > 1) { renderNotesPage(pdfState.currentNotesPageNum - 1); } }
    function notesNextPage() { if (pdfState.currentNotesPageNum < pdfState.totalNotesPages) { renderNotesPage(pdfState.currentNotesPageNum + 1); } }


    // --- Game Transition Logic (MODIFIED - Button logic changed) ---
    function transitionToChapter() {
        updateStatus("Transitioning to chapter...");
        clearTimeout(appState.gameOverTimeoutId); // Cancel any pending auto-transition

        // 1. Explicitly remove visibility classes from the button to start its fade-out transition.
        if (ui.goToChapterBtn) {
            ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE);
            ui.goToChapterBtn.classList.remove(CSS_CLASS.LOADING_CHAPTER);
            // The button's own opacity transition (0.3s) will handle the fade out.
            updateStatus("Removed button visibility classes to initiate fade-out.");
        }

        // 2. Remove the body class to hide the game container and reveal the reader UI.
        //    This happens concurrently with the button fading out.
        ui.body.classList.remove(CSS_CLASS.LOADING_GAME_ACTIVE);
        window.focus(); // Try to bring focus back to the main window

        // *** ADDED: Re-enable iframe input (though it's hidden now) ***
    if (ui.gameIframe) {
        ui.gameIframe.classList.remove('iframe-inactive');
        updateStatus("Re-enabled game iframe input class (though hidden).");
    }
    // *** END ADDED ***

// --- START: Temporarily Show Toolbars ---
if (ui.rightToolbar && ui.leftToolbar) {
    updateStatus("Temporarily showing toolbars for 7 seconds.");
    ui.rightToolbar.classList.add('visible');
    ui.leftToolbar.classList.add('visible');

    // Clear any previous toolbar hide timers from hover logic (just in case)
    clearTimeout(toolbarTimer);
    clearTimeout(leftToolbarTimer);

    setTimeout(() => {
        // Only hide if the user ISN'T currently hovering over them
        // We check the global hover state variables used by manageToolbar/manageLeftToolbar
        if (!toolbarHover && ui.rightToolbar?.classList.contains('visible')) {
            ui.rightToolbar.classList.remove('visible');
            updateStatus("Hiding right toolbar after 7s timeout (not hovered).");
        } else if(ui.rightToolbar?.classList.contains('visible')) {
             updateStatus("Keeping right toolbar visible after 7s (hovered).");
        }

        if (!leftToolbarHover && ui.leftToolbar?.classList.contains('visible')) {
            ui.leftToolbar.classList.remove('visible');
            updateStatus("Hiding left toolbar after 7s timeout (not hovered).");
        } else if(ui.leftToolbar?.classList.contains('visible')) {
             updateStatus("Keeping left toolbar visible after 7s (hovered).");
        }
    }, 7000); // 7000 milliseconds = 7 seconds
}
// --- END: Temporarily Show Toolbars ---
        
        // 3. Apply reader scaling/resize shortly after the body class is removed.
        //    The reader's main container also has a fade-in transition.
        setTimeout(() => {
            applyCurrentViewModeStyles(); // Recalculate scale for the reader view
            window.dispatchEvent(new Event('resize')); // Trigger resize event for any listeners
            updateStatus("Reader should be visible and scaled.");
        }, 50); // Delay allows transitions to start smoothly.
    }

    function handleGameOverFromGame(score) {
        updateStatus(`Game over message received. Score: ${score}`);

        // Always show the 'Go to Chapter' button on game over, if not already visible in loading state
        if (ui.goToChapterBtn && !ui.goToChapterBtn.classList.contains(CSS_CLASS.LOADING_CHAPTER)) {
            // If reader is already ready, show the animated button
            if (appState.isReaderReady) {
                ui.goToChapterBtn.textContent = 'Go to Chapter';
                ui.goToChapterBtn.classList.remove(CSS_CLASS.LOADING_CHAPTER); // Ensure this is removed
                ui.goToChapterBtn.classList.add(CSS_CLASS.VISIBLE); // Trigger animation
                updateStatus("Made 'Go to Chapter' button visible (Game Over - Reader Ready).");
            } else {
                // If reader isn't ready yet, show the static "Loading..." button
                ui.goToChapterBtn.textContent = 'Loading Chapter...';
                ui.goToChapterBtn.classList.add(CSS_CLASS.LOADING_CHAPTER);
                 updateStatus("Made 'Loading Chapter...' button visible (Game Over - Reader Not Ready).");
            }

            // *** ADDED: Disable iframe input ***
        if (ui.gameIframe) {
            ui.gameIframe.classList.add('iframe-inactive');
            // Try to remove focus to prevent keyboard input
            ui.gameIframe.blur();
             // More robust: tell the iframe's content to blur itself
            if (ui.gameIframe.contentWindow) {
                try {
                    ui.gameIframe.contentWindow.postMessage({ type: 'blurYourself' }, '*');
                     updateStatus("Sent 'blurYourself' message to game iframe.");
                } catch(e){ console.warn("Could not post 'blurYourself' message:", e)}
            }
            updateStatus("Disabled game iframe input (Game Over).");
        }
        // *** END ADDED ***
            
        } else if (ui.goToChapterBtn) {
             updateStatus("'Go to Chapter' button already visible in loading state.");
        } else {
             console.error("'Go to Chapter' button not found!");
        }

        if (ui.gameIframe) {
            ui.gameIframe.classList.add('iframe-inactive');
            // Try to remove focus to prevent keyboard input
            ui.gameIframe.blur();
            // More robust: tell the iframe's content to blur itself
            if (ui.gameIframe.contentWindow) {
                try {
                    ui.gameIframe.contentWindow.postMessage({ type: 'blurYourself' }, '*');
                    updateStatus("Sent 'blurYourself' message to game iframe.");
                } catch(e){ console.warn("Could not post 'blurYourself' message:", e)}
            }
            updateStatus("Disabled game iframe input (Game Over).");
        }

        
        // If reader is already loaded, start timer for automatic transition
        if (appState.isReaderReady) { // Use appState from new code
            updateStatus(`Reader is ready, starting automatic transition timer (${GAME_OVER_TRANSITION_DELAY}ms) after game over.`);
            // Try to disable game restart as a safeguard
            if (ui.gameIframe?.contentWindow) {
                try { ui.gameIframe.contentWindow.postMessage({ type: 'disableRestart' }, '*'); }
                 catch (e) { console.error("Error posting safeguard disableRestart message:", e); }
            }
            clearTimeout(appState.gameOverTimeoutId); // Clear any existing timer
            appState.gameOverTimeoutId = setTimeout(() => {
                updateStatus("Game over timeout finished, transitioning now.");
                transitionToChapter(); // Transition hides the button via body class
            }, GAME_OVER_TRANSITION_DELAY);
        } else {
            updateStatus("Game over occurred, but reader is not ready yet. Button made visible for manual transition.");
        }
    }

    // --- Timelock UI and Toggle (REVERTED from Old Code) ---
    function updateTimelockButtonVisuals() { // REVERTED
        if (!ui.timelockToggleButton) return;
        if (isTimelockGloballyEnabled) { // Uses reverted global
            ui.timelockToggleButton.classList.remove(CSS_CLASS.TIMELOCK_OFF);
            ui.timelockToggleButton.classList.add(CSS_CLASS.TIMELOCK_ON);
            ui.timelockToggleButton.title = "Toggle Reading Time Lock (On)";
        } else {
            ui.timelockToggleButton.classList.remove(CSS_CLASS.TIMELOCK_ON);
            ui.timelockToggleButton.classList.add(CSS_CLASS.TIMELOCK_OFF);
            ui.timelockToggleButton.title = "Toggle Reading Time Lock (Off)";
        }
    }

    function toggleTimelock() { // REVERTED
        isTimelockGloballyEnabled = !isTimelockGloballyEnabled; // Uses reverted global
        updateStatus(`Timelock globally ${isTimelockGloballyEnabled ? 'ENABLED' : 'DISABLED'}`);
        updateTimelockButtonVisuals();

        // If turning the timelock OFF, immediately deactivate any *current* lock.
        if (!isTimelockGloballyEnabled && isTimeLockActive) { // Uses reverted globals
        updateStatus("Timelock globally disabled, clearing current active lock.");
        isTimeLockActive = false;
        requiredReadingTime = 0;
        currentPageLockStartTime = 0;
        currentLockType = null; // Reset type when disabling lock globally
        clearTimeout(appState.alertTimeout); // Hide any active alert (use appState timer var from new code)
        toggleVisibility(ui.readingTimeAlert, false); // Hide alert visually
    } else if (isTimelockGloballyEnabled) {
            // If turning the timelock ON, re-evaluate the lock state for the current view immediately.
            updateStatus("Timelock globally enabled, re-evaluating lock state for current view.");
            updateDisplay(); // Re-run updateDisplay to potentially set a lock (calls reverted lock logic)
        }
        manageLeftToolbar(false); // Hide toolbar after action (uses reverted function)
    }

// Helper function to start the fade timer
// Helper function to start the fade timer IF screen is narrow
function startNotesNavFadeTimer() {
    const FADE_BREAKPOINT = 768; // Width in pixels
    const FADE_DELAY = 3500; // 3.5 seconds

    clearTimeout(notesNavFadeTimeout); // Clear any existing timer

    // Only start the timer if the window is below the breakpoint
    if (window.innerWidth <= FADE_BREAKPOINT) {
        notesNavFadeTimeout = setTimeout(() => {
            // Check popup is still visible before fading
            if (ui.notesPopupContainer?.classList.contains(CSS_CLASS.VISIBLE)) {
                // Add the faded class to both buttons
                ui.notesPrevBtn?.classList.add('notes-nav-faded');
                ui.notesNextBtn?.classList.add('notes-nav-faded');
                 updateStatus("Fading notes nav buttons due to timeout on narrow screen.");
            }
        }, FADE_DELAY);
    } else {
        // If window is wider, ensure buttons are not faded (CSS handles default visibility)
        // We don't need to explicitly remove the class here,
        // showNotesNavAndResetTimer does that initially.
        // CSS media query ensures the .notes-nav-faded class has no effect above breakpoint.
         updateStatus("Notes nav buttons timer not started (wide screen).");
    }
}

// Helper function to show buttons and reset timer
function showNotesNavAndResetTimer() {
    clearTimeout(notesNavFadeTimeout); // Clear existing timer first
    // Remove faded class immediately to make buttons visible
    ui.notesPrevBtn?.classList.remove('notes-nav-faded');
    ui.notesNextBtn?.classList.remove('notes-nav-faded');
    // Now, start the timer (which checks screen width internally)
    startNotesNavFadeTimer();
}

    // --- Event Setup (REVERTED Timelock Toggle Listener, keeps other new listeners, MODIFIED Game/LO Listeners) ---
    function setupEvents() {
        updateStatus("Setting up events");

        // --- Toolbar Clicks ---
        ui.rightToolbar?.addEventListener('click', (e) => {
             const btn = e.target.closest('.new-btn');
             if (!btn) return;
             switch (btn.id) {
                 case 'back-btn': window.history.back(); break;
                 case 'single-page-btn': setSinglePageView(); break;
                 case 'double-page-btn': setDoublePageView(); break;
                 // Note: Rotate button is no longer here
                 case 'time-capsule-btn': console.log("Time Capsule button clicked (feature disabled)."); break;
             }
             // Hiding managed by view change functions + reverted manageToolbar
        });
        // *** REVERTED Left Toolbar Click (Timelock Toggle) ***
        ui.leftToolbar?.addEventListener('click', e => {
            const btn = e.target.closest('.new-btn');
            if (!btn || btn.id !== 'timelock-toggle-btn') return;
            toggleTimelock(); // Calls reverted function
        });
        ui.returnViewFixedBtn?.addEventListener('click', setRotatedView);

        // --- Popup Close Buttons & Backdrops ---
        ui.closeIframePopupBtn?.addEventListener('click', hideIframePopup);
        ui.iframePopupBackdrop?.addEventListener('click', hideIframePopup);
        ui.notesPopupBackdrop?.addEventListener('click', hideNotesPopup);
        ui.loContinueBtn?.addEventListener('click', hideLoAchievementPopup); // NEW
        ui.loAchievementBackdrop?.addEventListener('click', hideLoAchievementPopup); // NEW: Click backdrop to close

        // --- Notes Navigation ---
        ui.notesPrevBtn?.addEventListener('click', notesPrevPage);
        ui.notesNextBtn?.addEventListener('click', notesNextPage);

        // --- START: ADDED LISTENERS for Notes Nav Fade ---
        // Show buttons on hover/tap and reset timer
        ui.notesPrevBtn?.addEventListener('mouseenter', showNotesNavAndResetTimer);
        ui.notesNextBtn?.addEventListener('mouseenter', showNotesNavAndResetTimer);
        ui.notesPdfCanvasContainer?.addEventListener('mouseenter', showNotesNavAndResetTimer);
        ui.notesPdfCanvasContainer?.addEventListener('touchstart', showNotesNavAndResetTimer, { passive: true });
        // --- END: ADDED LISTENERS ---

        // --- START: Prevent Toolbar Trigger when hovering Page Rotate Trigger ---
        const rotateTriggers = document.querySelectorAll('.page-rotate-hover-trigger');
        rotateTriggers.forEach(trigger => {
            trigger.addEventListener('mouseenter', (e) => {
                // Stop this hover event from reaching the toolbar trigger area underneath
                e.stopPropagation();
                // console.log('Stopped propagation from page rotate trigger'); // Optional debug
            });
        });
updateStatus("Added event stoppers for rotate triggers.");
// --- END: Prevent Toolbar Trigger ---

        // --- Page Interaction (Edges & Rotate Button) ---
        ui.bookSpread?.addEventListener('click', (e) => {
            if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;

            const pageEdgeNav = e.target.closest('.page-edge-nav');
            const rotateBtn = e.target.closest('.page-rotate-btn'); // Keep listener for new button location
            const rotateTrigger = e.target.closest('.page-rotate-hover-trigger'); // Check if click was on trigger

            // Ignore clicks on the trigger itself from causing navigation
            if (rotateTrigger) return;

            if (pageEdgeNav) {
                const pageDiv = pageEdgeNav.closest('.book-page');
                // Check if edge nav is visible and page is not placeholder
                if (!pageDiv || pageDiv.classList.contains(CSS_CLASS.PLACEHOLDER_PAGE) || pageEdgeNav.style.display === 'none') return;

                if (pageEdgeNav.classList.contains('page-edge-left')) { prevPage(); } // Calls reverted lock logic & NEW LO check
                else { nextPage(); } // Calls reverted lock logic & NEW LO check
            }
            else if (rotateBtn) { // Keep rotate button logic from new code
    const btnStyle = window.getComputedStyle(rotateBtn);
    // Button should only be clickable if visible (opacity 1, pointer-events auto)
    if (btnStyle.opacity === '1' && btnStyle.pointerEvents !== 'none') {
        const pageDiv = rotateBtn.closest('.book-page');
        if (pageDiv && !pageDiv.classList.contains(CSS_CLASS.PLACEHOLDER_PAGE)) {
            // *** START CHANGE ***
            let targetPageNum;
            if (pageDiv.classList.contains('left')) {
                targetPageNum = pdfState.currentPage;
            } else if (pageDiv.classList.contains('right')) {
                targetPageNum = pdfState.currentPage + 1;
            } else {
                console.warn("Could not determine page number for rotation.");
                return; // Don't rotate if we can't figure out the page
            }

            // Ensure the target page number is valid
            if (targetPageNum >= 1 && targetPageNum <= pdfState.totalPages) {
                updateStatus(`Page rotate button clicked for page ${targetPageNum}.`);
                setRotatedView(targetPageNum); // Pass the target page number
            } else {
                 updateStatus(`Ignoring rotate click for invalid target page ${targetPageNum}.`);
            }
            // *** END CHANGE ***
        }
    }
}
        });

        // --- Keyboard Navigation ---
        document.addEventListener('keydown', (e) => {
            if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;

            // Escape key for popups (Keep logic from new code, added LO popup)
            if (e.key === 'Escape') {
                if (ui.loAchievementPopup?.classList.contains(CSS_CLASS.VISIBLE)) { hideLoAchievementPopup(); e.preventDefault(); return; } // NEW
                if (ui.notesPopupContainer?.classList.contains(CSS_CLASS.VISIBLE)) { hideNotesPopup(); e.preventDefault(); return; }
                if (ui.iframePopupModal?.classList.contains(CSS_CLASS.VISIBLE)) { hideIframePopup(); e.preventDefault(); return; }
                if (ui.definitionPopup?.classList.contains(CSS_CLASS.VISIBLE)) { hideDefinitionPopup(); e.preventDefault(); return; }
            }

            // Ignore keyboard events if a popup/overlay is active, or if inside input fields
             const isPopupActive = ui.notesPopupContainer?.classList.contains(CSS_CLASS.VISIBLE) ||
                                  ui.iframePopupModal?.classList.contains(CSS_CLASS.VISIBLE) ||
                                  ui.definitionPopup?.classList.contains(CSS_CLASS.VISIBLE) ||
                                  ui.loAchievementPopup?.classList.contains(CSS_CLASS.VISIBLE); // NEW
            const isInputFocused = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';

            if (isPopupActive || isInputFocused || e.ctrlKey || e.altKey || e.metaKey) return;

            let navAction = false;
            switch(e.key){
                case 'ArrowRight': case 'PageDown': nextPage(); navAction = true; break; // Uses reverted lock logic & NEW LO check
                case 'ArrowLeft': case 'PageUp': prevPage(); navAction = true; break; // Uses reverted lock logic & NEW LO check
                case 'Home': if(pdfState.totalPages > 0) jumpToPage(1); navAction = true; break; // Uses reverted lock logic
                case 'End': if(pdfState.totalPages > 0) jumpToPage(pdfState.totalPages); navAction = true; break; // Uses reverted lock logic
            }
            if(navAction){ e.preventDefault(); } // Prevent default scroll behavior
        });

        // --- Resize Handling ---
        window.addEventListener('resize', () => {
            clearTimeout(appState.resizeTimer);
            appState.resizeTimer = setTimeout(() => {
                updateStatus("Resize detected.");
                resetPopupStates(); // Hide popups on resize
                applyCurrentViewModeStyles(); // Recalculate scale
                renderSliderMilestones(); // Re-render milestones on resize
                // Re-render if reader is active and PDF loaded
                if (!ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE) && pdfState.pdfDocument) {
                    updateDisplay(); // Calls reverted lock logic
                }
                 manageToolbar(); // Use reverted function
                 manageLeftToolbar(); // Use reverted function
                 showNotesNavAndResetTimer(); // Add this line - Resets notes button visibility/timer on resize
             }, 250); // Debounce resize event
        });

        // --- Touch Swipes (Keep from New Code, modified for LO check) ---
        let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
        const swipeThresholdX = 40; // Min horizontal distance
        const swipeMaxTime = 500; // Max duration for swipe
        const swipeMaxVertical = 70; // Max vertical distance allowed

        ui.body.addEventListener('touchstart', (e) => {
            if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;
            // Ignore swipes starting on interactive elements
            const ignoredElements = '#new-toolbar,.toolbar-trigger-area,#left-toolbar,.left-toolbar-trigger-area,#page-slider-container,#page-slider-trigger-zone,.toc-panel,.page-edge-nav,.new-btn,button,input,a,#definition-popup,.keyword-highlight,.annotationLayer section,#iframe-popup-modal,#iframe-popup-backdrop,#notes-popup-container,#notes-popup-backdrop, .page-action-btn, #return-view-fixed-btn, .page-rotate-hover-trigger, .lo-milestone, #lo-achievement-popup, #lo-achievement-backdrop'; // Added rotate trigger, LO elements
            if (e.target.closest(ignoredElements)) {
                touchStartX = 0; touchStartY = 0; touchStartTime = 0; return;
            }
            // Track single touch start
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].screenX;
                touchStartY = e.touches[0].screenY;
                touchStartTime = Date.now();
            } else { // Reset if multiple touches
                touchStartX = 0; touchStartY = 0; touchStartTime = 0;
            }
        }, { passive: true }); // Use passive listener for performance

        ui.body.addEventListener('touchend', (e) => {
             if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE) || touchStartTime === 0) return;
             // Ignore swipes ending within notes canvas or LO popup
             if (e.target.closest('#notes-pdf-canvas-container') || e.target.closest('#lo-achievement-popup')) {
                 touchStartX = 0; touchStartY = 0; touchStartTime = 0; return;
             }
             // Ignore swipes ending on the rotate trigger or milestone
             if (e.target.closest('.page-rotate-hover-trigger') || e.target.closest('.lo-milestone')) {
                 touchStartX = 0; touchStartY = 0; touchStartTime = 0; return;
             }

             if (e.changedTouches.length === 1) {
                 const touchEndX = e.changedTouches[0].screenX;
                 const touchEndY = e.changedTouches[0].screenY;
                 const elapsedTime = Date.now() - touchStartTime;

                 if (elapsedTime < swipeMaxTime) { // Check duration
                     const deltaX = touchEndX - touchStartX;
                     const deltaY = touchEndY - touchStartY;
                     const absDeltaX = Math.abs(deltaX);
                     const absDeltaY = Math.abs(deltaY);

                     // Check thresholds for horizontal swipe
                     if (absDeltaX > swipeThresholdX && absDeltaY < swipeMaxVertical) {
                         e.stopPropagation(); // Prevent other handlers if it's a swipe
                         if (deltaX > 0) { // Swipe Right (-> Previous)
                             updateStatus("Body Swipe Right Detected -> Previous Page");
                             prevPage(); // Uses reverted lock logic
                         } else { // Swipe Left (-> Next)
                             updateStatus("Body Swipe Left Detected -> Next Page");
                             nextPage(); // Uses reverted lock logic & NEW LO check
                         }
                     }
                 }
             }
             // Reset tracking state
             touchStartX = 0; touchStartY = 0; touchStartTime = 0;
        });

        // --- Touch Swipes (Notes Popup) ---
        let notesTouchStartX = 0, notesTouchStartY = 0, notesTouchStartTime = 0;
        const notesSwipeThresholdX = 50;

        ui.notesPdfCanvasContainer?.addEventListener('touchstart', (e) => {
            if (!ui.notesPopupContainer?.classList.contains(CSS_CLASS.VISIBLE)) return;
            // Ignore swipes starting on nav buttons within the container
            if (e.target.closest('.notes-nav-btn')) {
                notesTouchStartX = 0; notesTouchStartY = 0; notesTouchStartTime = 0; return;
            }
            if (e.touches.length === 1) {
                notesTouchStartX = e.touches[0].screenX;
                notesTouchStartY = e.touches[0].screenY;
                notesTouchStartTime = Date.now();
            } else {
                notesTouchStartX = 0; notesTouchStartY = 0; notesTouchStartTime = 0;
            }
        }, { passive: true });

        ui.notesPdfCanvasContainer?.addEventListener('touchend', (e) => {
            if (!ui.notesPopupContainer?.classList.contains(CSS_CLASS.VISIBLE) || notesTouchStartTime === 0) return;
            if (e.changedTouches.length === 1) {
                const notesTouchEndX = e.changedTouches[0].screenX;
                const notesTouchEndY = e.changedTouches[0].screenY;
                const notesElapsedTime = Date.now() - notesTouchStartTime;

                if (notesElapsedTime < swipeMaxTime) {
                    const notesDeltaX = notesTouchEndX - notesTouchStartX;
                    const notesDeltaY = notesTouchEndY - notesTouchStartY;
                    const notesAbsDeltaX = Math.abs(notesDeltaX);
                    const notesAbsDeltaY = Math.abs(notesDeltaY);

                    if (notesAbsDeltaX > notesSwipeThresholdX && notesAbsDeltaY < swipeMaxVertical) {
                        e.stopPropagation(); // Prevent body swipe handler
                        if (notesDeltaX > 0) { // Swipe Right -> Previous Notes Page
                            updateStatus("Notes Swipe Right Detected -> Previous Notes Page");
                            notesPrevPage();
                        } else { // Swipe Left -> Next Notes Page
                            updateStatus("Notes Swipe Left Detected -> Next Notes Page");
                            notesNextPage();
                        }
                    }
                }
            }
            // Reset tracking state
            notesTouchStartX = 0; notesTouchStartY = 0; notesTouchStartTime = 0;
        });


        // --- Game Event Listeners (MODIFIED Button Logic) ---
        ui.goToChapterBtn?.addEventListener('click', transitionToChapter);

        window.addEventListener('message', (event) => {
            // Basic security check: ensure message is from the iframe source
            if (event.source !== ui.gameIframe?.contentWindow) { return; }

            if (event.data && event.data.type === 'gameOver') {
                handleGameOverFromGame(event.data.score);
            }
            // PASTE THIS ENTIRE BLOCK:
// PASTE THIS ENTIRE BLOCK:
else if (event.data && event.data.type === 'gameLoaded') {
     if(ui.iframeLoadingText) ui.iframeLoadingText.style.display = 'none'; // Hide "Loading game..." text
     updateStatus("Game iframe reported 'gameLoaded'.");

     // *** Tell the game iframe to focus itself ***
     updateStatus("Sending 'focusGame' message back to iframe.");
     try {
         if (ui.gameIframe?.contentWindow) {
             // IMPORTANT: Use '*' for origin during development, change for production
             ui.gameIframe.contentWindow.postMessage({ type: 'focusGame' }, '*');
             updateStatus("Successfully sent 'focusGame' message.");
         } else {
              console.warn("Cannot send 'focusGame' message: Game iframe or contentWindow not accessible.");
         }
     } catch (postMessageError) {
         console.warn("Error sending 'focusGame' message:", postMessageError);
     }
} // END OF BLOCK TO PASTE
        });

        // Listener for the iframe's initial document load (less reliable than postMessage)
        ui.gameIframe?.addEventListener('load', () => {
            // Hide loading text earlier, but still wait for 'gameLoaded' message for full readiness
            if(ui.iframeLoadingText) ui.iframeLoadingText.style.display = 'none';
            updateStatus("Game iframe document structure loaded (waiting for gameLoaded message).");
        });

        // --- Global Click Listener for Popup Dismissal (Keep from New Code) ---
        document.addEventListener('click', (e) => {
             if (ui.definitionPopup?.classList.contains(CSS_CLASS.VISIBLE) &&
                 !ui.definitionPopup.contains(e.target) && // Clicked outside popup
                 !e.target.closest('.keyword-highlight')) // And not on a keyword highlight
             { hideDefinitionPopup(); }
        }, true); // Use capture phase to catch clicks early

// --- START: Prevent Game Replay via iframe focus ---
ui.gameIframe?.addEventListener('focus', () => {
    // Only trigger if the reader has loaded AND the game screen is still technically active
    if (appState.isReaderReady && ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) {
        updateStatus("Game iframe focused after reader ready. Forcing transition to chapter.");
        // Call the same function the button calls
        transitionToChapter();
    }
}, true); // Use capture phase: true
// --- END: Prevent Game Replay via iframe focus ---
        
        updateStatus("Events setup complete");
    }

    // --- Initialization (Uses reverted timelock reset, reverted setupToolbarHover/setupLeftToolbarHover, LO loading) ---
    async function init() {
        updateStatus("Initializing application...");
        // Body starts with 'loading-game-active' class

        try {
            // Determine page padding from CSS variable
            try {
                 appState.pagePadding = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-padding')) || 15;
             } catch(e){
                 appState.pagePadding = 15;
                 console.warn("CSS var --page-padding read failed, using default.");
             }


            // Setup core event listeners and UI handlers
            setupEvents(); // Calls reverted timelock listener, LO popup listener
            setupToolbarHover(); // REVERTED Hover logic
            setupLeftToolbarHover(); // REVERTED Hover logic
            updateTimelockButtonVisuals(); // Set initial timelock icon state (uses reverted globals)
            initPageSlider(); // Setup slider interaction (uses reverted jump/lock logic, LO milestone rendering/interaction)

            // Get PDF URL from query parameter
            const urlParams = new URLSearchParams(window.location.search);
            const pdfUrlParam = urlParams.get('pdf');

            if (pdfUrlParam) {
                updateStatus(`PDF URL parameter found: ${pdfUrlParam}. Starting background load...`);
                loadPdf(pdfUrlParam); // Start loading the PDF asynchronously (calls reverted lock reset, loads LOs)
            } else {
                // No PDF specified - show message and exit loading state
                updateStatus("No PDF specified in URL parameter (?pdf=...). Reader content will not load.");
                appState.isReaderReady = false;
                if (ui.goToChapterBtn) { // Ensure button is hidden
                     ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE, CSS_CLASS.LOADING_CHAPTER);
                }
                ui.body.classList.remove(CSS_CLASS.LOADING_GAME_ACTIVE); // Exit loading state

                // Display message in main container
                if(ui.mainContainer) {
                    ui.mainContainer.style.visibility = 'visible';
                    ui.mainContainer.style.opacity = '1';
                    ui.mainContainer.innerHTML = `<div style="color: var(--text-on-dark); background: rgba(28,37,54,.8); border-radius: 8px; padding: 40px; text-align: center; max-width: 500px; margin: auto; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"><h2>Interactive Reader</h2><p style="margin-top: 15px;">Add <code>?pdf=URL_TO_PDF</code> to the address bar.</p></div>`;
                }
                // Hide loading game elements if no PDF is provided
                if (ui.gameContainer) ui.gameContainer.style.display = 'none';
            }

            // Cleanup on unload
            window.addEventListener('beforeunload', () => {
                updateStatus("Unloading - Performing Cleanup.");
                // Clear all timeouts
                clearTimeout(appState.gameOverTimeoutId);
                clearTimeout(appState.alertTimeout);
                clearTimeout(appState.alertWiggleTimeout);
                clearTimeout(toolbarTimer); // Use reverted timer variable
                clearTimeout(leftToolbarTimer); // Use reverted timer variable
                clearTimeout(appState.resizeTimer);
                clearTimeout(appState.sliderHideTimeout);
                // Clear cache and destroy PDF documents
                pdfState.pageCache.clear();
                if (pdfState.pdfDocument?.destroy) { try { pdfState.pdfDocument.destroy(); } catch(e){} }
                if (pdfState.currentNotesPdfDoc?.destroy) { try { pdfState.currentNotesPdfDoc.destroy(); } catch(e){} }
                pdfState.pdfDocument = null;
                pdfState.currentNotesPdfDoc = null;
                // Hide any remaining popups (though they should be closed by normal flow)
                hideNotesPopup();
                hideIframePopup();
                hideDefinitionPopup();
                hideLoAchievementPopup(); // Added
            });

            updateStatus("Initialization sequence complete. Background PDF loading may be in progress.");

        } catch (initError) {
            console.error("CRITICAL Initialization failed:", initError);
            // Display error prominently if init fails catastrophically
            document.body.innerHTML = `<div style="color: red; background: white; padding: 20px; border: 2px solid red; font-family: monospace; position: fixed; top: 10px; left: 10px; z-index: 11000; max-width: calc(100% - 20px); overflow: auto;"><pre>Application Initialization Error:\n${initError.stack || initError}</pre></div>`;
            // Ensure loading state is visually consistent with error
            ui.body.classList.add(CSS_CLASS.LOADING_GAME_ACTIVE);
            if (ui.goToChapterBtn) { // Ensure button is hidden on failure
                ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE, CSS_CLASS.LOADING_CHAPTER);
            }
        }
    }

// --- Start the application ---
document.addEventListener('DOMContentLoaded', init);

})(); // End of IIFE
</script>
</body>
</html>
