<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;1,400&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pyr Course Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf_viewer.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf_viewer.css">
    <style>
         :root {
            --accent: #f5a623;
            --fiery-orange: #f97316;
            --lab-blue: #080e1c;
            --page: #fff;
            --text-on-dark: rgba(255, 255, 255, .9);
            --page-w: 650px;
            --page-h: 842px;
            --gradient-flame: linear-gradient(90deg, var(--fiery-orange), var(--accent), var(--fiery-orange));
            --page-padding: 7px;
            --font-heading: 'Roboto', sans-serif;
            --font-body: 'Open Sans', sans-serif;
            --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            --gradient-time-capsule: linear-gradient(45deg, #f5a623, #f97316, #c553eb, #38bdf8);
            --radius-full: 50%;
            --parchment: #f5e8c7;
            --parchment-overlay: rgba(245, 232, 199, 0.85);
            --lo-greyed-out-filter: grayscale(100%);
            --lo-tooltip-bg: rgba(8, 14, 28, 0.95);
        }

        @keyframes pulseAnimation {
            0%,
            100% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateX(-50%) scale(1.03);
                opacity: 0.85;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: var(--font-body);
            background-color: var(--lab-blue);
            color: var(--text-on-dark);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: fixed;
            line-height: 1.6;
            -webkit-tap-highlight-color: transparent;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background-image: radial-gradient(circle at 15% 15%, rgba(249, 115, 22, .12) 0, transparent 45%), radial-gradient(circle at 85% 85%, rgba(197, 83, 235, .12) 0, transparent 45%), radial-gradient(circle at 85% 15%, rgba(56, 189, 248, .05) 0, transparent 40%), radial-gradient(circle at 15% 85%, rgba(251, 191, 36, .08) 0, transparent 40%);
            animation: ambient-shift 30s ease infinite alternate
        }

        @keyframes ambient-shift {
            0% {
                background-position: 0 0, 0 0, 0 0, 0 0
            }
            100% {
                background-position: 5% 10%, -5% -5%, 10% -5%, -10% 5%
            }
        }

        @media (prefers-reduced-motion:reduce) {
            body::before {
                animation: none !important
            }
        }

        #new-toolbar {
            position: fixed !important;
            top: 15px !important;
            right: -60px !important;
            bottom: auto !important;
            left: auto !important;
            z-index: 9999 !important;
            display: flex !important;
            flex-direction: column !important;
            gap: 10px !important;
            transition: right .3s ease !important;
            background: rgba(28, 37, 54, .9) !important;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 2.5px 5px !important;
            border-radius: 8px 0 0 8px !important;
            box-shadow: -2px 2px 10px rgba(0, 0, 0, .4) !important;
            width: 58px;
            height: auto !important;
            border: 1px solid rgba(255, 255, 255, .1);
            border-right: none !important;
        }

        .toolbar-trigger-area {
            position: fixed;
            top: 0;
            right: 0;
            width: 30px;
            height: 100%;
            z-index: 9998;
            transition: none !important;
        }

        #new-toolbar.visible {
            right: 0 !important;
            transform: none !important;
        }

        .new-btn {
            background: rgba(44, 62, 80, .8) !important;
            border: 1px solid rgba(255, 255, 255, .15) !important;
            color: var(--text-on-dark) !important;
            width: 48px !important;
            height: 48px !important;
            border-radius: 4px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 25px !important;
            cursor: pointer !important;
            transition: all .2s !important;
            box-shadow: 0 2px 5px rgba(0, 0, 0, .2) !important;
            user-select: none !important;
            flex-shrink: 0;
            transform: rotate(0deg) !important;
            padding: 0;
            position: relative;
            overflow: visible;
        }

        .new-btn>*,
        .new-btn .icon {
            margin: 0;
            line-height: 1;
            flex-shrink: 0;
        }

        .new-btn .icon {
            width: 24px;
            height: 24px;
            stroke-width: 1.5;
        }

        .new-btn:hover {
            background: rgba(52, 73, 94, .9) !important;
            border-color: rgba(255, 255, 255, .25) !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, .3) !important;
            transform: translateY(-2px) !important;
        }

        .new-btn:active {
            transform: translateY(1px) !important;
        }

        .new-btn[disabled] {
            opacity: .5;
            cursor: not-allowed;
            pointer-events: none
        }

        #back-btn {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            font-size: 20px !important;
            color: var(--text-on-dark) !important;
            width: 36px !important;
            height: 36px !important;
            padding: 0 !important;
            margin-top: -2.5px !important;
            margin-bottom: -5px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            transition: color 0.2s, transform 0.2s !important;
        }

        #back-btn:hover {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            color: var(--accent) !important;
            transform: translateX(-3px) !important;
        }

        #back-btn:active {
            transform: translateX(0px) !important;
            color: var(--secondary) !important;
        }

        #time-capsule-btn {
            position: relative;
            overflow: hidden;
            z-index: 1;
            border-radius: 50% !important;
            padding: 0 !important;
        }

        #time-capsule-btn::before {
            content: "";
            position: absolute;
            z-index: -1;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: var(--gradient-time-capsule);
            background-size: 300% 300%;
            border-radius: 50%;
            filter: blur(3px);
            opacity: 0.35;
            transition: opacity 0.4s ease-out, filter 0.4s ease-out;
            animation: hazyGradientAnimation 6s linear infinite;
            pointer-events: none;
        }

        #time-capsule-btn:hover {
            background: rgba(52, 73, 94, .9) !important;
            border-color: rgba(255, 255, 255, .25) !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, .3) !important;
            transform: translateY(-2px) !important;
            color: var(--text-on-dark) !important;
        }

        #time-capsule-btn:hover::before {
            opacity: 0.8;
            filter: blur(5px);
        }

        #time-capsule-btn .icon {
            position: relative;
            z-index: 2;
            margin: 0;
            color: var(--text-on-dark) !important;
        }

        #time-capsule-btn:hover .icon {
            color: var(--text-on-dark) !important;
        }

        @keyframes hazyGradientAnimation {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        .page-slider-container {
            position: fixed;
            bottom: -80px;
            left: 50% !important;
            transform: translateX(-50%) !important;
            top: auto !important;
            right: auto !important;
            width: 90%;
            max-width: 700px;
            height: auto !important;
            padding: 18px 20px 14px 20px;
            background: rgba(28, 37, 54, .9);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, .1);
            border-bottom: none;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, .4);
            display: flex;
            flex-direction: column !important;
            align-items: center;
            z-index: 9998;
            transition: bottom .35s cubic-bezier(.2, .9, .3, 1) !important;
            border-radius: 16px 16px 0 0;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: bottom .35s cubic-bezier(.2, .9, .3, 1), opacity .35s ease-out, visibility 0s linear .35s !important;
        }

        .page-slider-container.visible {
            bottom: 0 !important;
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition-delay: 0s, 0s, 0s !important;
        }

        #page-slider-trigger-zone {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px;
            z-index: 9997;
            pointer-events: auto;
            cursor: pointer;
        }

        .page-slider-track {
            width: 100%;
            margin-bottom: 8px;
            padding: 0 10px;
            position: relative;
            height: 20px;
            display: flex;
            align-items: center;
        }

        .page-slider {
            width: 100% !important;
            height: 6px !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            background: rgba(255, 255, 255, .1) !important;
            outline: none;
            border-radius: 3px !important;
            overflow: visible;
            cursor: pointer;
            transition: height .2s;
            writing-mode: horizontal-tb !important;
            position: relative;
            z-index: 1;
        }

        .page-slider:hover {
            height: 8px
        }

        .page-slider::-webkit-slider-thumb {
            -webkit-appearance: none !important;
            appearance: none !important;
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            background: var(--accent) !important;
            cursor: pointer;
            border: 3px solid rgba(28, 37, 54, .9) !important;
            box-shadow: 0 1px 6px rgba(0, 0, 0, .4) !important;
            transition: all .2s ease;
            margin-top: -7px !important;
            margin-left: 0 !important;
            position: relative;
            z-index: 4;
        }

        .page-slider:hover::-webkit-slider-thumb {
            width: 24px !important;
            height: 24px !important;
            margin-top: -8px !important
        }

        .page-slider::-webkit-slider-runnable-track {
            width: 100% !important;
            height: 100% !important;
            background-image: linear-gradient(to right, var(--fiery-orange), var(--accent)), linear-gradient(to right, rgba(255, 255, 255, .1), rgba(255, 255, 255, .1));
            background-size: var(--slider-percent, 0%) 100%, 100% 100%;
            background-repeat: no-repeat;
            border-radius: 3px !important;
            background-color: transparent !important;
        }

        .page-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: 3px solid rgba(28, 37, 54, .9);
            box-shadow: 0 1px 6px rgba(0, 0, 0, .4);
            position: relative;
            z-index: 4;
        }

        .page-slider:hover::-moz-range-thumb {
            width: 24px;
            height: 24px;
        }

        .page-slider::-moz-range-progress {
            background: linear-gradient(to right, var(--fiery-orange), var(--accent)) !important;
            height: 100%;
            border-radius: 3px;
        }

        .page-slider::-moz-range-track {
            background-color: rgba(255, 255, 255, .1) !important;
            height: 100%;
            border-radius: 3px;
        }

        .page-slider-info {
            font-size: 12px;
            font-family: var(--font-heading);
            color: var(--text-on-dark);
            font-weight: 500;
            letter-spacing: .3px;
            opacity: .8;
            transform: rotate(0deg) !important;
            white-space: normal !important;
            margin-bottom: 0 !important;
            padding-top: 0 !important;
            transition: opacity 0.25s ease-in-out;
        }

        .lo-milestone {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 27px;
            cursor: pointer;
            user-select: none;
            z-index: 3;
            opacity: var(--lo-greyed-out-opacity);
            filter: var(--lo-greyed-out-filter);
            transition: opacity 0.3s ease, filter 0.3s ease;
            will-change: opacity, filter;
        }

        .lo-milestone.lo-passed {
            opacity: 1;
            filter: none;
        }

        .lo-milestone.hover-colored {
            opacity: 1;
            filter: none;
        }

        #lo-tooltip {
            position: absolute;
            background-color: var(--lo-tooltip-bg);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0s linear 0.2s;
            pointer-events: none;
            transform: translateY(-100%);
        }

        #lo-tooltip.visible {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        #lo-achievement-backdrop {
            position: fixed;
            inset: 0;
            background-color: rgba(8, 14, 28, 0.7);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 10020;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
            cursor: pointer;
        }

        #lo-achievement-backdrop.visible {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        #lo-achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 90%;
            max-width: 500px;
            background-color: #FFFFFF;
            color: #333333;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 25px 30px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            z-index: 10021;
            opacity: 0;
            visibility: hidden;
            text-align: center;
            font-family: var(--font-body);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out, visibility 0s linear 0.3s;
        }

        #lo-achievement-popup.visible {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
            transition-delay: 0s;
        }

        #lo-achievement-popup h3 {
            font-family: var(--font-heading);
            font-size: 1.45rem;
            margin-bottom: 15px;
            color: #222;
            font-weight: 700;
        }

        #lo-achievement-popup p#lo-achievement-text {
            margin-bottom: 15px;
            padding: 0;
            line-height: normal;
        }

        #lo-achievement-text .lo-popup-emoji {
            display: block;
            font-size: 5rem;
            line-height: 1;
            margin-bottom: 10px;
        }

        #lo-achievement-text .lo-popup-text {
            display: block;
            font-size: 1.0rem;
            line-height: 1.5;
            background: var(--gradient-flame);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: shimmerText 2.5s infinite linear;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #lo-achievement-text .lo-popup-text strong {
            font-weight: bold;
            color: #080e1c;
            text-decoration: underline;
            text-decoration-color: #ffaa75;
            text-decoration-thickness: 1.6px;
            line-height: 1.1;
        }

        #lo-achievement-popup em#lo-achievement-tip {
            font-family: var(--font-body);
            display: block;
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 20px;
            font-style: italic;
        }

        #lo-continue-btn {
            font-family: var(--font-heading);
            padding: 10px 25px;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, var(--accent), var(--fiery-orange));
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #lo-continue-btn:hover {
            background: linear-gradient(135deg, var(--fiery-orange), var(--accent));
            transform: scale(1.05);
        }

        #lo-continue-btn:active {
            transform: scale(0.98);
        }

        #left-toolbar {
            position: fixed !important;
            top: 15px !important;
            left: -60px !important;
            bottom: auto !important;
            right: auto !important;
            z-index: 9999 !important;
            display: flex !important;
            flex-direction: column !important;
            gap: 10px !important;
            transition: left .3s ease !important;
            background: rgba(28, 37, 54, .9) !important;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 2.5px 5px !important;
            border-radius: 0 8px 8px 0 !important;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, .4) !important;
            width: 58px;
            height: auto !important;
            border: 1px solid rgba(255, 255, 255, .1);
            border-left: none !important;
        }

        .left-toolbar-trigger-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 30px;
            height: 100%;
            z-index: 9998;
            transition: none !important;
        }

        #left-toolbar.visible {
            left: 0 !important;
            transform: none !important;
        }

        #timelock-toggle-btn {}

        #timelock-toggle-btn.timelock-on .icon-clock-on {
            display: block;
            stroke: var(--secondary);
        }

        #timelock-toggle-btn.timelock-on .icon-clock-off {
            display: none;
        }

        #timelock-toggle-btn.timelock-off .icon-clock-on {
            display: none;
        }

        #timelock-toggle-btn.timelock-off .icon-clock-off {
            display: block;
            stroke: var(--accent);
        }

        .main-container {
            flex: 1;
            display: flex;
            justify-content: center !important;
            align-items: center !important;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            background: transparent;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s linear 0.3s, opacity 0.3s ease-in-out;
        }

        body:not(.loading-game-active) .main-container {
            visibility: visible;
            opacity: 1;
            transition-delay: 0s;
        }

        .book-spread {
            display: flex;
            box-shadow: 0 10px 35px rgba(0, 0, 0, .5);
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform-origin: center center;
            width: auto !important;
            height: auto !important;
            transition: transform .3s ease;
            transform: translate(-50%, -50%)
        }

        .book-page {
            width: var(--page-w);
            height: var(--page-h);
            background-color: var(--page);
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, .08);
            padding: 0;
        }

        .book-page.left {
            border-right: 1px solid rgba(255, 255, 255, .15);
            border-radius: 3px 0 0 3px
        }

        .book-page.right {
            border-left: 1px solid rgba(255, 255, 255, .15);
            border-radius: 0 3px 3px 0
        }

        .canvas-container {
            position: relative;
            width: calc(100% - 2 * var(--page-padding));
            height: calc(100% - 2 * var(--page-padding));
            margin: var(--page-padding);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .pdf-canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            object-fit: contain;
            box-shadow: none;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .page-number {
            display: none
        }

        .page-loading-overlay {
            position: absolute;
            inset: var(--page-padding);
            background: rgba(255, 255, 255, .6);
            z-index: 50;
            display: none;
            justify-content: center;
            align-items: center;
            border-radius: 3px
        }

        .page-loading-spinner {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 3px solid rgba(0, 0, 0, .1);
            border-top-color: var(--primary);
            animation: spin 1s linear infinite
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        .page-edge-nav {
            position: absolute;
            top: 0;
            height: 100%;
            width: 50px;
            cursor: pointer;
            z-index: 10;
            transition: background-color .2s;
            -webkit-tap-highlight-color: transparent
        }

        .page-edge-nav:hover {
            background-color: rgba(0, 0, 0, .03)
        }

        .page-edge-left {
            left: 0;
            border-radius: 3px 0 0 3px
        }

        .page-edge-right {
            right: 0;
            border-radius: 0 3px 3px 0
        }

        .page-edge-left:hover::after,
        .page-edge-right:hover::after {
            content: "";
            position: absolute;
            top: 50%;
            width: 12px;
            height: 12px;
            border-style: solid;
            border-color: rgba(0, 0, 0, .6);
            border-width: 2px 2px 0 0;
            opacity: .8
        }

        .page-edge-left:hover::after {
            left: 18px;
            transform: translateY(-50%) rotate(-135deg)
        }

        .page-edge-right:hover::after {
            right: 18px;
            transform: translateY(-50%) rotate(45deg)
        }

        .fullscreen-mode .book-page.right {
            display: none !important;
        }

        .fullscreen-mode .book-page.left {
            border-right: 1px solid rgba(255, 255, 255, .08) !important;
            border-radius: 3px !important;
        }

        .fullscreen-mode .canvas-container {
            margin: var(--page-padding);
        }

        .fullscreen-mode .pdf-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            position: absolute;
            z-index: 1;
        }

        .content-rotated-mode .book-page.left {
            width: var(--page-w) !important;
            height: var(--page-h) !important;
            border-radius: 3px !important;
            border: 1px solid rgba(255, 255, 255, .08) !important;
            padding: 0 !important;
            background-color: var(--page);
            display: flex !important;
            justify-content: center;
            align-items: center;
        }

        .content-rotated-mode .canvas-container {
            margin: 10px !important;
            width: calc(100% - 20px);
            height: calc(100% - 20px);
        }

        .content-rotated-mode .book-page.right {
            display: none !important;
        }

        .content-rotated-mode .pdf-canvas {
            box-shadow: none;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            position: relative;
            z-index: 1;
        }

        body:not(.fullscreen-mode):not(.content-rotated-mode) .book-page {
            width: var(--page-w);
            height: var(--page-h)
        }

        .book-page.right.placeholder-page {
            background-color: var(--page) !important;
            border-left: 1px solid rgba(0, 0, 0, .1);
            position: relative;
            display: flex !important;
            justify-content: center;
            align-items: center
        }

        .book-page.right.placeholder-page::after {
            content: "End of document";
            font-size: 14px;
            font-style: italic;
            color: rgba(0, 0, 0, .5)
        }

        .book-page.right.placeholder-page .canvas-container,
        .book-page.right.placeholder-page .page-edge-nav,
        .book-page.right.placeholder-page .page-loading-overlay,
        .book-page.right.placeholder-page .page-action-btn {
            display: none
        }

        body:not(.fullscreen-mode):not(.content-rotated-mode) .book-page.right.placeholder-page {
            border-left: 1px solid rgba(0, 0, 0, .1) !important;
        }

        body:not(.fullscreen-mode):not(.content-rotated-mode) .book-spread::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            width: 30px;
            transform: translateX(-50%);
            background: linear-gradient(to right, rgba(0, 0, 0, 0.0) 0%, rgba(0, 0, 0, 0.12) 35%, rgba(0, 0, 0, 0.18) 50%, rgba(0, 0, 0, 0.12) 65%, rgba(0, 0, 0, 0.0) 100%);
            pointer-events: none;
            z-index: 6;
            opacity: 1;
        }

        .page-action-btn {
            position: absolute;
            z-index: 20;
            background-color: rgba(44, 62, 80, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 20px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease, opacity 0.2s ease, pointer-events 0.2s ease;
            opacity: 0;
            pointer-events: none;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        .page-action-btn:hover {
            background-color: rgba(52, 73, 94, 0.9);
            transform: scale(1.1);
        }

        .page-rotate-btn {
            width: 25px;
            height: 25px;
            font-size: 14px;
            top: 5px;
            right: 5px;
        }

        .page-rotate-hover-trigger {
            position: absolute;
            top: 0;
            right: 0;
            width: 25%;
            height: 20%;
            z-index: 19;
            pointer-events: auto;
        }

        .page-rotate-hover-trigger:hover+.page-rotate-btn {
            opacity: 1;
            pointer-events: auto;
        }

        body.loading-game-active .page-rotate-btn,
        body.loading-game-active .page-rotate-hover-trigger {
            display: none !important;
        }

        body.content-rotated-mode .page-rotate-btn,
        body.content-rotated-mode .page-rotate-hover-trigger {
            display: none !important;
        }

        body.loading-game-active #game-iframe.iframe-inactive {
            pointer-events: none;
        }

        .book-page.placeholder-page .page-rotate-hover-trigger {
            display: none;
        }

        #return-view-fixed-btn {
            position: fixed !important;
            top: 15px !important;
            right: 15px !important;
            z-index: 10000 !important;
        }

        body:not(.content-rotated-mode) #return-view-fixed-btn {
            display: none !important;
        }

        body.content-rotated-mode #return-view-fixed-btn {
            display: flex !important;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(8, 14, 28, .85);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 10001;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column
        }

        .loading-overlay.visible {
            display: flex !important;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, .2);
            border-top-color: var(--accent);
            animation: spin 1s linear infinite;
            margin-bottom: 15px
        }

        .loading-message {
            font-size: 16px;
            color: var(--text-on-dark)
        }

        #status-indicator {
            display: none
        }

        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1.0;
            color: transparent !important;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: none !important;
            z-index: 2;
        }

        .textLayer>div {
            position: absolute;
            white-space: pre;
            cursor: default;
            transform-origin: 0% 0%;
            pointer-events: none !important;
            border-radius: 2px;
        }

        .annotationLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
            z-index: 3;
        }

        .annotationLayer section {
            position: absolute;
            pointer-events: auto;
        }

        .annotationLayer .linkAnnotation>a {
            position: absolute;
            font-size: 1em;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 1px solid transparent;
            transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out;
            pointer-events: auto !important;
            cursor: pointer;
        }

        .annotationLayer .linkAnnotation>a:hover {
            cursor: pointer;
            background-color: rgba(255, 255, 0, 0.2);
            border: 1px solid rgba(255, 255, 0, 0.5);
            box-shadow: 0px 0px 2px rgba(255, 255, 0, 0.5);
        }

        .keyword-overlay-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
            overflow: hidden;
        }

        .keyword-highlight {
            position: absolute;
            background: transparent;
            transition: background 0.2s ease-out, box-shadow 0.2s ease-out;
            pointer-events: auto;
            cursor: pointer;
            z-index: 5;
            box-sizing: border-box;
            border-radius: 3px;
        }

        .keyword-highlight:hover {
            background: linear-gradient(to right, rgba(249, 115, 22, 0.25), rgba(251, 191, 36, 0.25));
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        }

        .keyword-highlight.first-keyword-instance::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -2px;
            width: 100%;
            height: 1.5px;
            background: linear-gradient(to right, var(--fiery-orange), var(--accent));
            pointer-events: none;
            min-height: 1px;
            border-radius: 1px;
            opacity: 0.54;
            transition: opacity 0.2s ease-out;
        }

        body.content-rotated-mode .keyword-highlight {
            pointer-events: none !important;
            cursor: default;
        }

        body.content-rotated-mode .keyword-highlight.first-keyword-instance::after {
            display: none;
            opacity: 0;
        }

        #definition-popup {
            position: fixed;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15), 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 14px 18px;
            max-width: 320px;
            min-width: 180px;
            color: #2d3748;
            z-index: 10002;
            transform-origin: top center;
            transform: translateY(6px) scale(0.98);
            opacity: 0;
            visibility: hidden;
            transition: transform 0.18s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.18s cubic-bezier(0.4, 0, 0.2, 1), visibility 0s linear 0.18s;
            pointer-events: none;
            will-change: transform, opacity;
        }

        #definition-popup.visible {
            transform: translateY(0) scale(1);
            opacity: 1;
            visibility: visible;
            transition-delay: 0s, 0s, 0s;
            pointer-events: auto;
        }

        #popup-word {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin: 0 0 10px 0;
            border-bottom: 1px solid #e2e8f0;
            padding: 0 0 8px 0;
            font-family: var(--font-heading);
            font-size: 15px;
            font-weight: 600;
        }

        #popup-word .keyword-term {
            color: #1c1e66;
            flex-grow: 1;
            padding-right: 10px;
        }

        #popup-word .part-of-speech {
            color: #f97315;
            font-family: var(--font-heading);
            font-size: 0.85em;
            font-weight: 400;
            white-space: nowrap;
            flex-shrink: 0;
            margin-left: 10px;
        }

        #popup-definition {
            font-family: var(--font-body);
            font-size: 14px;
            line-height: 1.6;
            max-height: 180px;
            overflow-y: auto;
            color: #4a5568;
            padding-right: 5px;
            margin-right: -5px;
        }

        #popup-definition::-webkit-scrollbar {
            width: 5px;
        }

        #popup-definition::-webkit-scrollbar-track {
            background: #edf2f7;
            border-radius: 3px;
        }

        #popup-definition::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }

        #popup-definition::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }

        #loading-game-container {
            position: fixed;
            inset: 0;
            z-index: 10000;
            background-color: var(--lab-blue);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
            opacity: 1;
            visibility: visible;
            padding-bottom: 80px;
        }

        body.loading-game-active #loading-game-container {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        body:not(.loading-game-active) #loading-game-container {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #game-iframe {
            width: 90%;
            max-width: 900px;
            height: 70vh;
            max-height: 400px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            background-color: var(--lab-blue);
            margin-bottom: 15px;
        }

        #iframe-loading-text {
            color: var(--text-on-dark);
            margin-top: 15px;
        }

        @keyframes popUpBounce {
            0% {
                transform: translateX(-50%) scale(0.8);
                opacity: 0;
            }
            60% {
                transform: translateX(-50%) scale(1.1);
                opacity: 1;
            }
            80% {
                transform: translateX(-50%) scale(0.95);
            }
            100% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }
        }

        #go-to-chapter-btn {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            z-index: 10001;
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, var(--fiery-orange), var(--accent));
            border: none;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(255, 255, 255, 0.2) inset;
            opacity: 0;
            visibility: hidden;
            animation: none;
            transition: background-color 0.3s ease, background-image 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease, opacity 0.3s ease, visibility 0s linear 0.3s;
        }

        #go-to-chapter-btn.loading-chapter {
            background-color: var(--lab-blue);
            background-image: none;
            color: var(--text-on-dark);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) scale(1);
            transition-delay: 0s;
            animation: pulseAnimation 1.8s infinite ease-in-out;
        }

        #go-to-chapter-btn:not(.loading-chapter) {
            animation: none;
        }

        #go-to-chapter-btn.visible:not(.loading-chapter) {
            animation: popUpBounce 0.5s ease-out forwards;
        }

        #go-to-chapter-btn.visible {
            opacity: 1;
            visibility: visible;
            animation: popUpBounce 0.5s ease-out forwards;
            transition-delay: 0s;
        }

        #go-to-chapter-btn.visible:hover {
            background: linear-gradient(135deg, var(--accent), var(--fiery-orange));
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 1px 4px rgba(255, 255, 255, 0.25) inset;
            transform: translateX(-50%) scale(1.05);
        }

        #go-to-chapter-btn.visible:active {
            transform: translateX(-50%) scale(0.98);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.15) inset;
        }

        #go-to-chapter-btn.loading-chapter:hover {
            background-color: #0b1221;
            transform: translateX(-50%) scale(1.03);
        }

        #go-to-chapter-btn.loading-chapter:active {
            background-color: #060a14;
            transform: translateX(-50%) scale(0.98);
        }

        body.loading-game-active #new-toolbar,
        body.loading-game-active .toolbar-trigger-area,
        body.loading-game-active #left-toolbar,
        body.loading-game-active .left-toolbar-trigger-area,
        body.loading-game-active #page-slider-container,
        body.loading-game-active #page-slider-trigger-zone,
        body.loading-game-active #definition-popup,
        body.loading-game-active #iframe-popup-backdrop,
        body.loading-game-active #iframe-popup-modal,
        body.loading-game-active #notes-popup-backdrop,
        body.loading-game-active #notes-popup-container,
        body.loading-game-active .page-action-btn,
        body.loading-game-active .page-rotate-hover-trigger,
        body.loading-game-active #return-view-fixed-btn,
        body.loading-game-active #lo-tooltip,
        body.loading-game-active #lo-achievement-backdrop,
        body.loading-game-active #lo-achievement-popup {
            display: none !important;
            visibility: hidden;
            opacity: 0;
        }

        @keyframes wiggle {
            0%,
            100% {
                transform: translateX(-50%) rotate(0deg);
            }
            25% {
                transform: translateX(-50%) rotate(-3deg);
            }
            50% {
                transform: translateX(-50%) rotate(3deg);
            }
            75% {
                transform: translateX(-50%) rotate(-1deg);
            }
        }

        #reading-time-alert {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(0);
            background: rgba(44, 62, 80, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            z-index: 10005;
            font-family: var(--font-sans);
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
            pointer-events: none;
            white-space: nowrap;
            animation: none;
        }

        #reading-time-alert.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s, 0s;
            animation: wiggle 0.5s ease-in-out 1;
        }

        #reading-time-alert em {
            font-style: italic;
            font-weight: normal;
        }

        #iframe-popup-backdrop {
            position: fixed;
            inset: 0;
            background-color: rgba(8, 14, 28, 0.7);
            backdrop-filter: blur(3.15px);
            -webkit-backdrop-filter: blur(3.15px);
            z-index: 10003;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.25s ease-out, visibility 0s linear 0.25s, backdrop-filter 0.25s ease-out;
            cursor: pointer;
            overflow: hidden;
        }

        #iframe-popup-backdrop.visible {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        #iframe-popup-backdrop::before {
            content: "";
            position: absolute;
            inset: 0;
            background: var(--gradient-time-capsule);
            background-size: 300% 300%;
            opacity: 0;
            animation: hazyGradientAnimation 30s linear infinite;
            pointer-events: none;
            z-index: -1;
            transition: opacity 0.4s ease-out 0.1s;
        }

        #iframe-popup-backdrop.visible::before {
            opacity: 0.35;
        }

        #iframe-popup-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 80%;
            height: 80%;
            max-width: 1000px;
            max-height: 700px;
            background-color: var(--page);
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 10004;
            opacity: 0;
            visibility: hidden;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1) 0.1s, opacity 0.45s ease-out 0.1s, visibility 0s linear 0.45s;
        }

        #iframe-popup-modal.visible {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s, 0s, 0s;
            transform: translate(-50%, -50%) scale(1);
        }

        #popup-iframe {
            flex-grow: 1;
            border: none;
            width: 100%;
            height: 100%;
        }

        #close-iframe-popup-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            line-height: 1;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.2s;
            z-index: 10005;
        }

        #close-iframe-popup-btn:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: scale(1.1);
        }

        #notes-popup-backdrop {
            position: fixed;
            inset: 0;
            background-color: var(--parchment-overlay);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            z-index: 10010;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
            cursor: pointer;
        }

        #notes-popup-backdrop.visible {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        @keyframes notes-wiggle {
            0%,
            100% {
                transform: rotate(0deg);
            }
            25% {
                transform: rotate(-3deg);
            }
            50% {
                transform: rotate(3deg);
            }
            75% {
                transform: rotate(-1deg);
            }
        }

        @keyframes subtleWiggle {
            0%,
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }
            25% {
                transform: translate(calc(-50% - 2px), -50%) scale(1.01) rotate(-0.5deg);
            }
            50% {
                transform: translate(calc(-50% + 2px), -50%) scale(1.01) rotate(0.5deg);
            }
            75% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }
        }

        #notes-popup-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 90vw;
            height: 90vh;
            max-width: 700px;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10011;
            opacity: 0;
            visibility: hidden;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out, visibility 0s linear 0.3s;
            pointer-events: none;
            animation: none;
        }

        #notes-popup-container.visible {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
            animation: subtleWiggle 0.4s ease-in-out 1 forwards;
        }

        #notes-pdf-canvas-container {
            width: 100%;
            height: calc(100% - 60px);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            margin-bottom: 10px;
            pointer-events: auto;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            background-color: transparent;
        }

        .notes-local-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10013;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-on-dark);
            font-family: var(--font-sans);
            font-size: 14px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-out, visibility 0s linear 0.2s;
            pointer-events: none;
            background: rgba(8, 14, 28, 0.8);
            padding: 20px;
            border-radius: 8px;
        }

        .notes-local-loader.visible {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        .notes-local-spinner {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: var(--accent);
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        .notes-local-loader span {
            font-weight: 500;
        }

        #notes-pdf-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
            background-color: var(--page);
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }

        .notes-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: rgba(44, 62, 80, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s, opacity 0.3s ease-out, visibility 0s linear 0s;
            opacity: 1;
            visibility: visible;
            z-index: 10014;
            pointer-events: auto;
            user-select: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            padding: 0;
            will-change: opacity, transform;
        }

        #notes-prev-btn {
            left: 10px;
        }

        #notes-next-btn {
            right: 10px;
        }

        .notes-nav-btn:hover {
            background-color: rgba(52, 73, 94, 0.9);
            transform: translateY(-50%) scale(1.1);
            opacity: 1 !important;
            visibility: visible !important;
        }

        .notes-nav-btn:active {
            transform: translateY(-50%) scale(1);
        }

        .notes-nav-btn[disabled] {
            display: none;
        }

        @media (max-width: 768px) {
            .notes-nav-btn.notes-nav-faded {
                opacity: 0;
                visibility: hidden;
                pointer-events: none;
                transition: background-color 0.2s, transform 0.2s, opacity 0.3s ease-out, visibility 0s linear 0.3s;
            }
            .notes-nav-btn:not(.notes-nav-faded) {
                transition: background-color 0.2s, transform 0.2s, opacity 0.3s ease-out, visibility 0s linear 0s;
            }
        }

        #notes-prev-btn {
            left: 5px;
        }

        #notes-next-btn {
            right: 5px;
        }

        #notes-instruction {
            background-color: rgba(44, 62, 80, 0.9);
            color: var(--text-on-dark);
            padding: 8px 18px;
            border-radius: 20px;
            font-family: var(--font-sans);
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            z-index: 10012;
            pointer-events: auto;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.15);
            margin-top: auto;
            width: auto;
            max-width: 90%;
            transform-origin: center center;
            transform: scale(1);
            animation: none;
        }

        #notes-instruction.wiggle-now {
            animation: notes-wiggle 0.5s ease-in-out 1;
        }

        .right-handle-floated #new-toolbar.visible,
        .left-handle-floated #left-toolbar.visible {}

        body.right-handle-floated .toolbar-trigger-area {
            pointer-events: none;
        }

        body.left-handle-floated .left-toolbar-trigger-area {
            pointer-events: none;
        }

        #new-toolbar::before,
        #left-toolbar::before {
            transition: all 0.3s ease-in-out;
        }

        #toolbar-trigger-area,
        #left-toolbar-trigger-area {
            position: fixed;
            width: 30px;
            height: 100%;
            top: 0;
            z-index: 9998;
            pointer-events: auto;
            background: transparent;
            border: none;
        }

        #toolbar-trigger-area {
            right: 0;
        }

        #left-toolbar-trigger-area {
            left: 0;
        }

        #toolbar-trigger-area::after,
        #left-toolbar-trigger-area::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 90px;
            background: radial-gradient( ellipse at center, rgba(245, 166, 35, 0.6) 0%, rgba(249, 115, 22, 0.4) 40%, rgba(249, 115, 22, 0) 70%);
            border-radius: 50%;
            filter: blur(15px);
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
            pointer-events: none;
            z-index: -1;
        }

        #toolbar-trigger-area:hover::after,
        #left-toolbar-trigger-area:hover::after {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        @keyframes shimmerText {
            0% {
                background-position: 150% 50%;
            }
            100% {
                background-position: -50% 50%;
            }
        }
    </style>
</head>

<body class="loading-game-active">

    <div id="loading-game-container">
        <iframe id="game-iframe" src="/chapter2-loading-game.html" title="Loading Game"></iframe>
        <p id="iframe-loading-text">Loading game...</p>
    </div>
    <button id="go-to-chapter-btn">Go to Chapter</button>

    <div id="left-toolbar"></div>
    <div class="left-toolbar-trigger-area" id="left-toolbar-trigger-area"></div>

    <div id="new-toolbar"></div>
    <div class="toolbar-trigger-area" id="toolbar-trigger-area"></div>

    <button id="return-view-fixed-btn" class="new-btn" title="Return to Previous View"></button>

    <div id="status-indicator">Status: Initializing...</div>

    <div class="main-container">
        <div class="book-spread">
            <div class="book-page left">
                <div class="page-rotate-hover-trigger"></div>
                <button class="page-action-btn page-rotate-btn" title="Rotate Content"></button>
                <div class="canvas-container">
                    <canvas id="left-page-canvas" class="pdf-canvas"></canvas>
                    <div class="textLayer" id="left-text-layer"></div>
                    <div class="annotationLayer" id="left-annotation-layer"></div>
                    <div class="keyword-overlay-container" id="left-keyword-overlay"></div>
                </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="left-page-number"></div>
                <div class="page-loading-overlay">
                    <div class="page-loading-spinner"></div>
                </div>
            </div>
            <div class="book-page right placeholder-page">
                <div class="page-rotate-hover-trigger"></div>
                <button class="page-action-btn page-rotate-btn" title="Rotate Content"></button>
                <div class="canvas-container">
                    <canvas id="right-page-canvas" class="pdf-canvas"></canvas>
                    <div class="textLayer" id="right-text-layer"></div>
                    <div class="annotationLayer" id="right-annotation-layer"></div>
                    <div class="keyword-overlay-container" id="right-keyword-overlay"></div>
                </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="right-page-number"></div>
                <div class="page-loading-overlay">
                    <div class="page-loading-spinner"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loading-overlay"></div>

    <div class="page-slider-container" id="page-slider-container">
        <div class="page-slider-track">
            <div id="lo-milestones-container"></div>
            <input type="range" id="page-slider" class="page-slider" min="1" max="1" value="1" style="--slider-percent: 0%">
        </div>
        <div class="page-slider-info">
            <span id="current-page-display">Page 1</span> of <span id="total-pages-display">1</span>
        </div>
        <div id="lo-tooltip"></div>
    </div>
    <div id="page-slider-trigger-zone"></div>

    <div id="definition-popup">
        <div id="popup-word">Keyword</div>
        <div id="popup-definition">Loading definition...</div>
    </div>

    <div id="reading-time-alert"></div>

    <div id="iframe-popup-backdrop"></div>
    <div id="iframe-popup-modal">
        <button id="close-iframe-popup-btn" title="Close (Esc)"></button>
        <iframe id="popup-iframe" src="about:blank" title="Embedded Content"></iframe>
    </div>

    <div id="notes-popup-backdrop"></div>
    <div id="notes-popup-container">
        <div id="notes-pdf-canvas-container">
            <div class="notes-local-loader" style="display: none;">
                <div class="notes-local-spinner"></div>
                <span>Loading Notes...</span>
            </div>
            <canvas id="notes-pdf-canvas"></canvas>
            <button id="notes-prev-btn" class="notes-nav-btn" title="Previous Notes Page"></button>
            <button id="notes-next-btn" class="notes-nav-btn" title="Next Notes Page"></button>
        </div>
        <div id="notes-instruction"><em>Copy these notes into your Pyr Notebook before continuing</em></div>
    </div>

    <div id="lo-achievement-backdrop"></div>
    <div id="lo-achievement-popup">
        <h3 id="lo-achievement-header">Congratulations  You've learned:</h3>
        <p id="lo-achievement-text"><strong>Placeholder Learning Outcome</strong></p>
        <em id="lo-achievement-tip">Teach it to a friend or family member to strengthen your understanding!</em>
        <button id="lo-continue-btn">Continue</button>
    </div>

    <script>
        (function populateInitialHTML() {
            const boxIconSVG = `<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`;
            const clockOnIconSVG = `<svg class="icon icon-clock-on" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`;
            const clockOffIconSVG = `<svg class="icon icon-clock-off" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>`;

            document.getElementById('new-toolbar').innerHTML = `
                <button class="new-btn" id="back-btn" title="Go Back"></button>
                <button class="new-btn" id="single-page-btn" title="Single Page View" style="font-size: 28px; line-height: 1;"></button>
                <button class="new-btn" id="double-page-btn" title="Double Page View"></button>
                <button class="new-btn" id="time-capsule-btn" title="Time Capsule (TOC Disabled)">${boxIconSVG}</button>
            `;
            document.getElementById('left-toolbar').innerHTML = `
                <button class="new-btn" id="timelock-toggle-btn" title="Toggle Reading Time Lock (On)">
                    ${clockOnIconSVG}
                    ${clockOffIconSVG}
                </button>
            `;
            document.getElementById('loading-overlay').innerHTML = `<div class="loading-spinner"></div><div class="loading-message">Processing...</div>`;
        })();
    </script>

    <script>
        (function() {
            'use strict';

            // --- State & Constants ---
            let notesNavFadeTimeout = null;
            let isChapterReady = false;
            let toolbarTimer = null;
            let toolbarHover = !1;
            let leftToolbarTimer = null;
            let leftToolbarHover = !1;
            let isTimelockGloballyEnabled = true;
            let currentPageLockStartTime = 0;
            let requiredReadingTime = 0;
            let isTimeLockActive = false;
            let completedTimeLockPages = new Set();
            let currentLockType = null;

            const MAX_CACHE_SIZE = 20;
            const TOOLBAR_HIDE_DELAY = 500;
            const SLIDER_HIDE_DELAY = 1750;
            const READING_TIME_ALERT_DURATION = 2500;
            const GAME_OVER_TRANSITION_DELAY = 3000;
            const LOADING_BAR_ANIMATION_BUFFER = 600;
            const NOTES_WIGGLE_DURATION = 500;
            const LO_TOOLTIP_OFFSET_Y = 5;

            const CSS_CLASS = {
                VISIBLE: 'visible',
                LOADING_GAME_ACTIVE: 'loading-game-active',
                FULLSCREEN_MODE: 'fullscreen-mode',
                CONTENT_ROTATED_MODE: 'content-rotated-mode',
                PLACEHOLDER_PAGE: 'placeholder-page',
                FIRST_KEYWORD_INSTANCE: 'first-keyword-instance',
                TIMELOCK_ON: 'timelock-on',
                TIMELOCK_OFF: 'timelock-off',
                WIGGLE_NOW: 'wiggle-now',
                LOADING_CHAPTER: 'loading-chapter',
                LO_PASSED: 'lo-passed',
                HOVER_COLORED: 'hover-colored',
            };

            const appState = {
                isReaderReady: false,
                resizeTimer: null,
                sliderHideTimeout: null,
                gameOverTimeoutId: null,
                alertTimeout: null,
                alertWiggleTimeout: null,
                rotatedViewTargetPageNum: null,
                isDraggingSlider: false,
                pagePadding: 15,
                isSliderAreaHovered: false,
                learningOutcomes: [],
                loPopupTargetPage: null,
                originalSliderInfoText: null,
                sliderInfoFadeTimeout: null,
            };

            const pdfState = {
                pdfDocument: null,
                title: "No Document",
                totalPages: 0,
                currentPage: 1,
                isDoublePageView: true,
                pageCache: new Map(),
                currentViewports: {},
                keywordDefinitions: {},
                pageKeywords: {},
                globalFirstInstanceLocation: {},
                iframeMappings: {},
                notesMapping: {},
                notesPdfLoadingTask: null,
                currentNotesPdfDoc: null,
                currentNotesPageNum: 1,
                totalNotesPages: 0,
                outline: [],
            };

            const userState = {
                readingProgress: {
                    furthestPage: 1,
                },
            };

            const rawNotesData = [{
                "chapterPage": 11,
                "path": "chapters/ancient-history/chapter2-notes-1.pdf",
                "notesPage": 1
            }, {
                "chapterPage": 15,
                "path": "chapters/ancient-history/chapter2-notes-2.pdf",
                "notesPage": 1
            }, {
                "chapterPage": 21,
                "path": "chapters/ancient-history/chapter2-notes-3.pdf",
                "notesPage": 2
            }, {
                "chapterPage": 29,
                "path": "chapters/ancient-history/chapter2-notes-4.pdf",
                "notesPage": 2
            }, {
                "chapterPage": 35,
                "path": "chapters/ancient-history/chapter2-notes-5.pdf",
                "notesPage": 3
            }, {
                "chapterPage": 49,
                "path": "chapters/ancient-history/chapter2-notes-6.pdf",
                "notesPage": 3
            }, {
                "chapterPage": 55,
                "path": "chapters/ancient-history/chapter2-notes-7.pdf",
                "notesPage": 4
            }];

            // --- UI Elements Cache ---
            const ui = {
                body: document.body,
                mainContainer: document.querySelector('.main-container'),
                bookSpread: document.querySelector('.main-container .book-spread'),
                leftPageDiv: document.querySelector('.book-page.left'),
                rightPageDiv: document.querySelector('.book-page.right'),
                leftPageCanvas: document.getElementById('left-page-canvas'),
                rightPageCanvas: document.getElementById('right-page-canvas'),
                leftTextLayer: document.getElementById('left-text-layer'),
                rightTextLayer: document.getElementById('right-text-layer'),
                leftAnnotationLayer: document.getElementById('left-annotation-layer'),
                rightAnnotationLayer: document.getElementById('right-annotation-layer'),
                leftKeywordOverlay: document.getElementById('left-keyword-overlay'),
                rightKeywordOverlay: document.getElementById('right-keyword-overlay'),
                leftPageNumDisplay: document.getElementById('left-page-number'),
                rightPageNumDisplay: document.getElementById('right-page-number'),
                rightToolbar: document.getElementById('new-toolbar'),
                rightToolbarTrigger: document.getElementById('toolbar-trigger-area'),
                leftToolbar: document.getElementById('left-toolbar'),
                leftToolbarTrigger: document.getElementById('left-toolbar-trigger-area'),
                timelockToggleButton: document.getElementById('timelock-toggle-btn'),
                returnViewFixedBtn: document.getElementById('return-view-fixed-btn'),
                sliderContainer: document.getElementById('page-slider-container'),
                sliderTrack: document.querySelector('.page-slider-track'),
                loMilestonesContainer: document.getElementById('lo-milestones-container'),
                slider: document.getElementById('page-slider'),
                sliderTriggerZone: document.getElementById('page-slider-trigger-zone'),
                currentPageDisplay: document.getElementById('current-page-display'),
                totalPagesDisplay: document.getElementById('total-pages-display'),
                sliderInfo: document.querySelector('.page-slider-info'),
                loadingOverlay: document.getElementById('loading-overlay'),
                loadingMessage: document.querySelector('#loading-overlay .loading-message'),
                definitionPopup: document.getElementById('definition-popup'),
                popupWord: document.getElementById('popup-word'),
                popupDefinition: document.getElementById('popup-definition'),
                closePopupBtn: document.getElementById('close-popup-btn'),
                readingTimeAlert: document.getElementById('reading-time-alert'),
                iframePopupBackdrop: document.getElementById('iframe-popup-backdrop'),
                iframePopupModal: document.getElementById('iframe-popup-modal'),
                popupIframe: document.getElementById('popup-iframe'),
                closeIframePopupBtn: document.getElementById('close-iframe-popup-btn'),
                notesPopupBackdrop: document.getElementById('notes-popup-backdrop'),
                notesPopupContainer: document.getElementById('notes-popup-container'),
                notesPdfCanvasContainer: document.getElementById('notes-pdf-canvas-container'),
                notesPdfCanvas: document.getElementById('notes-pdf-canvas'),
                notesPrevBtn: document.getElementById('notes-prev-btn'),
                notesNextBtn: document.getElementById('notes-next-btn'),
                notesInstruction: document.getElementById('notes-instruction'),
                notesLocalLoader: document.querySelector('#notes-pdf-canvas-container .notes-local-loader'),
                gameContainer: document.getElementById('loading-game-container'),
                gameIframe: document.getElementById('game-iframe'),
                goToChapterBtn: document.getElementById('go-to-chapter-btn'),
                iframeLoadingText: document.getElementById('iframe-loading-text'),
                statusIndicator: document.getElementById('status-indicator'),
                loAchievementBackdrop: document.getElementById('lo-achievement-backdrop'),
                loAchievementPopup: document.getElementById('lo-achievement-popup'),
                loAchievementText: document.getElementById('lo-achievement-text'),
                loAchievementTip: document.getElementById('lo-achievement-tip'),
                loContinueBtn: document.getElementById('lo-continue-btn'),
                loTooltip: document.getElementById('lo-tooltip'),
            };

            // --- PDF.js Setup ---
            const {
                pdfjsLib,
                pdfjsViewer
            } = window;
            if (!pdfjsLib || !pdfjsViewer) {
                console.error("PDF.js library or viewer components not found!");
                document.body.innerHTML = `<div style="color:red;padding:20px;background:white;font-family:sans-serif;">Error: PDF.js failed to load.</div>`;
                return;
            }
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.worker.min.js';
            const linkService = new pdfjsViewer.SimpleLinkService();
            const eventBus = new pdfjsViewer.EventBus();

            // --- Utility Functions ---
            const updateStatus = (message) => console.log(`[Viewer Status] ${message}`);
            // const updateStatus = () => {};

            const toggleVisibility = (element, show) => {
                if (element) {
                    if (element === ui.goToChapterBtn) {
                        if (show) {} else {
                            element.classList.remove(CSS_CLASS.VISIBLE, CSS_CLASS.LOADING_CHAPTER);
                        }
                    } else if (element === ui.loAchievementBackdrop || element === ui.loAchievementPopup) {
                        element.classList.toggle(CSS_CLASS.VISIBLE, show);
                    } else if (element === ui.loTooltip) {
                        element.classList.toggle(CSS_CLASS.VISIBLE, show);
                    } else {
                        element.classList.toggle(CSS_CLASS.VISIBLE, show);
                    }
                }
            };

            const resetPopupStates = () => {
                hideDefinitionPopup();
                hideIframePopupIfNeeded();
                hideNotesPopupIfNeeded();
                hideLoAchievementPopup();
            };

            const getPageElement = (canvasId) => {
                const canvas = (canvasId === 'left-page-canvas') ? ui.leftPageCanvas : ui.rightPageCanvas;
                return canvas ? .closest('.book-page');
            };

            const getCanvasContainer = (pageElement) => pageElement ? .querySelector('.canvas-container');

            const clearPageLayers = (pageElement) => {
                if (!pageElement) return;
                const textLayer = pageElement.querySelector('.textLayer');
                const annotationLayer = pageElement.querySelector('.annotationLayer');
                const keywordOverlay = pageElement.querySelector('.keyword-overlay-container');
                if (textLayer) textLayer.innerHTML = '';
                if (annotationLayer) annotationLayer.innerHTML = '';
                if (keywordOverlay) keywordOverlay.innerHTML = '';
            };

            const showPageLoading = (canvasId) => {
                const overlay = getPageElement(canvasId) ? .querySelector('.page-loading-overlay');
                if (overlay) overlay.style.display = 'flex';
            };

            const hidePageLoading = (canvasId) => {
                const overlay = getPageElement(canvasId) ? .querySelector('.page-loading-overlay');
                if (overlay) overlay.style.display = 'none';
            };

            // --- Toolbar Logic ---
            function manageToolbar(s = null) {
                const t = document.getElementById('new-toolbar');
                if (!t || document.body.classList.contains('loading-game-active')) return;
                clearTimeout(toolbarTimer);
                const show = s ? ? toolbarHover;
                if (show) {
                    t.classList.add('visible')
                } else {
                    toolbarTimer = setTimeout(() => {
                        if (!toolbarHover) t.classList.remove('visible')
                    }, 500)
                }
            }

            function setupToolbarHover() {
                const t = document.getElementById('new-toolbar'),
                    a = document.getElementById('toolbar-trigger-area'),
                    h = t;
                if (!t || !a) {
                    console.error("Right Toolbar/trigger missing");
                    return
                }
                const enter = () => {
                    if (document.body.classList.contains('loading-game-active')) return;
                    toolbarHover = true;
                    manageToolbar(true)
                };
                const leave = () => {
                    toolbarHover = false;
                    manageToolbar(false)
                };
                a.addEventListener('mouseenter', enter);
                t.addEventListener('mouseenter', enter);
                a.addEventListener('mouseleave', leave);
                t.addEventListener('mouseleave', leave);
                h.addEventListener('click', e => {
                    if (document.body.classList.contains('loading-game-active')) return;
                    if (e.target.closest('.new-btn')) return;
                    const r = h.getBoundingClientRect();
                    let c = false;
                    const w = 25;
                    if (e.clientY >= r.top && e.clientY <= r.bottom && e.clientX < r.left && e.clientX >= r.left - w) c = true;
                    if (c) {
                        toolbarHover = !t.classList.contains('visible');
                        manageToolbar()
                    }
                });
                updateStatus("Right Toolbar setup.")
            }

            function manageLeftToolbar(s = null) {
                const t = document.getElementById('left-toolbar');
                if (!t || document.body.classList.contains('loading-game-active')) return;
                clearTimeout(leftToolbarTimer);
                const show = s ? ? leftToolbarHover;
                if (show) {
                    t.classList.add('visible')
                } else {
                    leftToolbarTimer = setTimeout(() => {
                        if (!leftToolbarHover) t.classList.remove('visible')
                    }, 500)
                }
            }

            function setupLeftToolbarHover() {
                const t = document.getElementById('left-toolbar'),
                    a = document.getElementById('left-toolbar-trigger-area'),
                    h = t;
                if (!t || !a) {
                    console.error("Left Toolbar/trigger missing");
                    return
                }
                const enter = () => {
                    if (document.body.classList.contains('loading-game-active')) return;
                    leftToolbarHover = true;
                    manageLeftToolbar(true)
                };
                const leave = () => {
                    leftToolbarHover = false;
                    manageLeftToolbar(false)
                };
                a.addEventListener('mouseenter', enter);
                t.addEventListener('mouseenter', enter);
                a.addEventListener('mouseleave', leave);
                t.addEventListener('mouseleave', leave);
                h.addEventListener('click', e => {
                    if (document.body.classList.contains('loading-game-active')) return;
                    if (e.target.closest('.new-btn')) return;
                    const r = h.getBoundingClientRect();
                    let c = false;
                    const w = 25;
                    if (e.clientY >= r.top && e.clientY <= r.bottom && e.clientX > r.right && e.clientX <= r.right + w) c = true;
                    if (c) {
                        leftToolbarHover = !t.classList.contains('visible');
                        manageLeftToolbar()
                    }
                });
                updateStatus("Left Toolbar setup.")
            }

            // --- Caching ---
            function trimCache() {
                while (pdfState.pageCache.size > MAX_CACHE_SIZE) {
                    pdfState.pageCache.delete(pdfState.pageCache.keys().next().value);
                }
            }

            // --- Keyword Overlays ---
            async function createKeywordOverlays(pageNum, pageElement, viewport) {
                const overlayContainerId = pageElement.classList.contains('left') ? 'left-keyword-overlay' : 'right-keyword-overlay';
                const overlayContainer = document.getElementById(overlayContainerId);
                const canvasContainer = getCanvasContainer(pageElement);

                if (!pdfState.pdfDocument || !overlayContainer || !canvasContainer) {
                    console.warn(`Skipping keyword overlay for page ${pageNum}: Missing elements.`);
                    return;
                }
                overlayContainer.innerHTML = '';

                const keywordsForPage = pdfState.pageKeywords[pageNum.toString()] || [];
                if (keywordsForPage.length === 0) return;

                const lowerCaseKeywords = keywordsForPage.map(k => k.toLowerCase());
                const lowerCaseDefs = {};
                for (const key in pdfState.keywordDefinitions) {
                    lowerCaseDefs[key.toLowerCase()] = pdfState.keywordDefinitions[key];
                }

                try {
                    const page = await pdfState.pdfDocument.getPage(pageNum);
                    const textContent = await page.getTextContent({
                        normalizeWhitespace: true
                    });
                    const items = textContent.items;

                    for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                        const item = items[itemIndex];
                        const itemText = item.str;
                        const itemTextLength = itemText.length;
                        if (!itemText || itemText.trim().length === 0 || itemTextLength === 0 || item.width === 0) continue;

                        keywordsForPage.forEach((originalKeyword, keywordIndex) => {
                            const keywordLower = lowerCaseKeywords[keywordIndex];
                            const definitionData = lowerCaseDefs[keywordLower];

                            if (!Array.isArray(definitionData) || definitionData.length < 2 || typeof definitionData[1] !== 'string' || !definitionData[1]) {
                                return;
                            }
                            const partOfSpeech = definitionData[0] || '';
                            const actualDefinition = definitionData[1];

                            const escapedKeyword = originalKeyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                            const regex = new RegExp(`\\b(${escapedKeyword})\\b`, 'gi');
                            let match;

                            while ((match = regex.exec(itemText)) !== null) {
                                const matchedString = match[1];
                                const matchIndex = match.index;
                                const matchLength = matchedString.length;

                                if (matchLength === 0) {
                                    regex.lastIndex++;
                                    continue;
                                }

                                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                                const itemWidth = item.width;
                                const itemHeight = item.height;
                                const itemLeft = tx[4];
                                const itemTop = tx[5] - itemHeight;

                                const highlightOffsetX = (matchIndex / itemTextLength) * itemWidth;
                                const highlightWidth = (matchLength / itemTextLength) * itemWidth;

                                const finalLeft = Math.max(0, itemLeft + highlightOffsetX);
                                const finalTop = Math.max(0, itemTop);
                                const finalWidth = Math.max(1, highlightWidth);
                                const finalHeight = itemHeight > 0 ? itemHeight : parseFloat(getComputedStyle(overlayContainer).fontSize) || 12;

                                const highlightDiv = document.createElement('div');
                                highlightDiv.className = 'keyword-highlight';
                                highlightDiv.style.left = `${finalLeft}px`;
                                highlightDiv.style.top = `${finalTop}px`;
                                highlightDiv.style.width = `${finalWidth}px`;
                                highlightDiv.style.height = `${finalHeight}px`;

                                highlightDiv.dataset.keyword = originalKeyword;
                                highlightDiv.dataset.pos = partOfSpeech;
                                highlightDiv.dataset.definition = actualDefinition;
                                highlightDiv.title = `${originalKeyword} ${partOfSpeech}`;

                                const firstLoc = pdfState.globalFirstInstanceLocation[keywordLower];
                                if (firstLoc && firstLoc.pageNum === pageNum && firstLoc.itemIndex === itemIndex && firstLoc.matchIndex === matchIndex) {
                                    highlightDiv.classList.add(CSS_CLASS.FIRST_KEYWORD_INSTANCE);
                                }

                                highlightDiv.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    if (ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE)) return;
                                    const currentHighlight = e.currentTarget;
                                    showDefinitionPopup(currentHighlight);
                                });
                                overlayContainer.appendChild(highlightDiv);
                            }
                        });
                    }
                } catch (error) {
                    console.error(`Error processing text content for keyword overlays on page ${pageNum}:`, error);
                    overlayContainer.innerHTML = '';
                }
            }

            // --- Text & Annotation Layer Rendering ---
            async function renderAndEnhanceTextLayer(page, container, viewport) {
                if (!page || !container || !viewport) return;
                container.innerHTML = '';
                try {
                    const textContent = await page.getTextContent({
                        normalizeWhitespace: true
                    });
                    const renderTask = pdfjsLib.renderTextLayer({
                        textContent,
                        container,
                        viewport
                    });
                    await renderTask.promise;
                } catch (error) {
                    console.error(`Error rendering base text layer for page ${page.pageNumber}:`, error);
                    container.innerHTML = '';
                }
            }

            async function renderAnnotationLayer(page, container, viewport) {
                if (!page || !container || !viewport) {
                    console.warn("Skipping annotation layer: params missing.");
                    return
                }
                container.innerHTML = '';
                try {
                    const annotations = await page.getAnnotations();
                    if (annotations.length === 0) return;

                    pdfjsLib.AnnotationLayer.render({
                        viewport: viewport.clone({
                            dontFlip: true
                        }),
                        div: container,
                        annotations: annotations,
                        page: page,
                        linkService: linkService
                    });

                    requestAnimationFrame(() => {
                        const links = container.querySelectorAll('.linkAnnotation > a');
                        links.forEach(link => {
                            link.setAttribute('target', '_blank');
                            link.setAttribute('rel', 'noopener noreferrer');
                        });
                    });

                } catch (error) {
                    console.error(`Error rendering annotation layer for page ${page.pageNumber}:`, error);
                    container.innerHTML = '';
                }
            }

            // --- Page Rendering ---
            async function renderPage(pageNum, canvasId) {
                const canvas = (canvasId === 'left-page-canvas') ? ui.leftPageCanvas : ui.rightPageCanvas;
                const ctx = canvas ? .getContext('2d');
                const pageElement = getPageElement(canvasId);
                const canvasContainer = getCanvasContainer(pageElement);
                const textLayerContainer = pageElement ? .querySelector('.textLayer');
                const annotationLayerContainer = pageElement ? .querySelector('.annotationLayer');
                const keywordOverlayContainer = pageElement ? .querySelector('.keyword-overlay-container');

                delete pdfState.currentViewports[canvasId];
                clearPageLayers(pageElement);

                if (!pdfState.pdfDocument || !canvas || !ctx || !canvasContainer || !textLayerContainer || !annotationLayerContainer || !keywordOverlayContainer || !pageElement || pageNum < 1 || pageNum > pdfState.totalPages) {
                    if (canvas && ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (pageElement) pageElement.classList.add(CSS_CLASS.PLACEHOLDER_PAGE);
                    hidePageLoading(canvasId);
                    return;
                }

                showPageLoading(canvasId);
                pageElement.classList.remove(CSS_CLASS.PLACEHOLDER_PAGE);
                let page;
                let viewport;

                try {
                    if (pdfState.pageCache.has(pageNum)) {
                        const cachedData = pdfState.pageCache.get(pageNum);
                        canvas.width = cachedData.width;
                        canvas.height = cachedData.height;
                        canvas.style.width = `${cachedData.styleWidth}px`;
                        canvas.style.height = `${cachedData.styleHeight}px`;
                        ctx.putImageData(cachedData.imageData, 0, 0);
                        page = await pdfState.pdfDocument.getPage(pageNum);
                        viewport = cachedData.viewport;
                        pdfState.currentViewports[canvasId] = viewport;
                        pdfState.pageCache.delete(pageNum);
                        pdfState.pageCache.set(pageNum, cachedData);
                        hidePageLoading(canvasId);
                    } else {
                        page = await pdfState.pdfDocument.getPage(pageNum);
                        const containerStyle = getComputedStyle(canvasContainer);
                        const availableWidth = parseFloat(containerStyle.width);
                        const availableHeight = parseFloat(containerStyle.height);

                        if (isNaN(availableWidth) || isNaN(availableHeight) || availableWidth <= 0 || availableHeight <= 0) {
                            console.warn(`Canvas container ${canvasId} has invalid dimensions during renderPage call for page ${pageNum}. Skipping render.`);
                            hidePageLoading(canvasId);
                            return;
                        }

                        const defaultViewport = page.getViewport({
                            scale: 1
                        });
                        const scale = Math.min(availableWidth / defaultViewport.width, availableHeight / defaultViewport.height);
                        viewport = page.getViewport({
                            scale: scale
                        });
                        pdfState.currentViewports[canvasId] = viewport;

                        const outputScale = window.devicePixelRatio || 1;
                        canvas.width = Math.floor(viewport.width * outputScale);
                        canvas.height = Math.floor(viewport.height * outputScale);
                        canvas.style.width = `${Math.floor(viewport.width)}px`;
                        canvas.style.height = `${Math.floor(viewport.height)}px`;

                        const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
                        await page.render({
                            canvasContext: ctx,
                            transform,
                            viewport
                        }).promise;

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        pdfState.pageCache.set(pageNum, {
                            imageData,
                            width: canvas.width,
                            height: canvas.height,
                            styleWidth: Math.floor(viewport.width),
                            styleHeight: Math.floor(viewport.height),
                            viewport
                        });
                        trimCache();
                        hidePageLoading(canvasId);
                    }

                    await renderAndEnhanceTextLayer(page, textLayerContainer, viewport);
                    await renderAnnotationLayer(page, annotationLayerContainer, viewport);
                    await createKeywordOverlays(pageNum, pageElement, viewport);

                } catch (error) {
                    console.error(`Error rendering page ${pageNum} on ${canvasId}:`, error);
                    if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
                    hidePageLoading(canvasId);
                    pageElement ? .classList.add(CSS_CLASS.PLACEHOLDER_PAGE);
                }
            }

            // --- Reading Time Calculation ---
            async function calculatePageReadingTime(pageNum, viewport) {
                if (!pdfState.pdfDocument || !viewport || pageNum < 1 || pageNum > pdfState.totalPages) {
                    return 0;
                }
                try {
                    const page = await pdfState.pdfDocument.getPage(pageNum);
                    const [textContent, annotations] = await Promise.all([
                        page.getTextContent({
                            normalizeWhitespace: true
                        }),
                        page.getAnnotations()
                    ]);

                    const linkAnnotations = annotations.filter(annot => annot.subtype === 'Link' && annot.rect);
                    const linkRectsInViewport = linkAnnotations.map(annot => viewport.convertToViewportRectangle(annot.rect));

                    let wordCount = 0;
                    for (const item of textContent.items) {
                        const itemText = item.str;
                        if (!itemText || itemText.trim().length === 0 || item.width === 0) continue;

                        const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                        const itemWidth = item.width;
                        const itemHeight = item.height > 0 ? item.height : 12;
                        const itemLeft = tx[4];
                        const itemTop = tx[5] - itemHeight;
                        const itemRect = [itemLeft, itemTop, itemLeft + itemWidth, itemTop + itemHeight];

                        let isInsideLink = false;
                        const itemCenterX = itemRect[0] + (itemRect[2] - itemRect[0]) / 2;
                        const itemCenterY = itemRect[1] + (itemRect[3] - itemRect[1]) / 2;
                        for (const linkRect of linkRectsInViewport) {
                            if (itemCenterX >= linkRect[0] && itemCenterX <= linkRect[2] &&
                                itemCenterY >= linkRect[1] && itemCenterY <= linkRect[3]) {
                                isInsideLink = true;
                                break;
                            }
                        }

                        if (!isInsideLink) {
                            wordCount += itemText.trim().split(/\s+/).filter(Boolean).length;
                        }
                    }
                    const readingTimeSeconds = Math.ceil(wordCount / 5);
                    return readingTimeSeconds;

                } catch (error) {
                    console.error(`Error calculating reading time for page ${pageNum}:`, error);
                    return 0;
                }
            }

            // --- Update Display ---
            async function updateDisplay() {
                if (!pdfState.pdfDocument) {
                    updateStatus("UpdateDisplay skipped: No PDF loaded.");
                    return;
                }

                const leftPageNum = pdfState.currentPage;
                const potentialRightPageNum = pdfState.isDoublePageView ? pdfState.currentPage + 1 : 0;

                if (!ui.leftPageDiv || !ui.rightPageDiv || !ui.leftPageNumDisplay || !ui.rightPageNumDisplay) {
                    console.error("Critical page elements missing! Cannot update display.");
                    return;
                }

                const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
                const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
                const isEffectiveDoublePageView = pdfState.isDoublePageView && !isFullscreen && !isContentRotated;

                let renderPromises = [];
                let leftPageNumToRender = pdfState.currentPage;

                if (isContentRotated && appState.rotatedViewTargetPageNum !== null) {
                    leftPageNumToRender = appState.rotatedViewTargetPageNum;
                    updateStatus(`Rotated view active. Rendering target page ${leftPageNumToRender} into left canvas.`);
                } else if (!isContentRotated) {
                    leftPageNumToRender = pdfState.currentPage;
                } else {
                    console.warn("In rotated view but no target page number set in appState. Defaulting to currentPage.");
                    leftPageNumToRender = pdfState.currentPage;
                }

                isTimeLockActive = false;
                currentPageLockStartTime = 0;
                requiredReadingTime = 0;
                currentLockType = null;

                if (leftPageNumToRender >= 1 && leftPageNumToRender <= pdfState.totalPages) {
                    ui.leftPageNumDisplay.textContent = String(leftPageNumToRender);
                    renderPromises.push(renderPage(leftPageNumToRender, 'left-page-canvas'));
                } else {
                    ui.leftPageNumDisplay.textContent = '';
                    const lCtx = ui.leftPageCanvas ? .getContext('2d');
                    if (lCtx) lCtx.clearRect(0, 0, ui.leftPageCanvas.width, ui.leftPageCanvas.height);
                    clearPageLayers(ui.leftPageDiv);
                    ui.leftPageDiv.classList.add(CSS_CLASS.PLACEHOLDER_PAGE);
                    delete pdfState.currentViewports['left-page-canvas'];
                }

                ui.rightPageDiv.style.display = 'none';
                ui.rightPageDiv.classList.remove(CSS_CLASS.PLACEHOLDER_PAGE);
                const rCtx = ui.rightPageCanvas ? .getContext('2d');
                if (rCtx) rCtx.clearRect(0, 0, ui.rightPageCanvas.width, ui.rightPageCanvas.height);
                clearPageLayers(ui.rightPageDiv);
                ui.rightPageNumDisplay.textContent = '';
                delete pdfState.currentViewports['right-page-canvas'];

                let actualRightPageNum = 0;

                if (isEffectiveDoublePageView) {
                    actualRightPageNum = pdfState.currentPage + 1;
                    if (actualRightPageNum >= 1 && actualRightPageNum <= pdfState.totalPages) {
                        ui.rightPageNumDisplay.textContent = String(actualRightPageNum);
                        ui.rightPageDiv.style.display = 'flex';
                        renderPromises.push(renderPage(actualRightPageNum, 'right-page-canvas'));
                    } else if (pdfState.currentPage >= 1 && pdfState.currentPage <= pdfState.totalPages) {
                        ui.rightPageDiv.style.display = 'flex';
                        ui.rightPageDiv.classList.add(CSS_CLASS.PLACEHOLDER_PAGE);
                        ui.rightPageNumDisplay.textContent = '';
                        actualRightPageNum = 0;
                    }
                }

                await Promise.all(renderPromises);

                const leftEdgeNavLeft = ui.leftPageDiv ? .querySelector('.page-edge-left');
                const leftEdgeNavRight = ui.leftPageDiv ? .querySelector('.page-edge-right');
                const rightEdgeNavLeft = ui.rightPageDiv ? .querySelector('.page-edge-left');
                const rightEdgeNavRight = ui.rightPageDiv ? .querySelector('.page-edge-right');

                if (leftEdgeNavLeft) leftEdgeNavLeft.style.display = '';
                if (rightEdgeNavRight) rightEdgeNavRight.style.display = 'none';
                if (leftEdgeNavRight) leftEdgeNavRight.style.display = 'none';
                if (rightEdgeNavLeft) rightEdgeNavLeft.style.display = 'none';

                if (isEffectiveDoublePageView) {
                    if (rightEdgeNavRight && !ui.rightPageDiv ? .classList.contains(CSS_CLASS.PLACEHOLDER_PAGE)) {
                        rightEdgeNavRight.style.display = '';
                    }
                } else {
                    if (leftEdgeNavRight) leftEdgeNavRight.style.display = '';
                }

                if (isTimelockGloballyEnabled) {
                    if (isContentRotated) {
                        const rotatedPageNum = leftPageNumToRender;
                        const rotatedViewport = pdfState.currentViewports['left-page-canvas'];
                        let timeRotated = 0;
                        if (rotatedPageNum >= 1 && rotatedPageNum <= pdfState.totalPages && rotatedViewport) {
                            timeRotated = await calculatePageReadingTime(rotatedPageNum, rotatedViewport);
                        }

                        if (completedTimeLockPages.has(rotatedPageNum)) {
                            updateStatus(`Time lock previously completed for rotated page ${rotatedPageNum}. Skipping set.`);
                        } else if (timeRotated > 0) {
                            requiredReadingTime = timeRotated;
                            currentPageLockStartTime = Date.now();
                            isTimeLockActive = true;
                            currentLockType = 'pdf';
                            updateStatus(`Time lock SET (Rotated View) for page ${rotatedPageNum}. Time: ${requiredReadingTime}s`);
                        } else {
                            updateStatus(`Time lock NOT SET for rotated page ${rotatedPageNum} (time=0 or already completed).`);
                        }
                    } else if (isEffectiveDoublePageView) {
                        const leftViewport = pdfState.currentViewports['left-page-canvas'];
                        const rightViewport = pdfState.currentViewports['right-page-canvas'];

                        let timeLeft = 0;
                        if (pdfState.currentPage >= 1 && pdfState.currentPage <= pdfState.totalPages && leftViewport) {
                            timeLeft = await calculatePageReadingTime(pdfState.currentPage, leftViewport);
                        }
                        let timeRight = 0;
                        if (actualRightPageNum > 0 && rightViewport) {
                            timeRight = await calculatePageReadingTime(actualRightPageNum, rightViewport);
                        }

                        const timeForPair = timeLeft + timeRight;
                        const firstPageOfCurrentPair = pdfState.currentPage;

                        if (completedTimeLockPages.has(firstPageOfCurrentPair)) {
                            updateStatus(`Time lock previously completed for pair starting ${firstPageOfCurrentPair}. Skipping set.`);
                        } else if (timeForPair > 0) {
                            requiredReadingTime = timeForPair;
                            currentPageLockStartTime = Date.now();
                            isTimeLockActive = true;
                            currentLockType = 'pdf';
                            updateStatus(`Time lock SET (Double View - Pair) for pair starting ${firstPageOfCurrentPair}. Time: ${requiredReadingTime}s`);
                        } else {
                            updateStatus(`Time lock NOT SET for pair starting ${firstPageOfCurrentPair} (time=0 or already completed).`);
                        }
                    } else {
                        const currentPageNum = pdfState.currentPage;
                        const isEvenPage = currentPageNum > 0 && currentPageNum % 2 === 0;

                        if (isEvenPage) {
                            if (completedTimeLockPages.has(currentPageNum)) {
                                updateStatus(`Time lock previously completed for single page ${currentPageNum}. Skipping set.`);
                            } else {
                                const singlePageViewPort = pdfState.currentViewports['left-page-canvas'];
                                let timeSingle = 0;
                                if (currentPageNum >= 1 && currentPageNum <= pdfState.totalPages && singlePageViewPort) {
                                    timeSingle = await calculatePageReadingTime(currentPageNum, singlePageViewPort);
                                }

                                if (timeSingle > 0) {
                                    requiredReadingTime = timeSingle;
                                    currentPageLockStartTime = Date.now();
                                    isTimeLockActive = true;
                                    currentLockType = 'pdf';
                                    updateStatus(`Time lock SET (Single View - Even Page) for page ${currentPageNum}. Time: ${requiredReadingTime}s`);
                                } else {
                                    updateStatus(`Time lock NOT SET for single page ${currentPageNum} (time=0 or already completed).`);
                                }
                            }
                        } else {
                            updateStatus(`Time lock NOT APPLICABLE (Single View - Odd/Invalid Page) for page ${currentPageNum}.`);
                        }
                    }
                } else {
                    isTimeLockActive = false;
                    requiredReadingTime = 0;
                    currentPageLockStartTime = 0;
                    currentLockType = null;
                    updateStatus("Time lock globally DISABLED. Skipping lock calculation/set.");
                }

                updateSliderPosition();
                preloadAdjacentPages(pdfState.currentPage);
                applyCurrentViewModeStyles();

                let shouldShowNotesPopup = false;
                const currentPageToCheckPopups = isContentRotated ? leftPageNumToRender : pdfState.currentPage;

                if (currentPageToCheckPopups >= 1 && currentPageToCheckPopups <= pdfState.totalPages) {
                    const notesInfo = pdfState.notesMapping[currentPageToCheckPopups.toString()];
                    if (notesInfo) {
                        updateStatus(`Notes Popup found for page ${currentPageToCheckPopups}. Showing.`);
                        showNotesPopup(notesInfo.pdf, notesInfo.page);
                        shouldShowNotesPopup = true;
                    } else {
                        hideNotesPopupIfNeeded();
                    }

                    if (!shouldShowNotesPopup) {
                        const iframeUrl = pdfState.iframeMappings[currentPageToCheckPopups.toString()];
                        if (iframeUrl) {
                            updateStatus(`Iframe Popup found for page ${currentPageToCheckPopups}. Showing.`);
                            showIframePopup(iframeUrl);
                        } else {
                            hideIframePopupIfNeeded();
                        }
                    } else {
                        hideIframePopupIfNeeded();
                    }
                } else {
                    hideNotesPopupIfNeeded();
                    hideIframePopupIfNeeded();
                }

                updateStatus("Display update complete.");
            }

            // --- Preloading ---
            function preloadAdjacentPages(currentPage) {
                if (!pdfState.pdfDocument) return;
                const lookahead = pdfState.isDoublePageView ? 2 : 1;
                const pagesToPreload = new Set();

                for (let i = 1; i <= lookahead; i++) {
                    const nextPage = currentPage + (pdfState.isDoublePageView ? i * 2 : i);
                    if (nextPage <= pdfState.totalPages) {
                        pagesToPreload.add(nextPage);
                        if (pdfState.isDoublePageView && nextPage + 1 <= pdfState.totalPages) {
                            pagesToPreload.add(nextPage + 1);
                        }
                    }
                }
                for (let i = 1; i <= lookahead; i++) {
                    const prevPage = currentPage - (pdfState.isDoublePageView ? i * 2 : i);
                    if (prevPage >= 1) {
                        pagesToPreload.add(prevPage);
                        if (pdfState.isDoublePageView && prevPage + 1 >= 1 && prevPage + 1 < currentPage) {
                            pagesToPreload.add(prevPage + 1);
                        }
                    }
                }

                const uniquePagesToLoad = [...pagesToPreload].filter(p =>
                    p > 0 && p <= pdfState.totalPages && !pdfState.pageCache.has(p)
                );

                if (uniquePagesToLoad.length === 0) return;

                uniquePagesToLoad.forEach(pageNum => {
                    pdfState.pdfDocument.getPage(pageNum).then(page => {
                        const simWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w')) - (2 * appState.pagePadding);
                        const simHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h')) - (2 * appState.pagePadding);
                        const defaultViewport = page.getViewport({
                            scale: 1
                        });
                        const scale = Math.min(simWidth / defaultViewport.width, simHeight / defaultViewport.height, 1);
                        const viewport = page.getViewport({
                            scale: scale
                        });

                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        const outputScale = window.devicePixelRatio || 1;
                        tempCanvas.width = Math.floor(viewport.width * outputScale);
                        tempCanvas.height = Math.floor(viewport.height * outputScale);
                        const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

                        page.render({
                            canvasContext: tempCtx,
                            transform: transform,
                            viewport: viewport
                        }).promise.then(() => {
                            if (!pdfState.pageCache.has(pageNum)) {
                                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                                pdfState.pageCache.set(pageNum, {
                                    imageData,
                                    width: tempCanvas.width,
                                    height: tempCanvas.height,
                                    styleWidth: Math.floor(viewport.width),
                                    styleHeight: Math.floor(viewport.height),
                                    viewport
                                });
                                trimCache();
                            }
                        }).catch(err => console.warn(`Preloading render failed for page ${pageNum}: ${err.message}`));
                    }).catch(err => console.warn(`Failed to get page ${pageNum} for preloading: ${err.message}`));
                });
            }

            // --- Reading Time Alert ---
            function showReadingTimeAlert(message = '<em>Please read the text first!</em>') {
                if (!isTimelockGloballyEnabled) return;

                clearTimeout(appState.alertTimeout);
                clearTimeout(appState.alertWiggleTimeout);

                ui.readingTimeAlert.innerHTML = message;
                toggleVisibility(ui.readingTimeAlert, true);

                appState.alertTimeout = setTimeout(() => {
                    toggleVisibility(ui.readingTimeAlert, false);
                }, READING_TIME_ALERT_DURATION);
            }


            // --- Reading Time Lock Check ---
            function checkReadingTimeLock() {
                if (!isTimelockGloballyEnabled) {
                    updateStatus(`Time lock check: Globally DISABLED. Allowing navigation.`);
                    return false;
                }

                if (!isTimeLockActive) {
                    updateStatus(`Time lock check: Lock is INACTIVE. Allowing navigation.`);
                    return false;
                }

                if (currentLockType !== null && currentLockType !== 'pdf') {
                    updateStatus(`Time lock check (PDF Nav): Active lock is for '${currentLockType}', not PDF. Allowing PDF navigation.`);
                    return false;
                }

                const elapsedSeconds = (Date.now() - currentPageLockStartTime) / 1000;
                const lockAssociatedPage = pdfState.currentPage;

                if (elapsedSeconds < requiredReadingTime) {
                    updateStatus(`Time lock ACTIVE (Page/Pair ${lockAssociatedPage}): ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Blocking forward nav.`);
                    showReadingTimeAlert();
                    return true;
                } else {
                    updateStatus(`Time lock FINISHED (Page/Pair ${lockAssociatedPage}): ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Allowing forward nav.`);

                    if (!completedTimeLockPages.has(lockAssociatedPage)) {
                        completedTimeLockPages.add(lockAssociatedPage);
                        updateStatus(`Page/Pair ${lockAssociatedPage} added to completed time lock set.`);
                    }

                    isTimeLockActive = false;
                    requiredReadingTime = 0;
                    currentPageLockStartTime = 0;
                    return false;
                }
            }

            // --- Navigation ---
            function nextPage() {
                const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
                const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
                const isEffectiveDoublePageView = pdfState.isDoublePageView && !isFullscreen && !isContentRotated;

                const currentActualPage = pdfState.currentPage;
                const jumpIncrement = isEffectiveDoublePageView ? 2 : 1;
                let targetPageForJump = currentActualPage + jumpIncrement;

                if (targetPageForJump > pdfState.totalPages) {
                    if (currentActualPage < pdfState.totalPages && !isEffectiveDoublePageView) {
                        targetPageForJump = pdfState.totalPages;
                    } else if (currentActualPage < pdfState.totalPages && isEffectiveDoublePageView && targetPageForJump > pdfState.totalPages && currentActualPage % 2 !== 0) {
                        targetPageForJump = pdfState.totalPages;
                    } else {
                        updateStatus("NextPage called on last view. No action.");
                        return;
                    }
                }

                let potentialLoPage = -1;
                const currentRightPage = isEffectiveDoublePageView ? currentActualPage + 1 : -1;
                const lastPageInView = Math.max(currentActualPage, currentRightPage);

                const currentLo = appState.learningOutcomes.find(lo => lo.page_number === lastPageInView);

                if (currentLo) {
                    potentialLoPage = currentLo.page_number;
                    const milestoneElement = ui.loMilestonesContainer ? .querySelector(`.lo-milestone[data-lo-page="${potentialLoPage}"]`);
                    const alreadyPassed = milestoneElement ? .classList.contains(CSS_CLASS.LO_PASSED);

                    if (!alreadyPassed) {
                        updateStatus(`LO Milestone found on page ${potentialLoPage}. Showing achievement popup before navigating to ${targetPageForJump}.`);
                        showLoAchievementPopup(currentLo, targetPageForJump);
                        return;
                    } else {
                        updateStatus(`LO Milestone on page ${potentialLoPage} already passed. Skipping popup.`);
                    }
                }

                if (targetPageForJump >= 1 && targetPageForJump <= pdfState.totalPages) {
                    jumpToPage(targetPageForJump);
                } else if (targetPageForJump > pdfState.totalPages) {
                    jumpToPage(pdfState.totalPages);
                }
            }

            function prevPage() {
                const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
                const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
                const isEffectiveDoublePageView = pdfState.isDoublePageView && !isFullscreen && !isContentRotated;
                const decrement = isEffectiveDoublePageView ? 2 : 1;
                const targetPage = pdfState.currentPage - decrement;

                if (targetPage >= 1) {
                    jumpToPage(targetPage);
                } else if (pdfState.currentPage > 1) {
                    jumpToPage(1);
                }
            }

            function jumpToPage(pageNum) {
                if (!pdfState.pdfDocument || pageNum < 1 || pageNum > pdfState.totalPages) {
                    console.warn(`Jump to page ${pageNum} out of bounds (1-${pdfState.totalPages})`);
                    return;
                }

                let targetStartPage = pageNum;
                const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
                const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
                const isEffectiveDoublePageView = pdfState.isDoublePageView && !isFullscreen && !isContentRotated;

                if (isEffectiveDoublePageView && targetStartPage > 1 && targetStartPage % 2 === 0) {
                    targetStartPage--;
                }

                const currentStartPage = pdfState.currentPage;
                if (targetStartPage === currentStartPage) {
                    updateStatus(`Jump target (${targetStartPage}) is same as current (${currentStartPage}). No action.`);
                    if (document.activeElement === ui.slider) {
                        updateSliderPosition();
                    }
                    return;
                }

                const isMovingForward = targetStartPage > currentStartPage;

                if (isMovingForward) {
                    updateStatus(`Moving forward from ${currentStartPage} to ${targetStartPage}. Checking time lock...`);
                    if (checkReadingTimeLock()) {
                        updateStatus(`Navigation blocked by time lock.`);
                        if (ui.slider && (document.activeElement === ui.slider || (typeof event !== 'undefined' && event ? .target === ui.slider))) {
                            updateSliderPosition();
                        }
                        return;
                    }
                    updateStatus(`Time lock passed/completed/disabled. Proceeding with jump.`);
                } else {
                    updateStatus(`Moving backward from ${currentStartPage} to ${targetStartPage}. Skipping time lock check.`);
                    if (isTimeLockActive) {
                        currentLockType = null;
                        updateStatus("Clearing active time lock due to backward navigation.");
                        isTimeLockActive = false;
                        requiredReadingTime = 0;
                        currentPageLockStartTime = 0;
                    }
                }

                updateStatus(`Jumping to page ${targetStartPage} (requested ${pageNum})`);
                pdfState.currentPage = targetStartPage;

                if (isMovingForward && targetStartPage > userState.readingProgress.furthestPage) {
                    userState.readingProgress.furthestPage = targetStartPage;
                    updateStatus(`Furthest page updated to: ${userState.readingProgress.furthestPage}`);
                }

                resetPopupStates();

                updateDisplay();
                manageToolbar(false);
                manageLeftToolbar(false);
            }

            // --- View Modes & Scaling ---
            function checkAndApplyHandleState() {
                if (!ui.bookSpread || !ui.rightToolbar || !ui.leftToolbar) return;

                const viewportWidth = window.innerWidth;
                const bookRect = ui.bookSpread.getBoundingClientRect();
                const scaledBookWidth = bookRect.width;

                const overlapThreshold = 0.85;
                const shouldFloat = (scaledBookWidth > viewportWidth * overlapThreshold);

                ui.rightToolbar.classList.toggle('handle-floated-top-right', shouldFloat);
                ui.leftToolbar.classList.toggle('handle-floated-top-left', shouldFloat);
                ui.body.classList.toggle('right-handle-floated', shouldFloat);
                ui.body.classList.toggle('left-handle-floated', shouldFloat);

                if (shouldFloat) {
                    if (!ui.rightToolbar.classList.contains('visible')) {
                        manageToolbar(false);
                    }
                    if (!ui.leftToolbar.classList.contains('visible')) {
                        manageLeftToolbar(false);
                    }
                }
            }

            function applyCurrentViewModeStyles() {
                if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE) || !ui.bookSpread) return;

                const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
                const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
                const isEffectiveSinglePage = isFullscreen || isContentRotated || !pdfState.isDoublePageView;

                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const bookWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w'));
                const bookHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h'));

                let scale = 1;
                let transformValue = 'translate(-50%, -50%)';

                if (isContentRotated) {
                    const scaleX = viewportWidth / bookHeight;
                    const scaleY = viewportHeight / bookWidth;
                    scale = Math.min(scaleX, scaleY) * 0.98;
                    transformValue = `translate(-50%, -50%) rotate(90deg) scale(${scale})`;
                } else {
                    const totalWidth = isEffectiveSinglePage ? bookWidth : bookWidth * 2;
                    const scaleX = viewportWidth / totalWidth;
                    const scaleY = viewportHeight / bookHeight;
                    scale = Math.min(scaleX, scaleY) * 0.98;
                    transformValue = `translate(-50%, -50%) scale(${scale})`;
                }

                ui.bookSpread.style.transformOrigin = 'center center';
                ui.bookSpread.style.transform = transformValue;
                checkAndApplyHandleState();
            }

            async function setRotatedView(targetPageNum = null) {
                const wasRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);

                if (wasRotated) {
                    updateStatus("Setting back to previous view (Double/Single)");
                    ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE);
                    appState.rotatedViewTargetPageNum = null;
                    if (!pdfState.isDoublePageView) {
                        ui.body.classList.add(CSS_CLASS.FULLSCREEN_MODE);
                    }
                    if (pdfState.isDoublePageView && pdfState.currentPage > 1 && pdfState.currentPage % 2 === 0) {
                        updateStatus(`Adjusting current page from ${pdfState.currentPage} to ${pdfState.currentPage - 1} for double view restore.`);
                        pdfState.currentPage--;
                    }
                } else if (targetPageNum !== null) {
                    updateStatus(`Setting Content Rotated View for page ${targetPageNum}`);
                    appState.rotatedViewTargetPageNum = targetPageNum;
                    ui.body.classList.remove(CSS_CLASS.FULLSCREEN_MODE);
                    ui.body.classList.add(CSS_CLASS.CONTENT_ROTATED_MODE);
                } else {
                    console.warn("setRotatedView called without a target page number when entering rotated mode.");
                    return;
                }

                resetPopupStates();
                await updateDisplay();
                manageToolbar(false);
                manageLeftToolbar(false);
                updateSliderTotalPages();
                updateSliderPosition();
            }

            async function setSinglePageView() {
                const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
                const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
                if (!pdfState.isDoublePageView && isFullscreen && !isContentRotated) return;

                updateStatus("Setting Single Page View (Fullscreen Mode)");
                pdfState.isDoublePageView = false;
                ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE);
                ui.body.classList.add(CSS_CLASS.FULLSCREEN_MODE);

                resetPopupStates();
                await updateDisplay();
                manageToolbar(false);
                manageLeftToolbar(false);
                updateSliderTotalPages();
                updateSliderPosition();
            }

            async function setDoublePageView() {
                const isFullscreen = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
                const isContentRotated = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
                if (pdfState.isDoublePageView && !isFullscreen && !isContentRotated) return;

                updateStatus("Setting Double Page View");
                pdfState.isDoublePageView = true;
                ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE, CSS_CLASS.FULLSCREEN_MODE);

                if (pdfState.currentPage > 1 && pdfState.currentPage % 2 === 0) {
                    updateStatus(`Adjusting current page from ${pdfState.currentPage} to ${pdfState.currentPage - 1} for double view.`);
                    pdfState.currentPage--;
                }

                resetPopupStates();
                await updateDisplay();
                manageToolbar(false);
                manageLeftToolbar(false);
                updateSliderTotalPages();
                updateSliderPosition();
            }

            function calculateVideoDuration(url) {
                const DEFAULT_VIDEO_LOCK_TIME = 60;
                try {
                    const urlObj = new URL(url);
                    const params = urlObj.searchParams;

                    let startTime = null;
                    let endTime = null;

                    if (params.has('start')) {
                        startTime = parseInt(params.get('start'), 10);
                    } else if (params.has('t')) {
                        const tParam = params.get('t');
                        if (tParam.includes('m') || tParam.includes('s')) {
                            let totalSeconds = 0;
                            const minutesMatch = tParam.match(/(\d+)m/);
                            const secondsMatch = tParam.match(/(\d+)s/);
                            if (minutesMatch) totalSeconds += parseInt(minutesMatch[1], 10) * 60;
                            if (secondsMatch) totalSeconds += parseInt(secondsMatch[1], 10);
                            startTime = totalSeconds > 0 ? totalSeconds : null;
                        } else {
                            startTime = parseInt(tParam, 10);
                        }
                    }

                    if (params.has('end')) {
                        endTime = parseInt(params.get('end'), 10);
                    }

                    startTime = isNaN(startTime) ? null : startTime;
                    endTime = isNaN(endTime) ? null : endTime;

                    if (startTime !== null && endTime !== null && endTime > startTime) {
                        updateStatus(`Timelock duration from start/end params: ${endTime - startTime}s`);
                        return endTime - startTime;
                    } else if (startTime !== null) {
                        updateStatus(`Timelock duration using default (only start time found).`);
                        return DEFAULT_VIDEO_LOCK_TIME;
                    } else {
                        updateStatus(`Timelock duration using default (no time params found).`);
                        return DEFAULT_VIDEO_LOCK_TIME;
                    }
                } catch (e) {
                    console.warn("Error parsing video URL for timelock duration, using default.", e);
                    return DEFAULT_VIDEO_LOCK_TIME;
                }
            }

            // --- UI Toggles ---
            function showLoading(msg = 'Processing...') {
                if (ui.loadingOverlay && ui.loadingMessage) {
                    ui.loadingMessage.textContent = msg;
                    toggleVisibility(ui.loadingOverlay, true);
                }
            }

            function hideLoading() {
                toggleVisibility(ui.loadingOverlay, false);
            }

            // --- Slider Logic ---
            function showPageSlider() {
                if (!ui.sliderContainer || ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;
                clearTimeout(appState.sliderHideTimeout);
                toggleVisibility(ui.sliderContainer, true);
            }

            function hidePageSlider() {
                if (!appState.isDraggingSlider && !appState.isSliderAreaHovered) {
                    toggleVisibility(ui.sliderContainer, false);
                }
            }

            function startSliderHideTimer() {
                clearTimeout(appState.sliderHideTimeout);
                appState.sliderHideTimeout = setTimeout(hidePageSlider, SLIDER_HIDE_DELAY);
            }

            function initPageSlider() {
                if (!ui.slider || !ui.sliderContainer || !ui.sliderTriggerZone || !ui.loMilestonesContainer || !ui.loTooltip) {
                    console.error("Slider elements, trigger zone, LO container, or LO tooltip not found");
                    return;
                }

                setTimeout(checkAndApplyHandleState, 500);

                const handleSliderAreaEnter = () => {
                    if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;
                    appState.isSliderAreaHovered = true;
                    showPageSlider();
                };

                const handleSliderAreaLeave = () => {
                    appState.isSliderAreaHovered = false;
                    if (!appState.isDraggingSlider) {
                        startSliderHideTimer();
                    }
                };

                ui.sliderTriggerZone.addEventListener('mouseenter', handleSliderAreaEnter);
                ui.sliderTriggerZone.addEventListener('mouseleave', handleSliderAreaLeave);
                ui.sliderContainer.addEventListener('mouseenter', handleSliderAreaEnter);
                ui.sliderContainer.addEventListener('mouseleave', handleSliderAreaLeave);

                const handleSliderInput = () => {
                    if (!appState.isDraggingSlider) return;
                    const targetPageValue = parseInt(ui.slider.value, 10);
                    updateSliderInfoText(targetPageValue);
                    updateSliderStyle(ui.slider, targetPageValue);
                    updateMilestoneColors(targetPageValue);
                };

                const handlePointerDown = () => {
                    if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;
                    appState.isDraggingSlider = true;
                    clearTimeout(appState.sliderHideTimeout);
                };

                const handlePointerUpOrChange = (event) => {
                    if (!appState.isDraggingSlider && event.type !== 'change') return;
                    const wasDragging = appState.isDraggingSlider;
                    appState.isDraggingSlider = false;

                    const targetPageValue = parseInt(ui.slider.value, 10);
                    updateStatus(`Slider action ended at value: ${targetPageValue}`);
                    jumpToPage(targetPageValue);

                    if (!appState.isSliderAreaHovered) {
                        startSliderHideTimer();
                    }
                };

                const handleLostPointer = () => {
                    if (appState.isDraggingSlider) {
                        appState.isDraggingSlider = false;
                        const targetPageValue = parseInt(ui.slider.value, 10);
                        updateStatus(`Slider lost capture at value: ${targetPageValue}`);
                        jumpToPage(targetPageValue);
                        if (!appState.isSliderAreaHovered) {
                            startSliderHideTimer();
                        }
                    }
                };

                ui.slider.addEventListener('input', handleSliderInput);
                ui.slider.addEventListener('pointerdown', handlePointerDown);
                ui.slider.addEventListener('pointerup', handlePointerUpOrChange);
                ui.slider.addEventListener('change', handlePointerUpOrChange);
                ui.slider.addEventListener('lostpointercapture', handleLostPointer);

                renderSliderMilestones();
                updateSliderTotalPages();
                updateSliderPosition();
            }

            function updateSliderInfoText(pageValue) {
                if (ui.currentPageDisplay && ui.totalPagesDisplay) {
                    let displayPageStart = pageValue;
                    const isFullscreenCurrent = ui.body.classList.contains(CSS_CLASS.FULLSCREEN_MODE);
                    const isContentRotatedCurrent = ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE);
                    const isCurrentlyEffectiveDoubleView = pdfState.isDoublePageView && !isFullscreenCurrent && !isContentRotatedCurrent;

                    if (isCurrentlyEffectiveDoubleView && displayPageStart > 1 && displayPageStart % 2 === 0) {
                        displayPageStart--;
                    }
                    let pageText;
                    if (isCurrentlyEffectiveDoubleView && displayPageStart + 1 <= pdfState.totalPages) {
                        pageText = `Page ${displayPageStart}-${displayPageStart + 1}`;
                    } else {
                        pageText = `Page ${pageValue}`;
                    }
                    ui.currentPageDisplay.textContent = pageText;
                }
            }

            function updateSliderTotalPages() {
                if (ui.slider && ui.totalPagesDisplay) {
                    const total = pdfState.totalPages > 0 ? pdfState.totalPages : 1;
                    ui.slider.max = total;
                    ui.totalPagesDisplay.textContent = total;
                    renderSliderMilestones();
                    updateSliderStyle(ui.slider, ui.slider.value);
                    updateMilestoneColors(parseInt(ui.slider.value, 10));
                }
            }

            function updateSliderPosition() {
                if (ui.slider && ui.currentPageDisplay && ui.totalPagesDisplay) {
                    const currentPage = pdfState.currentPage > 0 ? pdfState.currentPage : 1;
                    ui.slider.value = currentPage;
                    updateSliderInfoText(currentPage);
                    updateSliderStyle(ui.slider, currentPage);
                    updateMilestoneColors(currentPage);
                }
            }

            function updateSliderStyle(slider, value) {
                if (!slider) return;
                const min = parseInt(slider.min || 1);
                const max = parseInt(slider.max || 1);
                const range = max > min ? max - min : 1;
                const percentage = ((parseInt(value) - min) / range) * 100;
                slider.style.setProperty('--slider-percent', `${Math.max(0, Math.min(100, percentage))}%`);
            }

            // --- LO Milestone Functions ---
            function renderSliderMilestones() {
                if (!ui.loMilestonesContainer || !ui.sliderTrack) return;
                ui.loMilestonesContainer.innerHTML = '';

                if (appState.learningOutcomes.length === 0 || pdfState.totalPages <= 1) {
                    return;
                }

                const sliderWidth = ui.sliderTrack.offsetWidth;

                appState.learningOutcomes.forEach(lo => {
                    const pageNum = lo.page_number;
                    if (pageNum < 1 || pageNum > pdfState.totalPages) {
                        console.warn(`LO for page ${pageNum} is out of bounds (1-${pdfState.totalPages}). Skipping.`);
                        return;
                    }

                    const milestone = document.createElement('span');
                    milestone.className = 'lo-milestone';
                    milestone.textContent = lo.emoji;
                    milestone.dataset.loText = lo.learning_outcome;
                    milestone.dataset.loPage = pageNum;

                    const percentage = pdfState.totalPages > 1 ? ((pageNum - 1) / (pdfState.totalPages - 1)) * 100 : 0;
                    milestone.style.left = `${Math.max(0, Math.min(100, percentage))}%`;

                    milestone.addEventListener('mouseenter', handleMilestoneEnter);
                    milestone.addEventListener('mouseleave', handleMilestoneLeave);

                    ui.loMilestonesContainer.appendChild(milestone);
                });

                updateMilestoneColors(pdfState.currentPage);
            }

            function updateMilestoneColors(currentPage) {
                const milestones = ui.loMilestonesContainer ? .querySelectorAll('.lo-milestone');
                if (!milestones) return;

                milestones.forEach(milestone => {
                    const loPage = parseInt(milestone.dataset.loPage, 10);
                    milestone.classList.toggle(CSS_CLASS.LO_PASSED, currentPage > loPage);
                });
            }

            function handleMilestoneEnter(event) {
                const milestone = event.currentTarget;
                const loText = milestone.dataset.loText;
                const isPassed = milestone.classList.contains(CSS_CLASS.LO_PASSED);

                if (!isPassed) {
                    milestone.classList.add(CSS_CLASS.HOVER_COLORED);
                }

                if (ui.loTooltip) {
                    let displayText;
                    const fallbackText = 'Learning Outcome';
                    const checkmarkEmoji = '';

                    if (isPassed) {
                        displayText = `<strong>${loText || fallbackText}</strong> ${checkmarkEmoji}`;
                    } else {
                        displayText = `<em><span style="font-weight: 400;">${loText || fallbackText}</span></em>`;
                    }
                    ui.loTooltip.innerHTML = displayText;

                    const milestoneRect = milestone.getBoundingClientRect();
                    const tooltipRect = ui.loTooltip.getBoundingClientRect();
                    let left = milestoneRect.left + (milestoneRect.width / 2) - (tooltipRect.width / 2);
                    let top = milestoneRect.top - tooltipRect.height - LO_TOOLTIP_OFFSET_Y;

                    left = Math.max(5, Math.min(left, window.innerWidth - tooltipRect.width - 5));
                    top = Math.max(5, top);

                    ui.loTooltip.style.left = `${left}px`;
                    ui.loTooltip.style.top = `${top}px`;
                    toggleVisibility(ui.loTooltip, true);
                }

                if (ui.sliderInfo) {
                    clearTimeout(appState.sliderInfoFadeTimeout);
                    appState.sliderInfoFadeTimeout = null;
                    if (appState.originalSliderInfoText === null && !ui.sliderInfo.innerHTML.includes('<em') && !ui.sliderInfo.innerHTML.includes('<strong')) {
                        appState.originalSliderInfoText = ui.sliderInfo.innerHTML;
                    }
                    ui.sliderInfo.style.opacity = 0;
                    appState.sliderInfoFadeTimeout = setTimeout(() => {
                        let infoDisplayText;
                        const fallbackText = 'Learning Outcome';
                        const checkmarkEmoji = '';
                        if (isPassed) {
                            infoDisplayText = `<strong>${loText || fallbackText}</strong> ${checkmarkEmoji}`;
                        } else {
                            infoDisplayText = `<em><span style="font-weight: 400;">${loText || fallbackText}</span></em>`;
                        }
                        ui.sliderInfo.innerHTML = infoDisplayText;
                        ui.sliderInfo.style.opacity = '';
                        appState.sliderInfoFadeTimeout = null;
                    }, 125);
                }
            }

            function handleMilestoneLeave(event) {
                const milestone = event.currentTarget;
                milestone.classList.remove(CSS_CLASS.HOVER_COLORED);

                if (ui.loTooltip) {
                    toggleVisibility(ui.loTooltip, false);
                }

                if (ui.sliderInfo && appState.originalSliderInfoText !== null) {
                    clearTimeout(appState.sliderInfoFadeTimeout);
                    appState.sliderInfoFadeTimeout = null;
                    ui.sliderInfo.style.opacity = 0;
                    appState.sliderInfoFadeTimeout = setTimeout(() => {
                        ui.sliderInfo.innerHTML = appState.originalSliderInfoText;
                        appState.originalSliderInfoText = null;
                        ui.sliderInfo.style.opacity = '';
                        appState.sliderInfoFadeTimeout = null;
                    }, 200);
                } else if (ui.sliderInfo && !appState.sliderInfoFadeTimeout) {
                    ui.sliderInfo.style.opacity = '';
                }
            }

            // --- LO Achievement Popup Functions ---
            function showLoAchievementPopup(learningOutcomeObject, nextPageTarget) {
                if (!ui.loAchievementBackdrop || !ui.loAchievementPopup || !ui.loAchievementText || !ui.loContinueBtn) {
                    console.error("Cannot show LO achievement popup: Missing elements.");
                    jumpToPage(nextPageTarget);
                    return;
                }

                appState.loPopupTargetPage = nextPageTarget;

                const emoji = learningOutcomeObject ? .emoji || '';
                const loText = learningOutcomeObject ? .learning_outcome || "A key concept!";

                const formattedText = `
                    <span class="lo-popup-emoji">${emoji}</span>
                    <span class="lo-popup-text"><strong>${loText}</strong></span>
                `;
                ui.loAchievementText.innerHTML = formattedText;

                toggleVisibility(ui.loAchievementBackdrop, true);
                toggleVisibility(ui.loAchievementPopup, true);
                ui.loContinueBtn.focus();
            }

            function hideLoAchievementPopup() {
                if (ui.loAchievementPopup ? .classList.contains(CSS_CLASS.VISIBLE)) {
                    toggleVisibility(ui.loAchievementBackdrop, false);
                    toggleVisibility(ui.loAchievementPopup, false);
                    if (appState.loPopupTargetPage !== null) {
                        const targetPage = appState.loPopupTargetPage;
                        appState.loPopupTargetPage = null;
                        updateStatus(`LO Popup closed. Proceeding to page ${targetPage}.`);
                        jumpToPage(targetPage);
                    } else {
                        updateStatus("LO Popup closed (no target page stored).");
                    }
                } else {
                    appState.loPopupTargetPage = null;
                }
            }

            // --- Data Loading ---
            async function loadOverlayData(pdfUrl) {
                const overlayUrl = pdfUrl.replace(/\.pdf$/i, '.overlay.json');
                updateStatus(`Attempting to load overlay from: ${overlayUrl}`);
                pdfState.keywordDefinitions = {};
                pdfState.pageKeywords = {};
                pdfState.globalFirstInstanceLocation = {};
                try {
                    const response = await fetch(overlayUrl);
                    if (!response.ok) {
                        if (response.status !== 404) {
                            console.warn(`Overlay fetch failed: HTTP ${response.status} for ${overlayUrl}`);
                        } else {
                            updateStatus(`No overlay file found at ${overlayUrl}.`);
                        }
                        return false;
                    }
                    const data = await response.json();
                    if (!data || typeof data.keywords !== 'object' || typeof data.pages !== 'object') {
                        console.warn("Invalid overlay structure in JSON file.");
                        return false;
                    }
                    const processedKeywords = {};
                    for (const [key, value] of Object.entries(data.keywords)) {
                        if (key && Array.isArray(value) && value.length >= 2 && typeof value[1] === 'string' && value[1]) {
                            processedKeywords[key] = value;
                        } else {
                            console.warn(`Invalid keyword entry skipped: Key='${key}', Value=${JSON.stringify(value)}. Expected ["(pos)", "definition"]`);
                        }
                    }
                    pdfState.keywordDefinitions = processedKeywords;

                    const processedPages = {};
                    for (const [pageNum, pageWords] of Object.entries(data.pages)) {
                        if (pageNum && !isNaN(parseInt(pageNum)) && Array.isArray(pageWords) && pageWords.every(w => typeof w === 'string')) {
                            processedPages[pageNum.toString()] = pageWords;
                        } else {
                            console.warn(`Invalid page entry skipped: Page='${pageNum}'`);
                        }
                    }
                    pdfState.pageKeywords = processedPages;
                    updateStatus(`Overlay loaded: ${Object.keys(pdfState.keywordDefinitions).length} keywords, ${Object.keys(pdfState.pageKeywords).length} pages defined.`);
                    return true;
                } catch (error) {
                    console.warn(`Overlay fetch/parse error for ${overlayUrl}: ${error.message}.`);
                    pdfState.keywordDefinitions = {};
                    pdfState.pageKeywords = {};
                    pdfState.globalFirstInstanceLocation = {};
                    return false;
                }
            }

            async function loadIframeData(pdfUrl) {
                const iframeDataUrl = pdfUrl.replace(/\.pdf$/i, '-iframes.json');
                updateStatus(`Attempting to load iframe data from: ${iframeDataUrl}`);
                pdfState.iframeMappings = {};
                try {
                    const response = await fetch(iframeDataUrl);
                    if (!response.ok) {
                        if (response.status === 404) {
                            updateStatus(`Iframe data file not found at ${iframeDataUrl}. No iframe popups will be shown.`);
                        } else {
                            console.warn(`Iframe data fetch failed: HTTP error ${response.status} for ${iframeDataUrl}`);
                        }
                        return false;
                    }
                    const data = await response.json();
                    if (!data || typeof data !== 'object' || Array.isArray(data)) {
                        console.warn("Invalid iframe data structure in JSON file. Expected an object { pageNum: urlString }.");
                        return false;
                    }
                    const validMappings = {};
                    let count = 0;
                    for (const [key, value] of Object.entries(data)) {
                        const pageNum = parseInt(key, 10);
                        if (!isNaN(pageNum) && pageNum > 0 && typeof value === 'string' && value.trim() !== '') {
                            validMappings[key.toString()] = value.trim();
                            count++;
                        } else {
                            console.warn(`Invalid iframe mapping skipped: Key='${key}', Value='${value}'`);
                        }
                    }
                    pdfState.iframeMappings = validMappings;
                    updateStatus(`Iframe data loaded successfully: ${count} mappings found.`);
                    return true;
                } catch (error) {
                    console.warn(`Iframe data fetch/parse error for ${iframeDataUrl}: ${error.message}. No iframe popups will be shown.`);
                    pdfState.iframeMappings = {};
                    return false;
                }
            }

            async function loadLearningOutcomes(pdfUrl) {
                let loFileName = 'chapter-2.LOs.json';
                try {
                    const pathParts = pdfUrl.split('/');
                    const pdfFileName = pathParts.pop() || '';
                    const chapterMatch = pdfFileName.match(/chapter-(\d+)/i);
                    if (chapterMatch && chapterMatch[0]) {
                        loFileName = `${chapterMatch[0]}.LOs.json`;
                    } else {
                        console.warn(`Could not derive chapter name from PDF URL '${pdfUrl}'. Using default LO file name: ${loFileName}`);
                    }
                } catch (e) {
                    console.warn("Error deriving LO file name:", e);
                }

                const pdfDir = pdfUrl.substring(0, pdfUrl.lastIndexOf('/') + 1);
                const loUrl = pdfDir + loFileName;

                updateStatus(`Attempting to load Learning Outcomes from: ${loUrl}`);
                appState.learningOutcomes = [];

                try {
                    const response = await fetch(loUrl);
                    if (!response.ok) {
                        if (response.status === 404) {
                            updateStatus(`LO file not found at ${loUrl}. No LO milestones will be shown.`);
                        } else {
                            console.warn(`LO data fetch failed: HTTP error ${response.status} for ${loUrl}`);
                        }
                        return false;
                    }
                    const data = await response.json();
                    if (!Array.isArray(data)) {
                        console.warn("Invalid LO data structure in JSON file. Expected an array.");
                        return false;
                    }

                    const validLOs = [];
                    let count = 0;
                    data.forEach(item => {
                        if (item && typeof item.emoji === 'string' && typeof item.learning_outcome === 'string' && typeof item.page_number === 'number' && Number.isInteger(item.page_number) && item.page_number > 0) {
                            validLOs.push({
                                emoji: item.emoji,
                                learning_outcome: item.learning_outcome,
                                page_number: item.page_number
                            });
                            count++;
                        } else {
                            console.warn("Invalid LO item skipped:", item);
                        }
                    });

                    validLOs.sort((a, b) => a.page_number - b.page_number);
                    appState.learningOutcomes = validLOs;
                    updateStatus(`LO data loaded successfully: ${count} valid outcomes found.`);
                    return true;
                } catch (error) {
                    console.warn(`LO data fetch/parse error for ${loUrl}: ${error.message}. No LO milestones will be shown.`);
                    appState.learningOutcomes = [];
                    return false;
                }
            }

            async function findFirstKeywordInstances() {
                updateStatus("Starting pre-scan for first keyword instances...");
                pdfState.globalFirstInstanceLocation = {};
                const lowerCaseKeywordsToFind = new Set(Object.keys(pdfState.keywordDefinitions).map(k => k.toLowerCase()));

                if (lowerCaseKeywordsToFind.size === 0 || !pdfState.pdfDocument) {
                    updateStatus("Pre-scan skipped: No keywords defined or PDF not loaded.");
                    return;
                }

                const totalPages = pdfState.pdfDocument.numPages;
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    if (lowerCaseKeywordsToFind.size === 0) {
                        updateStatus("Pre-scan finished early: All first instances found.");
                        break;
                    }
                    try {
                        const page = await pdfState.pdfDocument.getPage(pageNum);
                        const textContent = await page.getTextContent({
                            normalizeWhitespace: true
                        });
                        const items = textContent.items;

                        for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                            const item = items[itemIndex];
                            const itemText = item.str;
                            if (!itemText || itemText.trim().length === 0) continue;

                            const currentKeywordsToCheck = Array.from(lowerCaseKeywordsToFind);
                            for (const keywordLower of currentKeywordsToCheck) {
                                let originalKeywordForRegex = keywordLower;
                                const originalDefKey = Object.keys(pdfState.keywordDefinitions).find(k => k.toLowerCase() === keywordLower);
                                if (originalDefKey) originalKeywordForRegex = originalDefKey;

                                const escapedKeyword = originalKeywordForRegex.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                                const regex = new RegExp(`\\b(${escapedKeyword})\\b`, 'gi');
                                let match;

                                while ((match = regex.exec(itemText)) !== null) {
                                    if (pdfState.globalFirstInstanceLocation[keywordLower]) continue;

                                    if (match[1].toLowerCase() === keywordLower) {
                                        const matchIndex = match.index;
                                        pdfState.globalFirstInstanceLocation[keywordLower] = {
                                            pageNum,
                                            itemIndex,
                                            matchIndex
                                        };
                                        lowerCaseKeywordsToFind.delete(keywordLower);
                                        if (lowerCaseKeywordsToFind.size === 0) break;
                                    }
                                }
                                if (lowerCaseKeywordsToFind.size === 0) break;
                            }
                        }
                        if (lowerCaseKeywordsToFind.size === 0) break;
                    } catch (error) {
                        console.warn(`Error processing page ${pageNum} during keyword pre-scan:`, error);
                    }
                }
                updateStatus(`Pre-scan complete. Found first instances for ${Object.keys(pdfState.globalFirstInstanceLocation).length} keywords.`);
            }

            // --- PDF Loading ---
            async function loadPdf(pdfUrl) {
                updateStatus(`loadPdf started for: ${pdfUrl}`);
                pdfState.pageCache.clear();
                pdfState.currentViewports = {};
                pdfState.keywordDefinitions = {};
                pdfState.pageKeywords = {};
                pdfState.globalFirstInstanceLocation = {};
                pdfState.iframeMappings = {};
                pdfState.outline = [];
                appState.learningOutcomes = [];
                if (pdfState.pdfDocument) {
                    try {
                        pdfState.pdfDocument.destroy();
                    } catch (e) {
                        console.warn("Error destroying previous PDF doc:", e);
                    }
                    pdfState.pdfDocument = null;
                }
                pdfState.totalPages = 0;
                pdfState.currentPage = 1;
                pdfState.title = "No Document";
                pdfState.isDoublePageView = true;

                updateStatus("Resetting time lock state for new PDF.");
                isTimelockGloballyEnabled = true;
                updateTimelockButtonVisuals();
                isTimeLockActive = false;
                completedTimeLockPages.clear();
                currentPageLockStartTime = 0;
                requiredReadingTime = 0;

                pdfState.currentNotesPdfDoc = null;
                pdfState.currentNotesPageNum = 1;
                pdfState.totalNotesPages = 0;
                if (pdfState.notesPdfLoadingTask ? .destroy) {
                    pdfState.notesPdfLoadingTask.destroy();
                    pdfState.notesPdfLoadingTask = null;
                }
                userState.readingProgress.furthestPage = 1;
                resetPopupStates();
                document.title = "Pyr Course Viewer";

                if (ui.goToChapterBtn) {
                    updateStatus("Setting button to 'Loading Chapter...' state.");
                    ui.goToChapterBtn.textContent = 'Loading Chapter...';
                    ui.goToChapterBtn.classList.add(CSS_CLASS.LOADING_CHAPTER);
                    ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE);
                }

                let filename = "Document";
                try {
                    filename = decodeURIComponent(pdfUrl.split('/').pop() || filename).replace(/\.pdf$/i, '');
                } catch (e) {
                    console.warn("Error parsing filename from URL");
                }
                pdfState.title = filename;

                try {
                    updateStatus("Starting background PDF document loading...");
                    console.log("Internal Status: Loading PDF document...");
                    const loadingTask = pdfjsLib.getDocument(pdfUrl);

                    const overlayPromise = loadOverlayData(pdfUrl);
                    const iframeDataPromise = loadIframeData(pdfUrl);
                    const loPromise = loadLearningOutcomes(pdfUrl);

                    pdfState.pdfDocument = await loadingTask.promise;
                    pdfState.totalPages = pdfState.pdfDocument.numPages;
                    pdfState.currentPage = 1;
                    updateStatus(`PDF loaded: ${pdfState.title}, Pages: ${pdfState.totalPages}`);
                    document.title = `${pdfState.title} - Pyr Course Viewer`;
                    updateSliderTotalPages();

                    const [overlayLoaded, iframeDataLoaded, loLoaded] = await Promise.all([overlayPromise, iframeDataPromise, loPromise]);
                    updateStatus(`Overlay data loaded: ${overlayLoaded}`);
                    updateStatus(`Iframe data loaded: ${iframeDataLoaded}`);
                    updateStatus(`LO data loaded: ${loLoaded}`);

                    renderSliderMilestones();

                    if (overlayLoaded && pdfState.pdfDocument) {
                        console.log("Internal Status: Scanning for keywords...");
                        await findFirstKeywordInstances();
                    }

                    if (window.innerWidth < 1000) {
                        updateStatus("Initial setup: Small screen detected, setting intended view to Single Page (Fullscreen).");
                        pdfState.isDoublePageView = false;
                        ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE);
                        ui.body.classList.add(CSS_CLASS.FULLSCREEN_MODE);
                    } else {
                        updateStatus("Initial setup: Large screen detected, setting intended view to Double Page.");
                        pdfState.isDoublePageView = true;
                        ui.body.classList.remove(CSS_CLASS.CONTENT_ROTATED_MODE, CSS_CLASS.FULLSCREEN_MODE);
                        pdfState.currentPage = 1;
                    }

                    updateSliderPosition();

                    await new Promise(resolve => requestAnimationFrame(resolve));
                    await updateDisplay();

                    appState.isReaderReady = true;
                    updateStatus("Reader is ready!");
                    if (ui.gameIframe ? .contentWindow) {
                        try {
                            ui.gameIframe.contentWindow.postMessage({
                                type: 'chapterReady'
                            }, '*');
                            updateStatus("Sent 'chapterReady' message to game iframe.");
                        } catch (e) {
                            console.error("Error posting 'chapterReady' message to iframe:", e);
                        }
                    } else {
                        console.warn("Cannot send 'chapterReady' message: Game iframe or contentWindow not accessible.");
                    }

                    setTimeout(() => {
                        if (ui.goToChapterBtn && ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) {
                            updateStatus("Reader ready, updating button to 'Go to Chapter' state and animating.");
                            ui.goToChapterBtn.textContent = 'Go to Chapter';
                            ui.goToChapterBtn.classList.remove(CSS_CLASS.LOADING_CHAPTER);
                            ui.goToChapterBtn.classList.add(CSS_CLASS.VISIBLE);
                        }
                    }, LOADING_BAR_ANIMATION_BUFFER);

                    if (ui.gameIframe ? .contentWindow) {
                        try {
                            ui.gameIframe.contentWindow.postMessage({
                                type: 'disableRestart'
                            }, '*');
                            updateStatus("Sent disableRestart message to game iframe.");
                        } catch (e) {
                            console.error("Error posting disableRestart message to iframe:", e);
                        }
                    } else {
                        console.warn("Cannot send disableRestart message: iframe or contentWindow not accessible.");
                    }

                } catch (error) {
                    console.error("FATAL: Error loading PDF document:", error);
                    appState.isReaderReady = false;
                    pdfState.pdfDocument = null;
                    pdfState.totalPages = 0;
                    pdfState.currentPage = 1;
                    pdfState.title = "Error Loading";
                    pdfState.keywordDefinitions = {};
                    pdfState.pageKeywords = {};
                    pdfState.globalFirstInstanceLocation = {};
                    pdfState.iframeMappings = {};
                    appState.learningOutcomes = [];
                    completedTimeLockPages.clear();
                    isTimeLockActive = false;
                    requiredReadingTime = 0;
                    currentPageLockStartTime = 0;
                    isTimelockGloballyEnabled = true;
                    updateTimelockButtonVisuals();
                    pdfState.currentNotesPdfDoc = null;
                    pdfState.currentNotesPageNum = 1;
                    pdfState.totalNotesPages = 0;
                    document.title = "Pyr Course Viewer - Error";
                    updateSliderTotalPages();
                    updateSliderPosition();
                    if (ui.bookSpread) {
                        ui.bookSpread.innerHTML = `<div style="color: red; background: white; padding: 30px; text-align: center; width: 100%; border: 1px solid red; border-radius: 5px;">Failed to load document: ${error.message}</div>`;
                    }
                    updateStatus("loadPdf failed. Reader will not be available.");
                    ui.body.classList.add(CSS_CLASS.LOADING_GAME_ACTIVE);
                    if (ui.goToChapterBtn) {
                        ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE, CSS_CLASS.LOADING_CHAPTER);
                    }
                    if (ui.gameContainer) ui.gameContainer.style.display = 'none';
                    if (ui.iframeLoadingText) ui.iframeLoadingText.textContent = `Error loading PDF: ${error.message}`;
                    if (ui.iframeLoadingText) ui.iframeLoadingText.style.display = 'block';

                } finally {
                    updateStatus("loadPdf finished (background process).");
                }
            }

            // --- Popup Handling ---
            function showDefinitionPopup(clickedHighlightElement) {
                const word = clickedHighlightElement ? .dataset ? .keyword;
                const pos = clickedHighlightElement ? .dataset ? .pos || '';
                const definition = clickedHighlightElement ? .dataset ? .definition;
                const rect = clickedHighlightElement ? .getBoundingClientRect();

                if (!ui.definitionPopup || !ui.popupWord || !ui.popupDefinition || !word || !definition || !rect) {
                    console.error("Cannot show definition popup: Missing element, data, or rect.");
                    return;
                }
                if (ui.body.classList.contains(CSS_CLASS.CONTENT_ROTATED_MODE)) {
                    updateStatus("Definition popup suppressed in rotated mode.");
                    return;
                }

                hideIframePopupIfNeeded();
                hideNotesPopupIfNeeded();

                ui.popupWord.innerHTML = `
                    <span class="keyword-term">${word}</span>
                    <span class="part-of-speech">${pos}</span>
                `;
                ui.popupDefinition.innerHTML = definition;
                ui.popupDefinition.scrollTop = 0;

                const estPopupWidth = Math.min(ui.definitionPopup.offsetWidth || 320, 320);
                const estPopupHeight = Math.min(ui.definitionPopup.offsetHeight || 200, 200);
                const margin = 10;
                const verticalOffset = 8;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let targetLeft = rect.left + (rect.width / 2) - (estPopupWidth / 2);
                targetLeft = Math.max(margin, targetLeft);
                targetLeft = Math.min(targetLeft, viewportWidth - estPopupWidth - margin);
                targetLeft = Math.max(margin, targetLeft);

                let targetTop = rect.top - estPopupHeight - verticalOffset;
                let transformOrigin = 'bottom center';

                if (targetTop < margin || rect.top < viewportHeight * 0.4) {
                    targetTop = rect.bottom + verticalOffset;
                    transformOrigin = 'top center';
                    if (targetTop + estPopupHeight > viewportHeight - margin) {
                        targetTop = viewportHeight - estPopupHeight - margin;
                        targetTop = Math.max(margin, targetTop);
                    }
                }

                ui.definitionPopup.style.left = `${Math.round(targetLeft)}px`;
                ui.definitionPopup.style.top = `${Math.round(targetTop)}px`;
                ui.definitionPopup.style.transformOrigin = transformOrigin;

                toggleVisibility(ui.definitionPopup, true);
            }

            function hideDefinitionPopup() {
                toggleVisibility(ui.definitionPopup, false);
            }

            function showIframePopup(url) {
                if (!ui.iframePopupBackdrop || !ui.iframePopupModal || !ui.popupIframe || !ui.closeIframePopupBtn || !url) {
                    console.error("Cannot show iframe popup: Missing element or URL.");
                    return;
                }
                hideDefinitionPopup();
                hideNotesPopupIfNeeded();

                if (ui.iframePopupModal.classList.contains(CSS_CLASS.VISIBLE) && ui.popupIframe.src === url) {
                    updateStatus("Iframe popup already visible with the same URL.");
                    return;
                }

                updateStatus(`Showing iframe popup for URL: ${url}`);
                ui.popupIframe.src = url;
                toggleVisibility(ui.iframePopupBackdrop, true);
                toggleVisibility(ui.iframePopupModal, true);
                if (isTimelockGloballyEnabled) {
                    requiredReadingTime = calculateVideoDuration(url);
                    currentPageLockStartTime = Date.now();
                    isTimeLockActive = true;
                    currentLockType = 'iframe';
                    updateStatus(`Iframe timelock ACTIVATED. Type: ${currentLockType}, Duration: ${requiredReadingTime}s`);
                } else {
                    isTimeLockActive = false;
                    currentLockType = null;
                    updateStatus(`Iframe timelock NOT ACTIVATED (Globally disabled).`);
                }
            }

            function hideIframePopup() {
                if (isTimelockGloballyEnabled && isTimeLockActive && currentLockType === 'iframe') {
                    const elapsedSeconds = (Date.now() - currentPageLockStartTime) / 1000;
                    if (elapsedSeconds < requiredReadingTime) {
                        updateStatus(`Iframe timelock ACTIVE: ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Preventing close.`);
                        showReadingTimeAlert('<em>Please watch the video first!</em>');
                        return;
                    } else {
                        updateStatus(`Iframe timelock COMPLETED (${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s). Allowing close.`);
                        isTimeLockActive = false;
                        currentLockType = null;
                        requiredReadingTime = 0;
                        currentPageLockStartTime = 0;
                    }
                } else if (currentLockType === 'iframe') {
                    updateStatus("Iframe timelock was inactive or globally disabled. Resetting state.");
                    isTimeLockActive = false;
                    currentLockType = null;
                    requiredReadingTime = 0;
                    currentPageLockStartTime = 0;
                }
                if (!ui.iframePopupBackdrop || !ui.iframePopupModal || !ui.popupIframe) return;
                if (ui.iframePopupModal.classList.contains(CSS_CLASS.VISIBLE)) {
                    updateStatus("Hiding iframe popup.");
                    toggleVisibility(ui.iframePopupBackdrop, false);
                    toggleVisibility(ui.iframePopupModal, false);
                    if (currentLockType === 'iframe') {
                        isTimeLockActive = false;
                        currentLockType = null;
                        requiredReadingTime = 0;
                        currentPageLockStartTime = 0;
                    }
                    ui.popupIframe.src = 'about:blank';
                }
            }

            function hideIframePopupIfNeeded() {
                if (ui.iframePopupModal ? .classList.contains(CSS_CLASS.VISIBLE)) {
                    hideIframePopup();
                }
            }

            // --- Notes Data Processing ---
            function processNotesData(rawData) {
                const mapping = {};
                if (!Array.isArray(rawData)) {
                    console.error("Invalid raw notes data: Expected an array.");
                    return mapping;
                }
                rawData.forEach((entry, index) => {
                    if (typeof entry === 'object' && entry !== null &&
                        typeof entry.chapterPage === 'number' && Number.isInteger(entry.chapterPage) && entry.chapterPage > 0 &&
                        typeof entry.path === 'string' && entry.path.trim() !== '' &&
                        typeof entry.notesPage === 'number' && Number.isInteger(entry.notesPage) && entry.notesPage > 0) {
                        const chapterPageStr = entry.chapterPage.toString();
                        if (mapping[chapterPageStr]) {
                            console.warn(`Duplicate chapterPage ${entry.chapterPage} found in notes data at index ${index}. Overwriting previous entry.`);
                        }
                        mapping[chapterPageStr] = {
                            pdf: entry.path,
                            page: entry.notesPage
                        };
                    } else {
                        console.warn(`Invalid notes data entry at index ${index}. Skipping:`, entry);
                    }
                });
                updateStatus(`Notes mapping processed: ${Object.keys(mapping).length} valid entries found.`);
                return mapping;
            }

            // --- Notes Popup Handling ---
            async function showNotesPopup(pdfUrl, pageNum = 1) {
                if (!ui.notesPopupBackdrop || !ui.notesPopupContainer || !ui.notesPdfCanvas || !ui.notesLocalLoader) {
                    console.error("Cannot show notes popup: Missing elements.");
                    return;
                }
                hideDefinitionPopup();
                hideIframePopupIfNeeded();
                updateStatus(`Showing notes popup for PDF: ${pdfUrl}, page: ${pageNum}`);

                toggleVisibility(ui.notesPopupBackdrop, true);
                toggleVisibility(ui.notesPopupContainer, true);

                ui.notesLocalLoader.classList.add(CSS_CLASS.VISIBLE);

                const ctx = ui.notesPdfCanvas.getContext('2d');
                ctx.clearRect(0, 0, ui.notesPdfCanvas.width, ui.notesPdfCanvas.height);
                ui.notesPdfCanvas.style.opacity = 0;
                ui.notesPrevBtn.disabled = true;
                ui.notesNextBtn.disabled = true;
                ui.notesInstruction ? .classList.remove(CSS_CLASS.WIGGLE_NOW);

                if (pdfState.notesPdfLoadingTask ? .destroy) {
                    pdfState.notesPdfLoadingTask.destroy();
                }
                if (pdfState.currentNotesPdfDoc ? .destroy) {
                    try {
                        pdfState.currentNotesPdfDoc.destroy();
                    } catch (e) {
                        console.warn("Error destroying previous notes PDF", e);
                    }
                }
                pdfState.currentNotesPdfDoc = null;
                pdfState.notesPdfLoadingTask = null;

                try {
                    pdfState.notesPdfLoadingTask = pdfjsLib.getDocument(pdfUrl);
                    pdfState.currentNotesPdfDoc = await pdfState.notesPdfLoadingTask.promise;
                    pdfState.totalNotesPages = pdfState.currentNotesPdfDoc.numPages;
                    pdfState.currentNotesPageNum = Math.max(1, Math.min(pageNum, pdfState.totalNotesPages));

                    updateStatus(`Notes PDF loaded: ${pdfState.totalNotesPages} pages. Rendering page ${pdfState.currentNotesPageNum}.`);
                    await renderNotesPage(pdfState.currentNotesPageNum);

                    if (isTimelockGloballyEnabled) {
                        requiredReadingTime = 45;
                        currentPageLockStartTime = Date.now();
                        isTimeLockActive = true;
                        currentLockType = 'notes';
                        updateStatus(`Notes timelock ACTIVATED. Type: ${currentLockType}, Duration: ${requiredReadingTime}s`);
                    } else {
                        isTimeLockActive = false;
                        currentLockType = null;
                        updateStatus(`Notes timelock NOT ACTIVATED (Globally disabled).`);
                    }

                    ui.notesLocalLoader.classList.remove(CSS_CLASS.VISIBLE);

                } catch (error) {
                    console.error(`Error loading or rendering notes PDF ${pdfUrl}:`, error);
                    ctx.fillStyle = '#8B0000';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Error loading notes.', ui.notesPdfCanvas.width / 2, ui.notesPdfCanvas.height / 2);
                    ui.notesPdfCanvas.style.opacity = 1;

                    setTimeout(hideNotesPopup, 1500);

                } finally {
                    ui.notesLocalLoader.classList.remove(CSS_CLASS.VISIBLE);
                    pdfState.notesPdfLoadingTask = null;
                }
            }

            function hideNotesPopup() {
                if (isTimelockGloballyEnabled && isTimeLockActive && currentLockType === 'notes') {
                    const elapsedSeconds = (Date.now() - currentPageLockStartTime) / 1000;
                    if (elapsedSeconds < requiredReadingTime) {
                        updateStatus(`Notes timelock ACTIVE: ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Preventing close.`);
                        showReadingTimeAlert();

                        if (ui.notesInstruction) {
                            ui.notesInstruction.classList.remove(CSS_CLASS.WIGGLE_NOW);
                            void ui.notesInstruction.offsetWidth;

                            ui.notesInstruction.classList.add(CSS_CLASS.WIGGLE_NOW);
                            updateStatus("Triggering notes instruction wiggle (blocked close).");
                        }
                        return;
                    } else {
                        updateStatus(`Notes timelock COMPLETED (${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s). Allowing close.`);
                        isTimeLockActive = false;
                        currentLockType = null;
                        requiredReadingTime = 0;
                        currentPageLockStartTime = 0;
                    }
                } else if (currentLockType === 'notes') {
                    updateStatus("Notes timelock was inactive or globally disabled. Resetting state.");
                    isTimeLockActive = false;
                    currentLockType = null;
                    requiredReadingTime = 0;
                    currentPageLockStartTime = 0;
                }
                if (!ui.notesPopupBackdrop || !ui.notesPopupContainer || !ui.notesPdfCanvas || !ui.notesLocalLoader) return;

                if (ui.notesPopupContainer.classList.contains(CSS_CLASS.VISIBLE)) {
                    updateStatus("Hiding notes popup.");
                    clearTimeout(notesNavFadeTimeout);
                    notesNavFadeTimeout = null;
                    ui.notesPrevBtn ? .classList.remove('notes-nav-faded');
                    ui.notesNextBtn ? .classList.remove('notes-nav-faded');

                    toggleVisibility(ui.notesPopupBackdrop, false);
                    toggleVisibility(ui.notesPopupContainer, false);

                    ui.notesLocalLoader.classList.remove(CSS_CLASS.VISIBLE);

                    setTimeout(() => {
                        const ctx = ui.notesPdfCanvas.getContext('2d');
                        if (ctx) {
                            ctx.clearRect(0, 0, ui.notesPdfCanvas.width, ui.notesPdfCanvas.height);
                        }
                        ui.notesPdfCanvas.style.opacity = 0;
                        ui.notesInstruction ? .classList.remove(CSS_CLASS.WIGGLE_NOW);
                    }, 300);

                    if (currentLockType === 'notes') {
                        isTimeLockActive = false;
                        currentLockType = null;
                        requiredReadingTime = 0;
                        currentPageLockStartTime = 0;
                    }
                    if (pdfState.notesPdfLoadingTask ? .destroy) {
                        pdfState.notesPdfLoadingTask.destroy();
                        pdfState.notesPdfLoadingTask = null;
                    }
                    if (pdfState.currentNotesPdfDoc ? .destroy) {
                        try {
                            pdfState.currentNotesPdfDoc.destroy();
                            updateStatus("Destroyed notes PDF document object.");
                        } catch (e) {
                            console.warn("Error destroying notes PDF doc:", e);
                        }
                    }
                    pdfState.currentNotesPdfDoc = null;
                    pdfState.currentNotesPageNum = 1;
                    pdfState.totalNotesPages = 0;
                }
            }

            function hideNotesPopupIfNeeded() {
                if (ui.notesPopupContainer ? .classList.contains(CSS_CLASS.VISIBLE)) {
                    hideNotesPopup();
                }
            }

            async function renderNotesPage(pageNum) {
                if (!pdfState.currentNotesPdfDoc || pageNum < 1 || pageNum > pdfState.totalNotesPages || !ui.notesPdfCanvas || !ui.notesPdfCanvasContainer || !ui.notesLocalLoader) {
                    console.warn("Cannot render notes page: Invalid state or elements.");
                    ui.notesLocalLoader ? .classList.remove(CSS_CLASS.VISIBLE);
                    return;
                }
                updateStatus(`Rendering notes page ${pageNum} of ${pdfState.totalNotesPages}`);
                const canvas = ui.notesPdfCanvas;
                const ctx = canvas.getContext('2d');

                canvas.style.opacity = 0;
                ui.notesInstruction ? .classList.remove(CSS_CLASS.WIGGLE_NOW);
                ui.notesLocalLoader ? .classList.add(CSS_CLASS.VISIBLE);

                try {
                    const page = await pdfState.currentNotesPdfDoc.getPage(pageNum);
                    const containerStyle = getComputedStyle(ui.notesPdfCanvasContainer);
                    const availableWidth = parseFloat(containerStyle.width);
                    const availableHeight = parseFloat(containerStyle.height);
                    if (isNaN(availableWidth) || isNaN(availableHeight) || availableWidth <= 0 || availableHeight <= 0) {
                        console.warn("Notes canvas container has invalid dimensions.");
                        throw new Error("Invalid container dimensions");
                    }
                    const defaultViewport = page.getViewport({
                        scale: 1
                    });
                    const scale = Math.min(availableWidth / defaultViewport.width, availableHeight / defaultViewport.height);
                    const viewport = page.getViewport({
                        scale: scale
                    });
                    const outputScale = window.devicePixelRatio || 1;

                    canvas.width = Math.floor(viewport.width * outputScale);
                    canvas.height = Math.floor(viewport.height * outputScale);
                    canvas.style.width = `${Math.floor(viewport.width)}px`;
                    canvas.style.height = `${Math.floor(viewport.height)}px`;

                    const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
                    const renderContext = {
                        canvasContext: ctx,
                        transform: transform,
                        viewport: viewport
                    };

                    await page.render(renderContext).promise;
                    pdfState.currentNotesPageNum = pageNum;

                    canvas.style.opacity = 1;

                    ui.notesPrevBtn.disabled = (pdfState.currentNotesPageNum <= 1);
                    ui.notesNextBtn.disabled = (pdfState.currentNotesPageNum >= pdfState.totalNotesPages);
                    updateStatus(`Notes page ${pageNum} rendered successfully.`);

                    showNotesNavAndResetTimer();

                    if (ui.notesInstruction) {
                        updateStatus("Triggering notes instruction wiggle.");
                        setTimeout(() => {
                            ui.notesInstruction.classList.add(CSS_CLASS.WIGGLE_NOW);
                        }, 50);
                    }

                } catch (error) {
                    console.error(`Error rendering notes page ${pageNum}:`, error);
                    ctx.fillStyle = '#8B0000';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Error rendering page ${pageNum}.`, canvas.width / 2, canvas.height / 2);
                    canvas.style.opacity = 1;
                    ui.notesPrevBtn.disabled = true;
                    ui.notesNextBtn.disabled = true;
                    throw error;
                } finally {
                    ui.notesLocalLoader ? .classList.remove(CSS_CLASS.VISIBLE);
                }
            }

            function notesPrevPage() {
                if (pdfState.currentNotesPageNum > 1) {
                    renderNotesPage(pdfState.currentNotesPageNum - 1);
                }
            }

            function notesNextPage() {
                if (pdfState.currentNotesPageNum < pdfState.totalNotesPages) {
                    renderNotesPage(pdfState.currentNotesPageNum + 1);
                }
            }

            // --- Game Transition Logic ---
            function transitionToChapter() {
                updateStatus("Transitioning to chapter...");
                clearTimeout(appState.gameOverTimeoutId);

                if (ui.goToChapterBtn) {
                    ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE);
                    ui.goToChapterBtn.classList.remove(CSS_CLASS.LOADING_CHAPTER);
                    updateStatus("Removed button visibility classes to initiate fade-out.");
                }

                ui.body.classList.remove(CSS_CLASS.LOADING_GAME_ACTIVE);
                window.focus();

                if (ui.gameIframe) {
                    ui.gameIframe.classList.remove('iframe-inactive');
                    updateStatus("Re-enabled game iframe input class (though hidden).");
                }

                if (ui.rightToolbar && ui.leftToolbar) {
                    updateStatus("Temporarily showing toolbars for 7 seconds.");
                    ui.rightToolbar.classList.add('visible');
                    ui.leftToolbar.classList.add('visible');

                    clearTimeout(toolbarTimer);
                    clearTimeout(leftToolbarTimer);

                    setTimeout(() => {
                        if (!toolbarHover && ui.rightToolbar ? .classList.contains('visible')) {
                            ui.rightToolbar.classList.remove('visible');
                            updateStatus("Hiding right toolbar after 7s timeout (not hovered).");
                        } else if (ui.rightToolbar ? .classList.contains('visible')) {
                            updateStatus("Keeping right toolbar visible after 7s (hovered).");
                        }

                        if (!leftToolbarHover && ui.leftToolbar ? .classList.contains('visible')) {
                            ui.leftToolbar.classList.remove('visible');
                            updateStatus("Hiding left toolbar after 7s timeout (not hovered).");
                        } else if (ui.leftToolbar ? .classList.contains('visible')) {
                            updateStatus("Keeping left toolbar visible after 7s (hovered).");
                        }
                    }, 7000);
                }

                setTimeout(() => {
                    applyCurrentViewModeStyles();
                    window.dispatchEvent(new Event('resize'));
                    updateStatus("Reader should be visible and scaled.");
                }, 50);
            }

            function handleGameOverFromGame(score) {
                updateStatus(`Game over message received. Score: ${score}`);

                if (ui.goToChapterBtn && !ui.goToChapterBtn.classList.contains(CSS_CLASS.LOADING_CHAPTER)) {
                    if (appState.isReaderReady) {
                        ui.goToChapterBtn.textContent = 'Go to Chapter';
                        ui.goToChapterBtn.classList.remove(CSS_CLASS.LOADING_CHAPTER);
                        ui.goToChapterBtn.classList.add(CSS_CLASS.VISIBLE);
                        updateStatus("Made 'Go to Chapter' button visible (Game Over - Reader Ready).");
                    } else {
                        ui.goToChapterBtn.textContent = 'Loading Chapter...';
                        ui.goToChapterBtn.classList.add(CSS_CLASS.LOADING_CHAPTER);
                        updateStatus("Made 'Loading Chapter...' button visible (Game Over - Reader Not Ready).");
                    }

                    if (ui.gameIframe) {
                        ui.gameIframe.classList.add('iframe-inactive');
                        ui.gameIframe.blur();
                        if (ui.gameIframe.contentWindow) {
                            try {
                                ui.gameIframe.contentWindow.postMessage({
                                    type: 'blurYourself'
                                }, '*');
                                updateStatus("Sent 'blurYourself' message to game iframe.");
                            } catch (e) {
                                console.warn("Could not post 'blurYourself' message:", e)
                            }
                        }
                        updateStatus("Disabled game iframe input (Game Over).");
                    }

                } else if (ui.goToChapterBtn) {
                    updateStatus("'Go to Chapter' button already visible in loading state.");
                } else {
                    console.error("'Go to Chapter' button not found!");
                }

                if (ui.gameIframe) {
                    ui.gameIframe.classList.add('iframe-inactive');
                    ui.gameIframe.blur();
                    if (ui.gameIframe.contentWindow) {
                        try {
                            ui.gameIframe.contentWindow.postMessage({
                                type: 'blurYourself'
                            }, '*');
                            updateStatus("Sent 'blurYourself' message to game iframe.");
                        } catch (e) {
                            console.warn("Could not post 'blurYourself' message:", e)
                        }
                    }
                    updateStatus("Disabled game iframe input (Game Over).");
                }

                if (appState.isReaderReady) {
                    updateStatus(`Reader is ready, starting automatic transition timer (${GAME_OVER_TRANSITION_DELAY}ms) after game over.`);
                    if (ui.gameIframe ? .contentWindow) {
                        try {
                            ui.gameIframe.contentWindow.postMessage({
                                type: 'disableRestart'
                            }, '*');
                        } catch (e) {
                            console.error("Error posting safeguard disableRestart message:", e);
                        }
                    }
                    clearTimeout(appState.gameOverTimeoutId);
                    appState.gameOverTimeoutId = setTimeout(() => {
                        updateStatus("Game over timeout finished, transitioning now.");
                        transitionToChapter();
                    }, GAME_OVER_TRANSITION_DELAY);
                } else {
                    updateStatus("Game over occurred, but reader is not ready yet. Button made visible for manual transition.");
                }
            }

            // --- Timelock UI and Toggle ---
            function updateTimelockButtonVisuals() {
                if (!ui.timelockToggleButton) return;
                if (isTimelockGloballyEnabled) {
                    ui.timelockToggleButton.classList.remove(CSS_CLASS.TIMELOCK_OFF);
                    ui.timelockToggleButton.classList.add(CSS_CLASS.TIMELOCK_ON);
                    ui.timelockToggleButton.title = "Toggle Reading Time Lock (On)";
                } else {
                    ui.timelockToggleButton.classList.remove(CSS_CLASS.TIMELOCK_ON);
                    ui.timelockToggleButton.classList.add(CSS_CLASS.TIMELOCK_OFF);
                    ui.timelockToggleButton.title = "Toggle Reading Time Lock (Off)";
                }
            }

            function toggleTimelock() {
                isTimelockGloballyEnabled = !isTimelockGloballyEnabled;
                updateStatus(`Timelock globally ${isTimelockGloballyEnabled ? 'ENABLED' : 'DISABLED'}`);
                updateTimelockButtonVisuals();

                if (!isTimelockGloballyEnabled && isTimeLockActive) {
                    updateStatus("Timelock globally disabled, clearing current active lock.");
                    isTimeLockActive = false;
                    requiredReadingTime = 0;
                    currentPageLockStartTime = 0;
                    currentLockType = null;
                    clearTimeout(appState.alertTimeout);
                    toggleVisibility(ui.readingTimeAlert, false);
                } else if (isTimelockGloballyEnabled) {
                    updateStatus("Timelock globally enabled, re-evaluating lock state for current view.");
                    updateDisplay();
                }
                manageLeftToolbar(false);
            }

            // --- Notes Nav Button Fade Logic ---
            function startNotesNavFadeTimer() {
                const FADE_BREAKPOINT = 768;
                const FADE_DELAY = 3500;

                clearTimeout(notesNavFadeTimeout);

                if (window.innerWidth <= FADE_BREAKPOINT) {
                    notesNavFadeTimeout = setTimeout(() => {
                        if (ui.notesPopupContainer ? .classList.contains(CSS_CLASS.VISIBLE)) {
                            ui.notesPrevBtn ? .classList.add('notes-nav-faded');
                            ui.notesNextBtn ? .classList.add('notes-nav-faded');
                            updateStatus("Fading notes nav buttons due to timeout on narrow screen.");
                        }
                    }, FADE_DELAY);
                } else {
                    updateStatus("Notes nav buttons timer not started (wide screen).");
                }
            }

            function showNotesNavAndResetTimer() {
                clearTimeout(notesNavFadeTimeout);
                ui.notesPrevBtn ? .classList.remove('notes-nav-faded');
                ui.notesNextBtn ? .classList.remove('notes-nav-faded');
                startNotesNavFadeTimer();
            }

            // --- Event Setup ---
            function setupEvents() {
                updateStatus("Setting up events");

                ui.rightToolbar ? .addEventListener('click', (e) => {
                    const btn = e.target.closest('.new-btn');
                    if (!btn) return;
                    switch (btn.id) {
                        case 'back-btn':
                            window.history.back();
                            break;
                        case 'single-page-btn':
                            setSinglePageView();
                            break;
                        case 'double-page-btn':
                            setDoublePageView();
                            break;
                        case 'time-capsule-btn':
                            console.log("Time Capsule button clicked (feature disabled).");
                            break;
                    }
                });
                ui.leftToolbar ? .addEventListener('click', e => {
                    const btn = e.target.closest('.new-btn');
                    if (!btn || btn.id !== 'timelock-toggle-btn') return;
                    toggleTimelock();
                });
                ui.returnViewFixedBtn ? .addEventListener('click', setRotatedView);

                ui.closeIframePopupBtn ? .addEventListener('click', hideIframePopup);
                ui.iframePopupBackdrop ? .addEventListener('click', hideIframePopup);
                ui.notesPopupBackdrop ? .addEventListener('click', hideNotesPopup);
                ui.loContinueBtn ? .addEventListener('click', hideLoAchievementPopup);
                ui.loAchievementBackdrop ? .addEventListener('click', hideLoAchievementPopup);

                ui.notesPrevBtn ? .addEventListener('click', notesPrevPage);
                ui.notesNextBtn ? .addEventListener('click', notesNextPage);

                ui.notesPrevBtn ? .addEventListener('mouseenter', showNotesNavAndResetTimer);
                ui.notesNextBtn ? .addEventListener('mouseenter', showNotesNavAndResetTimer);
                ui.notesPdfCanvasContainer ? .addEventListener('mouseenter', showNotesNavAndResetTimer);
                ui.notesPdfCanvasContainer ? .addEventListener('touchstart', showNotesNavAndResetTimer, {
                    passive: true
                });

                ui.bookSpread ? .addEventListener('click', (e) => {
                    if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;

                    const pageEdgeNav = e.target.closest('.page-edge-nav');
                    const rotateBtn = e.target.closest('.page-rotate-btn');
                    const rotateTrigger = e.target.closest('.page-rotate-hover-trigger');

                    if (rotateTrigger) return;

                    if (pageEdgeNav) {
                        const pageDiv = pageEdgeNav.closest('.book-page');
                        if (!pageDiv || pageDiv.classList.contains(CSS_CLASS.PLACEHOLDER_PAGE) || pageEdgeNav.style.display === 'none') return;

                        if (pageEdgeNav.classList.contains('page-edge-left')) {
                            prevPage();
                        } else {
                            nextPage();
                        }
                    } else if (rotateBtn) {
                        const btnStyle = window.getComputedStyle(rotateBtn);
                        if (btnStyle.opacity === '1' && btnStyle.pointerEvents !== 'none') {
                            const pageDiv = rotateBtn.closest('.book-page');
                            if (pageDiv && !pageDiv.classList.contains(CSS_CLASS.PLACEHOLDER_PAGE)) {
                                let targetPageNum;
                                if (pageDiv.classList.contains('left')) {
                                    targetPageNum = pdfState.currentPage;
                                } else if (pageDiv.classList.contains('right')) {
                                    targetPageNum = pdfState.currentPage + 1;
                                } else {
                                    console.warn("Could not determine page number for rotation.");
                                    return;
                                }

                                if (targetPageNum >= 1 && targetPageNum <= pdfState.totalPages) {
                                    updateStatus(`Page rotate button clicked for page ${targetPageNum}.`);
                                    setRotatedView(targetPageNum);
                                } else {
                                    updateStatus(`Ignoring rotate click for invalid target page ${targetPageNum}.`);
                                }
                            }
                        }
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;

                    if (e.key === 'Escape') {
                        if (ui.loAchievementPopup ? .classList.contains(CSS_CLASS.VISIBLE)) {
                            hideLoAchievementPopup();
                            e.preventDefault();
                            return;
                        }
                        if (ui.notesPopupContainer ? .classList.contains(CSS_CLASS.VISIBLE)) {
                            hideNotesPopup();
                            e.preventDefault();
                            return;
                        }
                        if (ui.iframePopupModal ? .classList.contains(CSS_CLASS.VISIBLE)) {
                            hideIframePopup();
                            e.preventDefault();
                            return;
                        }
                        if (ui.definitionPopup ? .classList.contains(CSS_CLASS.VISIBLE)) {
                            hideDefinitionPopup();
                            e.preventDefault();
                            return;
                        }
                    }

                    const isPopupActive = ui.notesPopupContainer ? .classList.contains(CSS_CLASS.VISIBLE) ||
                        ui.iframePopupModal ? .classList.contains(CSS_CLASS.VISIBLE) ||
                        ui.definitionPopup ? .classList.contains(CSS_CLASS.VISIBLE) ||
                        ui.loAchievementPopup ? .classList.contains(CSS_CLASS.VISIBLE);
                    const isInputFocused = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';

                    if (isPopupActive || isInputFocused || e.ctrlKey || e.altKey || e.metaKey) return;

                    let navAction = false;
                    switch (e.key) {
                        case 'ArrowRight':
                        case 'PageDown':
                            nextPage();
                            navAction = true;
                            break;
                        case 'ArrowLeft':
                        case 'PageUp':
                            prevPage();
                            navAction = true;
                            break;
                        case 'Home':
                            if (pdfState.totalPages > 0) jumpToPage(1);
                            navAction = true;
                            break;
                        case 'End':
                            if (pdfState.totalPages > 0) jumpToPage(pdfState.totalPages);
                            navAction = true;
                            break;
                    }
                    if (navAction) {
                        e.preventDefault();
                    }
                });

                window.addEventListener('resize', () => {
                    clearTimeout(appState.resizeTimer);
                    appState.resizeTimer = setTimeout(() => {
                        updateStatus("Resize detected.");
                        resetPopupStates();
                        applyCurrentViewModeStyles();
                        renderSliderMilestones();
                        if (!ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE) && pdfState.pdfDocument) {
                            updateDisplay();
                        }
                        manageToolbar();
                        manageLeftToolbar();
                        showNotesNavAndResetTimer();
                    }, 250);
                });

                let touchStartX = 0,
                    touchStartY = 0,
                    touchStartTime = 0;
                const swipeThresholdX = 40;
                const swipeMaxTime = 500;
                const swipeMaxVertical = 70;

                ui.body.addEventListener('touchstart', (e) => {
                    if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) return;
                    const ignoredElements = '#new-toolbar,.toolbar-trigger-area,#left-toolbar,.left-toolbar-trigger-area,#page-slider-container,#page-slider-trigger-zone,.toc-panel,.page-edge-nav,.new-btn,button,input,a,#definition-popup,.keyword-highlight,.annotationLayer section,#iframe-popup-modal,#iframe-popup-backdrop,#notes-popup-container,#notes-popup-backdrop, .page-action-btn, #return-view-fixed-btn, .page-rotate-hover-trigger, .lo-milestone, #lo-achievement-popup, #lo-achievement-backdrop';
                    if (e.target.closest(ignoredElements)) {
                        touchStartX = 0;
                        touchStartY = 0;
                        touchStartTime = 0;
                        return;
                    }
                    if (e.touches.length === 1) {
                        touchStartX = e.touches[0].screenX;
                        touchStartY = e.touches[0].screenY;
                        touchStartTime = Date.now();
                    } else {
                        touchStartX = 0;
                        touchStartY = 0;
                        touchStartTime = 0;
                    }
                }, {
                    passive: true
                });

                ui.body.addEventListener('touchend', (e) => {
                    if (ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE) || touchStartTime === 0) return;
                    if (e.target.closest('#notes-pdf-canvas-container') || e.target.closest('#lo-achievement-popup')) {
                        touchStartX = 0;
                        touchStartY = 0;
                        touchStartTime = 0;
                        return;
                    }
                    if (e.target.closest('.page-rotate-hover-trigger') || e.target.closest('.lo-milestone')) {
                        touchStartX = 0;
                        touchStartY = 0;
                        touchStartTime = 0;
                        return;
                    }

                    if (e.changedTouches.length === 1) {
                        const touchEndX = e.changedTouches[0].screenX;
                        const touchEndY = e.changedTouches[0].screenY;
                        const elapsedTime = Date.now() - touchStartTime;

                        if (elapsedTime < swipeMaxTime) {
                            const deltaX = touchEndX - touchStartX;
                            const deltaY = touchEndY - touchStartY;
                            const absDeltaX = Math.abs(deltaX);
                            const absDeltaY = Math.abs(deltaY);

                            if (absDeltaX > swipeThresholdX && absDeltaY < swipeMaxVertical) {
                                e.stopPropagation();
                                if (deltaX > 0) {
                                    updateStatus("Body Swipe Right Detected -> Previous Page");
                                    prevPage();
                                } else {
                                    updateStatus("Body Swipe Left Detected -> Next Page");
                                    nextPage();
                                }
                            }
                        }
                    }
                    touchStartX = 0;
                    touchStartY = 0;
                    touchStartTime = 0;
                });

                let notesTouchStartX = 0,
                    notesTouchStartY = 0,
                    notesTouchStartTime = 0;
                const notesSwipeThresholdX = 50;

                ui.notesPdfCanvasContainer ? .addEventListener('touchstart', (e) => {
                    if (!ui.notesPopupContainer ? .classList.contains(CSS_CLASS.VISIBLE)) return;
                    if (e.target.closest('.notes-nav-btn')) {
                        notesTouchStartX = 0;
                        notesTouchStartY = 0;
                        notesTouchStartTime = 0;
                        return;
                    }
                    if (e.touches.length === 1) {
                        notesTouchStartX = e.touches[0].screenX;
                        notesTouchStartY = e.touches[0].screenY;
                        notesTouchStartTime = Date.now();
                    } else {
                        notesTouchStartX = 0;
                        notesTouchStartY = 0;
                        notesTouchStartTime = 0;
                    }
                }, {
                    passive: true
                });

                ui.notesPdfCanvasContainer ? .addEventListener('touchend', (e) => {
                    if (!ui.notesPopupContainer ? .classList.contains(CSS_CLASS.VISIBLE) || notesTouchStartTime === 0) return;
                    if (e.changedTouches.length === 1) {
                        const notesTouchEndX = e.changedTouches[0].screenX;
                        const notesTouchEndY = e.changedTouches[0].screenY;
                        const notesElapsedTime = Date.now() - notesTouchStartTime;

                        if (notesElapsedTime < swipeMaxTime) {
                            const notesDeltaX = notesTouchEndX - notesTouchStartX;
                            const notesDeltaY = notesTouchEndY - notesTouchStartY;
                            const notesAbsDeltaX = Math.abs(notesDeltaX);
                            const notesAbsDeltaY = Math.abs(notesDeltaY);

                            if (notesAbsDeltaX > notesSwipeThresholdX && notesAbsDeltaY < swipeMaxVertical) {
                                e.stopPropagation();
                                if (notesDeltaX > 0) {
                                    updateStatus("Notes Swipe Right Detected -> Previous Notes Page");
                                    notesPrevPage();
                                } else {
                                    updateStatus("Notes Swipe Left Detected -> Next Notes Page");
                                    notesNextPage();
                                }
                            }
                        }
                    }
                    notesTouchStartX = 0;
                    notesTouchStartY = 0;
                    notesTouchStartTime = 0;
                });

                ui.goToChapterBtn ? .addEventListener('click', transitionToChapter);

                window.addEventListener('message', (event) => {
                    if (event.source !== ui.gameIframe ? .contentWindow) {
                        return;
                    }

                    if (event.data && event.data.type === 'gameOver') {
                        handleGameOverFromGame(event.data.score);
                    } else if (event.data && event.data.type === 'gameLoaded') {
                        if (ui.iframeLoadingText) ui.iframeLoadingText.style.display = 'none';
                        updateStatus("Game iframe reported 'gameLoaded'.");
                        updateStatus("Sending 'focusGame' message back to iframe.");
                        try {
                            if (ui.gameIframe ? .contentWindow) {
                                ui.gameIframe.contentWindow.postMessage({
                                    type: 'focusGame'
                                }, '*');
                                updateStatus("Successfully sent 'focusGame' message.");
                            } else {
                                console.warn("Cannot send 'focusGame' message: Game iframe or contentWindow not accessible.");
                            }
                        } catch (postMessageError) {
                            console.warn("Error sending 'focusGame' message:", postMessageError);
                        }
                    }
                });

                ui.gameIframe ? .addEventListener('load', () => {
                    if (ui.iframeLoadingText) ui.iframeLoadingText.style.display = 'none';
                    updateStatus("Game iframe document structure loaded (waiting for gameLoaded message).");
                });

                document.addEventListener('click', (e) => {
                    if (ui.definitionPopup ? .classList.contains(CSS_CLASS.VISIBLE) &&
                        !ui.definitionPopup.contains(e.target) &&
                        !e.target.closest('.keyword-highlight')) {
                        hideDefinitionPopup();
                    }
                }, true);

                ui.gameIframe ? .addEventListener('focus', () => {
                    if (appState.isReaderReady && ui.body.classList.contains(CSS_CLASS.LOADING_GAME_ACTIVE)) {
                        updateStatus("Game iframe focused after reader ready. Forcing transition to chapter.");
                        transitionToChapter();
                    }
                }, true);

                updateStatus("Events setup complete");
            }

            // --- Initialization ---
            async function init() {
                updateStatus("Initializing application...");

                try {
                    try {
                        appState.pagePadding = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-padding')) || 15;
                    } catch (e) {
                        appState.pagePadding = 15;
                        console.warn("CSS var --page-padding read failed, using default.");
                    }

                    pdfState.notesMapping = processNotesData(rawNotesData);

                    setupEvents();
                    setupToolbarHover();
                    setupLeftToolbarHover();
                    updateTimelockButtonVisuals();
                    initPageSlider();

                    const urlParams = new URLSearchParams(window.location.search);
                    const pdfUrlParam = urlParams.get('pdf');

                    if (pdfUrlParam) {
                        updateStatus(`PDF URL parameter found: ${pdfUrlParam}. Starting background load...`);
                        loadPdf(pdfUrlParam);
                    } else {
                        updateStatus("No PDF specified in URL parameter (?pdf=...). Reader content will not load.");
                        appState.isReaderReady = false;
                        if (ui.goToChapterBtn) {
                            ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE, CSS_CLASS.LOADING_CHAPTER);
                        }
                        ui.body.classList.remove(CSS_CLASS.LOADING_GAME_ACTIVE);

                        if (ui.mainContainer) {
                            ui.mainContainer.style.visibility = 'visible';
                            ui.mainContainer.style.opacity = '1';
                            ui.mainContainer.innerHTML = `<div style="color: var(--text-on-dark); background: rgba(28,37,54,.8); border-radius: 8px; padding: 40px; text-align: center; max-width: 500px; margin: auto; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"><h2>Interactive Reader</h2><p style="margin-top: 15px;">Add <code>?pdf=URL_TO_PDF</code> to the address bar.</p></div>`;
                        }
                        if (ui.gameContainer) ui.gameContainer.style.display = 'none';
                    }

                    window.addEventListener('beforeunload', () => {
                        updateStatus("Unloading - Performing Cleanup.");
                        clearTimeout(appState.gameOverTimeoutId);
                        clearTimeout(appState.alertTimeout);
                        clearTimeout(appState.alertWiggleTimeout);
                        clearTimeout(toolbarTimer);
                        clearTimeout(leftToolbarTimer);
                        clearTimeout(appState.resizeTimer);
                        clearTimeout(appState.sliderHideTimeout);
                        pdfState.pageCache.clear();
                        if (pdfState.pdfDocument ? .destroy) {
                            try {
                                pdfState.pdfDocument.destroy();
                            } catch (e) {}
                        }
                        if (pdfState.currentNotesPdfDoc ? .destroy) {
                            try {
                                pdfState.currentNotesPdfDoc.destroy();
                            } catch (e) {}
                        }
                        pdfState.pdfDocument = null;
                        pdfState.currentNotesPdfDoc = null;
                        hideNotesPopup();
                        hideIframePopup();
                        hideDefinitionPopup();
                        hideLoAchievementPopup();
                    });

                    updateStatus("Initialization sequence complete. Background PDF loading may be in progress.");

                } catch (initError) {
                    console.error("CRITICAL Initialization failed:", initError);
                    document.body.innerHTML = `<div style="color: red; background: white; padding: 20px; border: 2px solid red; font-family: monospace; position: fixed; top: 10px; left: 10px; z-index: 11000; max-width: calc(100% - 20px); overflow: auto;"><pre>Application Initialization Error:\n${initError.stack || initError}</pre></div>`;
                    ui.body.classList.add(CSS_CLASS.LOADING_GAME_ACTIVE);
                    if (ui.goToChapterBtn) {
                        ui.goToChapterBtn.classList.remove(CSS_CLASS.VISIBLE, CSS_CLASS.LOADING_CHAPTER);
                    }
                }
            }

            // --- Start the application ---
            document.addEventListener('DOMContentLoaded', init);

        })();
    </script>
</body>

</html>
