<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heritage History™ - Digital Book Reader</title>
    <!-- Using PDF.js v2.5.207 as base for rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.min.js"></script>
    <!-- Viewer script still used for SimpleLinkService and CSS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf_viewer.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf_viewer.css">
    <style>
:root{
    --primary:#4a90e2;
    --secondary:#50e3c2;
    --accent:#f5a623; /* Amber/Orange */
    --fiery-orange: #f97316; /* Adjusted fiery orange */
    --lab-blue:#080e1c;
    --page:#fff;
    --text-on-dark:rgba(255,255,255,.9);
    --text-on-page:#333;
    /* --header-h:60px; /* Unused? */
    --page-w:650px; /* Base Desktop Page Width */
    --page-h:842px; /* Base Desktop Page Height */
    --page-padding:15px;
    /* Modern Font Stack */
    --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";

    /* --- Placeholder Variables for Time Capsule Button --- */
    /* Replace with actual values from your course page CSS if different */
    --scroll: #4a5568; /* Placeholder background */
    --gradient-time-capsule: linear-gradient(45deg, #f97316, #f5a623, #eab308, #f59e0b); /* Placeholder gradient */
    --text-light-bg-primary: #ffffff; /* Placeholder icon color */
}
*{margin:0;padding:0;box-sizing:border-box}
body{
    font-family: 'Georgia', serif; /* Keep base Georgia */
    background-color:var(--lab-blue);
    color:var(--text-on-dark);
    height:100vh; width:100vw;
    overflow:hidden; display:flex; flex-direction:column; position:fixed;
    line-height:1.6
}
body::before{content:'';position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;background-image:radial-gradient(circle at 15% 15%,rgba(249,115,22,.12) 0,transparent 45%),radial-gradient(circle at 85% 85%,rgba(197,83,235,.12) 0,transparent 45%),radial-gradient(circle at 85% 15%,rgba(56,189,248,.05) 0,transparent 40%),radial-gradient(circle at 15% 85%,rgba(251,191,36,.08) 0,transparent 40%);animation:ambient-shift 30s ease infinite alternate}
@keyframes ambient-shift{0%{background-position:0 0,0 0,0 0,0 0}100%{background-position:5% 10%,-5% -5%,10% -5%,-10% 5%}}
@media (prefers-reduced-motion:reduce){body::before{animation:none!important}}
@keyframes hazyGradientAnimation { /* Animation for Time Capsule button */
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* --- Toolbar (Desktop) --- */
#new-toolbar{
    position:fixed!important;top:15px!important;right:-60px!important;z-index:9999!important;
    display:flex!important;flex-direction:column!important;gap:10px!important; /* Gap between buttons */
    align-items: center; /* Center buttons horizontally */
    transition:right .3s ease, transform .3s ease!important;
    background:rgba(28,37,54,.9)!important;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);
    padding:10px 5px!important; /* More vertical padding */
    border-radius:8px 0 0 8px!important;box-shadow:-2px 2px 10px rgba(0,0,0,.4)!important;
    width:58px;border:1px solid rgba(255,255,255,.1);
}
#new-toolbar::before{
    content:"≡";position:absolute;left:-25px;top:50%;transform:translateY(-50%);
    background:rgba(28,37,54,.9);backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);
    width:25px;height:40px;display:flex;align-items:center;justify-content:center;
    border-radius:4px 0 0 4px;color:var(--text-on-dark);font-size:20px;
    box-shadow:-2px 2px 5px rgba(0,0,0,.3);transition:all .3s ease;
    border:1px solid rgba(255,255,255,.1);border-right:none;cursor:pointer;
}
.toolbar-trigger-area{
    position:fixed;top:0;right:0;width:30px;height:100%;z-index:9998;
    transition:all .3s ease;
}
#new-toolbar.visible{right:0!important;transform:none!important}

/* --- Toolbar Buttons (Standard) --- */
.new-btn{
    background:rgba(44,62,80,.8)!important;border:1px solid rgba(255,255,255,.15)!important;
    color:var(--text-on-dark)!important;width:48px!important;height:48px!important;
    border-radius:4px!important;display:flex!important;align-items:center!important;justify-content:center!important;
    font-size:25px!important;cursor:pointer!important;transition:all .2s!important;
    box-shadow:0 2px 5px rgba(0,0,0,.2)!important;user-select:none!important;flex-shrink:0;
}
.new-btn:hover{
    background:rgba(52,73,94,.9)!important;border-color:rgba(255,255,255,.25)!important;
    box-shadow:0 2px 8px rgba(0,0,0,.3)!important;transform:translateY(-2px)!important;
}
.new-btn:active{transform:translateY(1px)!important}
.new-btn[disabled]{opacity:.5;cursor:not-allowed;pointer-events:none}


/* --- START: Time Capsule Button Styles (from user) --- */
.circle-capsule-btn {
    position: relative;
    width: 30px; /* Smaller than standard buttons */
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--scroll);
    border: none;
    padding: 0;
    cursor: pointer;
    overflow: hidden;
    transition: transform 0.3s ease;
    flex-shrink: 0; /* Prevent shrinking */
}
.circle-capsule-btn .icon {
    width: 14px;
    height: 14px;
    color: var(--text-light-bg-primary);
    position: relative;
    z-index: 2;
    margin: 0; /* Remove margin if icon has it */
    font-size: 14px; /* Ensure icon size is consistent */
    line-height: 1; /* Prevent extra spacing */
}
.circle-capsule-btn::before {
    content: "";
    position: absolute;
    z-index: 1;
    top: -2px; left: -2px; right: -2px; bottom: -2px;
    background: var(--gradient-time-capsule);
    background-size: 300% 300%;
    border-radius: 50%;
    filter: blur(2px);
    opacity: 0.35;
    transition: opacity 0.4s ease-out, filter 0.4s ease-out;
    animation: hazyGradientAnimation 6s linear infinite;
}
.circle-capsule-btn:hover {
    transform: translateY(-2px);
}
.circle-capsule-btn:hover::before {
    opacity: 0.8;
    filter: blur(3px);
}
/* --- END: Time Capsule Button Styles --- */


/* --- Mobile Specific Toolbar --- */
body.mobile-device #new-toolbar {
    /* Horizontal toolbar at the bottom for mobile */
    top:auto!important; right:50%!important; bottom:-60px!important; transform:translateX(50%)!important;
    flex-direction:row!important; width:auto!important; height:58px!important;
    border-radius:8px 8px 0 0!important; padding:5px 10px!important; /* Horizontal padding */
    box-shadow:0 -2px 10px rgba(0,0,0,.4)!important; border-bottom:none;
    gap: 12px; /* Adjust gap for horizontal layout */
}
body.mobile-device #new-toolbar.visible {
    bottom:0!important; transform:translateX(50%)!important;
}
body.mobile-device #new-toolbar::before {
    left:50%!important; transform:translateX(-50%)!important; top:-25px!important;
    width:40px!important; height:25px!important; border-radius:4px 4px 0 0!important;
    content:"≡"; padding-bottom:5px; border-bottom:none;
}
body.mobile-device .toolbar-trigger-area {
    top:auto!important; bottom:0!important; left:0!important; transform:none!important;
    right:auto!important; width:100%!important; height:30px!important;
}
body.mobile-device #new-toolbar .new-btn {
     width:40px!important; height:40px!important; font-size:20px!important; transform: none; /* No rotate needed */
}
body.mobile-device #new-toolbar .circle-capsule-btn {
     width: 28px !important; /* Adjust size slightly for mobile bar */
     height: 28px !important;
}
body.mobile-device #new-toolbar .circle-capsule-btn .icon {
     width: 12px !important;
     height: 12px !important;
     font-size: 12px !important;
}
body.mobile-device .new-btn:hover { transform: scale(1.1); background:rgba(52,73,94,.9)!important; border-color:rgba(255,255,255,.25)!important; box-shadow:0 2px 8px rgba(0,0,0,.3)!important; }
body.mobile-device .new-btn:active { transform: scale(0.95); }
body.mobile-device .circle-capsule-btn:hover { transform: scale(1.1); } /* Simpler hover for mobile */


/* --- Main Content & Book Spread --- */
.main-container{flex:1;display:flex;justify-content:center!important;align-items:center!important;padding:0;height:100%;width:100%;overflow:hidden;position:relative;background:transparent}
.book-spread{display:flex;box-shadow:0 10px 35px rgba(0,0,0,.5);position:fixed!important;top:50%!important;left:50%!important;transform-origin:center center;width:auto!important;height:auto!important;transition:transform .3s ease, width .3s ease, height .3s ease; transform: translate(-50%, -50%)}

/* --- Book Page Base Styles --- */
.book-page{
    width:var(--page-w); height:var(--page-h); /* Desktop default */
    background-color:var(--page); position:relative; overflow:hidden;
    flex-shrink:0; display:flex; justify-content:center; align-items:center;
    border:1px solid rgba(255,255,255,.08); padding:0;
    transition: width 0.3s ease, height 0.3s ease, border-radius 0.3s ease;
}
.book-page.left{border-right:1px solid rgba(255,255,255,.15); border-radius:3px 0 0 3px;}
.book-page.right{border-left:1px solid rgba(255,255,255,.15); border-radius:0 3px 3px 0;}

/* --- Double Page Specific (Desktop Only) --- */
/* Default state (not fullscreen) applies these */
body:not(.fullscreen-mode) .book-page.left { width:var(--page-w); height:var(--page-h); border-radius:3px 0 0 3px; }
body:not(.fullscreen-mode) .book-page.right { width:var(--page-w); height:var(--page-h); border-radius:0 3px 3px 0; display: flex; /* Ensure right page shows by default */ }

/* Double page view specific shadows */
body:not(.fullscreen-mode) .book-page.left .canvas-container::after { /* Gutter shadow */
    content: ''; position: absolute; top: 0; right: calc(0px - var(--page-padding)); width: 15px; height: 100%;
    background: linear-gradient(to left, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0));
    pointer-events: none; z-index: 5; border-radius: 0 2px 2px 0;
}
body:not(.fullscreen-mode) .book-page.right:not(.placeholder-page) .canvas-container::before { /* Gutter shadow */
    content: ''; position: absolute; top: 0; left: calc(0px - var(--page-padding)); width: 15px; height: 100%;
    background: linear-gradient(to right, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0));
    pointer-events: none; z-index: 5; border-radius: 2px 0 0 2px;
}
body:not(.fullscreen-mode) .book-page.right.placeholder-page { border-left: 1px solid rgba(0,0,0,.1) !important; }

/* --- Single Page Mode (Fullscreen Mode) --- */
.fullscreen-mode .book-spread {
     /* Desktop Fullscreen: Centered, slightly smaller */
     width: 95vw; height: 95vh;
}
.fullscreen-mode .book-page.right { display:none!important; } /* Hide right page */
.fullscreen-mode .book-page.left {
    /* Desktop Fullscreen: Takes full spread size */
    width: 100%; height: 100%;
    border-radius:5px!important; border:1px solid rgba(255,255,255,.08)!important;
    border-right: none !important; padding:0;
}

/* --- Mobile View Mode (Always uses .fullscreen-mode) --- */
body.mobile-device.fullscreen-mode .book-spread {
    /* Mobile Fullscreen: Take entire viewport */
    width: 100vw; height: 100vh;
    box-shadow: none; /* No shadow needed when fullscreen */
    border-radius: 0; /* No border radius on mobile fullscreen */
}
body.mobile-device.fullscreen-mode .book-page.left {
    /* Mobile Fullscreen: Full spread size, no border/radius */
    width: 100%; height: 100%;
    border-radius: 0 !important; border: none !important;
}
body.mobile-device.fullscreen-mode .canvas-container {
     /* Mobile fullscreen canvas container */
     margin: 5px !important; /* Minimal padding */
     width: calc(100% - 10px); height: calc(100% - 10px);
}


/* --- Canvas & Layers --- */
.canvas-container {
    position: relative; /* Important for positioning layers */
    /* Default Desktop Padding */
    width: calc(100% - 2 * var(--page-padding)); height: calc(100% - 2 * var(--page-padding));
    margin: var(--page-padding);
    display: flex; justify-content: center; align-items: center;
    overflow: hidden; /* Clip layers */
}
/* Adjust canvas container padding in fullscreen desktop */
body:not(.mobile-device).fullscreen-mode .canvas-container {
     margin: 10px !important; /* Slightly reduced padding */
     width: calc(100% - 20px); height: calc(100% - 20px);
}

.pdf-canvas{
    max-width:100%; max-height:100%; display:block; object-fit:contain;
    box-shadow: none; position: absolute; top: 0; left: 0; z-index: 1; /* Canvas layer */
}
.textLayer { /* Base text layer (hidden) */
    position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden;
    opacity: 1; line-height: 1.0; color: transparent !important;
    user-select: none; -webkit-user-select: none; pointer-events: none !important;
    z-index: 2;
}
.textLayer > div { position: absolute; white-space: pre; cursor: default; transform-origin: 0% 0%; pointer-events: none !important; border-radius: 2px; }
.annotationLayer { /* PDF Annotations (links, etc.) */
    position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden;
    pointer-events: none; z-index: 3; /* Above text, below keywords */
}
.annotationLayer section { position: absolute; pointer-events: auto; /* Sections are clickable */ }
.annotationLayer .linkAnnotation { /* Ensure links cover area */
    width: 100%; height: 100%;
}
.annotationLayer .linkAnnotation > a { /* Link style */
    position: absolute; font-size: 1em; top: 0; left: 0; width: 100%; height: 100%;
    border: 1px solid transparent;
    transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out;
    cursor: pointer; /* Make it clear it's clickable */
    /* background-color: rgba(0, 0, 255, 0.05); */ /* Optional: Subtle blue tint for debugging links */
}
.annotationLayer .linkAnnotation > a:hover { /* Standard link hover */
    background-color: rgba(255, 255, 0, 0.2); border: 1px solid rgba(255, 255, 0, 0.5);
    box-shadow: 0px 0px 2px rgba(255, 255, 0, 0.5);
}
/* Custom: Style links detected as images differently on hover */
.annotationLayer .linkAnnotation.image-link > a:hover {
     background-color: rgba(74, 144, 226, 0.2); /* Light blue hover for image links */
     border: 1px solid rgba(74, 144, 226, 0.5);
     box-shadow: 0px 0px 3px rgba(74, 144, 226, 0.5);
}


/* --- Page Elements (Loading, Nav, Numbers) --- */
.page-number{display:none} /* Hidden by default */
.page-loading-overlay{position:absolute; inset: 0; /* Cover entire page */ background:rgba(255,255,255,.7); backdrop-filter: blur(2px); -webkit-backdrop-filter: blur(2px); z-index:50;display:none;justify-content:center;align-items:center;border-radius: inherit; /* Inherit from parent page */}
.page-loading-spinner{width:32px;height:32px;border-radius:50%;border:3px solid rgba(0,0,0,.1);border-top-color:var(--primary);animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}} /* Define spin if not already */
.page-edge-nav{position:absolute;top:0;height:100%;width:50px;cursor:pointer;z-index:10;transition:background-color .2s;-webkit-tap-highlight-color:transparent}
.page-edge-nav:hover{background-color:rgba(0,0,0,.03)}
.page-edge-left{left:0;border-radius:inherit; border-top-right-radius: 0; border-bottom-right-radius: 0;} /* Inherit radius */
.page-edge-right{right:0;border-radius:inherit; border-top-left-radius: 0; border-bottom-left-radius: 0;} /* Inherit radius */
.page-edge-left:hover::after,.page-edge-right:hover::after{content:"";position:absolute;top:50%;width:12px;height:12px;border-style:solid;border-color:rgba(0,0,0,.6);border-width:2px 2px 0 0;opacity:.8}
.page-edge-left:hover::after{left:18px;transform:translateY(-50%) rotate(-135deg)}
.page-edge-right:hover::after{right:18px;transform:translateY(-50%) rotate(45deg)}

/* Mobile edge nav tweaks */
body.mobile-device .page-edge-nav { width: 60px; } /* Slightly larger tap target */
body.mobile-device .page-edge-left:hover::after { left: 23px; }
body.mobile-device .page-edge-right:hover::after { right: 23px; }

/* --- Placeholder Page --- */
/* Placeholder styles are applied when .placeholder-page class is added via JS */
.book-page.right.placeholder-page{background-color:var(--page)!important;border-left:1px solid rgba(0,0,0,.1);position:relative;display:flex!important;justify-content:center;align-items:center; width: var(--page-w); height: var(--page-h);} /* Ensure dimensions */
.book-page.right.placeholder-page::after{content:"End of document";font-size:14px;font-style:italic;color:rgba(0,0,0,.5)}
.book-page.right.placeholder-page .canvas-container,.book-page.right.placeholder-page .page-edge-nav,.book-page.right.placeholder-page .page-loading-overlay{display:none!important} /* Hide everything inside */

/* --- Modals & Overlays --- */
.toc-panel{position:fixed;z-index:10000;display:none;color:var(--text-on-page); left:50%;top:50%;transform:translate(-50%,-50%);width:90%;max-width:500px;height:80vh;background:#f0f4f8;border-radius:8px;box-shadow:0 5px 25px rgba(0,0,0,.5);flex-direction:column;overflow:hidden; font-family: var(--font-sans);} /* Use modern font */
.toc-panel.visible,.loading-overlay.visible{display:flex!important}
.toc-header{padding:15px 20px;background:var(--primary);color:#fff;font-weight:700;display:flex;justify-content:space-between;align-items:center;flex-shrink:0}
.toc-header .notes-close{background:none;border:none;color:#fff;font-size:24px;cursor:pointer;padding:0 5px;line-height:1}
.toc-content{flex:1;padding:10px 20px;overflow-y:auto}
.toc-chapter{padding:8px 0;border-bottom:1px solid #d8dfe6}
.toc-chapter-title{font-weight:700;color:var(--primary);cursor:pointer;padding:5px 0}
.toc-chapter-title:hover,.toc-section:hover{color:var(--accent)}
.toc-sections{padding-left:20px;margin-top:5px}
.toc-section{padding:4px 0;cursor:pointer;color:#4a5568;font-size:.95em}
.loading-overlay{position:fixed;inset:0;background:rgba(8,14,28,.85);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);z-index:10001;display:none;justify-content:center;align-items:center;flex-direction:column}
.loading-spinner{width:50px;height:50px;border-radius:50%;border:4px solid rgba(255,255,255,.2);border-top-color:var(--accent);animation:spin 1s linear infinite;margin-bottom:15px}
.loading-message{font-size:16px;color:var(--text-on-dark)}
#status-indicator{display:none}

/* --- Page Slider (Common) --- */
.page-slider-container{position:fixed; z-index:9998; background:rgba(28,37,54,.9); backdrop-filter:blur(5px); -webkit-backdrop-filter:blur(5px); border:1px solid rgba(255,255,255,.1); transition: bottom .35s cubic-bezier(.2,.9,.3,1), left .35s cubic-bezier(.2,.9,.3,1), transform .35s cubic-bezier(.2,.9,.3,1), width .3s ease, height .3s ease; }
.page-slider-container.visible{ bottom:0; /* Default bottom pos */ }
.page-slider{ width:100%; height:6px; -webkit-appearance:none; appearance:none; background:rgba(255,255,255,.1); outline:none; border-radius:3px; overflow:visible; cursor:pointer; transition:height .2s; }
.page-slider:hover{height:8px}
.page-slider::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:20px; height:20px; border-radius:50%; background:var(--accent); cursor:pointer; border:3px solid rgba(28,37,54,.9); box-shadow:0 1px 6px rgba(0,0,0,.4); transition:all .2s ease; margin-top:-7px; /* Adjust for horizontal */ }
.page-slider::-webkit-slider-thumb:hover{width:24px;height:24px; margin-top:-8px;}
.page-slider::-moz-range-thumb{width:20px;height:20px;border-radius:50%;background:var(--accent);cursor:pointer;border:3px solid rgba(28,37,54,.9);box-shadow:0 1px 6px rgba(0,0,0,.4)}
.page-slider::-moz-range-thumb:hover{width:24px;height:24px}
.page-slider-info{font-size:12px;color:var(--text-on-dark);font-weight:500;letter-spacing:.3px;opacity:.8}
#page-slider-trigger-zone {position: fixed; z-index: 9997; pointer-events: auto;}

/* --- Page Slider (Desktop - Horizontal Bottom) --- */
body:not(.mobile-device) .page-slider-container{
    bottom:-80px; left:50%; transform:translateX(-50%); width:90%; max-width:700px;
    padding:14px 20px; border-bottom:none; box-shadow:0 -4px 20px rgba(0,0,0,.4);
    display:flex; flex-direction:column; align-items:center; border-radius:16px 16px 0 0;
}
body:not(.mobile-device) .page-slider-container.visible{ bottom:0; }
body:not(.mobile-device) .page-slider-track{ width:100%; margin-bottom:8px; padding:0 10px; }
body:not(.mobile-device) .page-slider::-webkit-slider-runnable-track{ height:100%; background:linear-gradient(to right,var(--accent) var(--slider-percent,0%),rgba(255,255,255,.1) var(--slider-percent,0%)); border-radius:3px; }
body:not(.mobile-device) .page-slider::-moz-range-progress{background-color:var(--accent);height:100%;border-radius:3px}
body:not(.mobile-device) .page-slider::-moz-range-track{background-color:rgba(255,255,255,.1);height:100%;border-radius:3px}
body:not(.mobile-device) #page-slider-trigger-zone { bottom: 0; left: 0; width: 100%; height: 30px; }

/* --- Page Slider (Mobile - Vertical Left) --- */
body.mobile-device .page-slider-container{
    bottom:50%!important; left:-80px!important; top:auto!important; transform:translateY(50%)!important;
    width:60px!important; height:70vh!important; max-width:none!important; max-height:500px;
    flex-direction:column-reverse!important; padding:10px 5px!important; border-left:none;
    border-radius:0 12px 12px 0!important; box-shadow:2px 0 20px rgba(0,0,0,.4)!important;
}
body.mobile-device .page-slider-container.visible{ left:0!important; }
body.mobile-device .page-slider-track{ width:100%!important; height:100%!important; margin-bottom:0!important; padding:10px 0!important; display:flex; align-items:center; flex:1; }
body.mobile-device .page-slider{ width:6px!important; height:100%!important; writing-mode:vertical-lr!important; -webkit-appearance:slider-vertical!important; appearance:slider-vertical; margin:0 auto!important; padding:0!important; background:rgba(255,255,255,.1)!important; border-radius:3px; }
body.mobile-device .page-slider::-webkit-slider-runnable-track{ width:6px!important; height:100%; background:linear-gradient(to top,var(--accent) var(--slider-percent,0%),rgba(255,255,255,.1) var(--slider-percent,0%))!important; border-radius:3px; }
body.mobile-device .page-slider::-webkit-slider-thumb{ -webkit-appearance: none; appearance: none; width:20px!important; height:20px!important; border-radius: 50%; background: var(--accent); cursor: pointer; border: 3px solid rgba(28,37,54,.9)!important; box-shadow: 0 1px 6px rgba(0,0,0,.4); transition: all .2s ease; margin-top:0!important; margin-left:-7px!important; /* Adjust for vertical */ }
body.mobile-device .page-slider:hover::-webkit-slider-thumb { width: 24px !important; height: 24px !important; margin-left: -9px !important; }
body.mobile-device .page-slider::-moz-range-thumb{ width: 20px; height: 20px; border-radius:50%; background:var(--accent); cursor:pointer; border:3px solid rgba(28,37,54,.9); box-shadow:0 1px 6px rgba(0,0,0,.4); transition: all .2s ease; }
body.mobile-device .page-slider:hover::-moz-range-thumb { width: 24px; height: 24px; }
body.mobile-device .page-slider::-moz-range-progress{ background-color:var(--accent)!important; width:6px!important; border-radius:3px; }
body.mobile-device .page-slider::-moz-range-track{ background-color:rgba(255,255,255,.1); width:6px!important; border-radius:3px; }
body.mobile-device .page-slider-info{ transform:rotate(90deg); white-space:nowrap; margin-bottom:15px; padding-top:10px; color:var(--text-on-dark); }
body.mobile-device #page-slider-trigger-zone { bottom: auto; top: 50%; left: 0; width: 30px; height: 100%; transform: translateY(-50%); }

/* --- START: Custom Keyword Overlay & Popup Styles (Unchanged) --- */
.keyword-overlay-container {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 4; overflow: hidden;
}
.keyword-highlight {
  position: absolute; background: transparent;
  transition: background 0.2s ease-out, box-shadow 0.2s ease-out;
  pointer-events: auto; cursor: pointer; z-index: 5;
  box-sizing: border-box; border-radius: 3px;
}
.keyword-highlight:hover {
  background: linear-gradient(to right, rgba(249, 115, 22, 0.25), rgba(251, 191, 36, 0.25));
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
}
#definition-popup {
  position: fixed; background: #ffffff; border-radius: 8px;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15), 0 2px 5px rgba(0, 0, 0, 0.1);
  padding: 14px 18px; max-width: 320px; min-width: 180px;
  font-family: var(--font-sans); color: #2d3748; z-index: 10002;
  transform-origin: top center; transform: translateY(6px) scale(0.97);
  opacity: 0; visibility: hidden;
  transition: transform 0.18s cubic-bezier(0.4, 0, 0.2, 1),
              opacity 0.18s cubic-bezier(0.4, 0, 0.2, 1),
              visibility 0s linear 0.18s;
  pointer-events: none;
}
#definition-popup.visible {
  transform: translateY(0) scale(1); opacity: 1; visibility: visible;
  transition: transform 0.18s cubic-bezier(0.4, 0, 0.2, 1),
              opacity 0.18s cubic-bezier(0.4, 0, 0.2, 1),
              visibility 0s linear 0s;
   pointer-events: auto;
}
#popup-word {
  font-weight: 600; font-size: 15px; margin: 0 0 10px 0;
  color: var(--primary); border-bottom: 1px solid #e2e8f0; padding: 0 0 8px 0;
}
#popup-definition {
  font-size: 14px; line-height: 1.6; max-height: 180px; overflow-y: auto;
  color: #4a5568; padding-right: 5px; margin-right: -5px;
}
#popup-definition::-webkit-scrollbar { width: 5px; }
#popup-definition::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px;}
#popup-definition::-webkit-scrollbar-thumb { background: #cbd5e0; border-radius: 3px;}
#popup-definition::-webkit-scrollbar-thumb:hover { background: #a0aec0; }
#close-popup-btn {
  position: absolute; top: 6px; right: 6px; cursor: pointer;
  font-size: 20px; font-weight: 300; color: #a0aec0;
  transition: color 0.2s, background-color 0.2s;
  background: none; border: none; padding: 0; width: 28px; height: 28px;
  display: flex; align-items: center; justify-content: center;
  border-radius: 50%; line-height: 1;
}
#close-popup-btn:hover { color: #4a5568; background-color: #edf2f7; }
/* --- END: Custom Keyword Overlay & Popup Styles --- */

/* --- START: Image Lightbox Styles (Unchanged) --- */
#image-lightbox {
    position: fixed; inset: 0; z-index: 10010; /* High z-index */
    background: rgba(0, 0, 0, 0.85); /* Dark semi-transparent background */
    display: none; /* Hidden by default */
    align-items: center; justify-content: center;
    padding: 20px; /* Space around the image */
    cursor: pointer; /* Click background to close */
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}
#image-lightbox.visible {
    display: flex;
}
#lightbox-image {
    display: block;
    max-width: 100%;
    max-height: 100%;
    object-fit: contain; /* Scale image down to fit */
    box-shadow: 0 5px 25px rgba(0,0,0,0.4);
    cursor: default; /* Don't show pointer cursor on image itself */
    border-radius: 4px; /* Optional slight rounding */
}
#close-lightbox-btn {
    position: absolute;
    top: 15px; right: 15px;
    width: 40px; height: 40px;
    background: rgba(40, 40, 40, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    color: #fff;
    font-size: 24px;
    font-weight: 300;
    line-height: 38px; /* Center '×' */
    text-align: center;
    cursor: pointer;
    transition: background 0.2s ease, transform 0.2s ease;
}
#close-lightbox-btn:hover {
    background: rgba(60, 60, 60, 0.9);
    transform: scale(1.1);
}
/* --- END: Image Lightbox Styles --- */

    </style>
</head>
<body>
    <!-- Device Type Class applied dynamically via JS -->

    <!-- Toolbar, Trigger Area, Status Indicator -->
    <div id="new-toolbar"></div>
    <div class="toolbar-trigger-area" id="toolbar-trigger-area"></div>
    <div id="status-indicator">Status: Initializing...</div>

    <!-- Main Content Area -->
    <div class="main-container">
        <div class="book-spread">
            <!-- Left Page -->
            <div class="book-page left">
                <div class="canvas-container">
                    <canvas id="left-page-canvas" class="pdf-canvas"></canvas>
                    <div class="textLayer" id="left-text-layer"></div>
                    <div class="annotationLayer" id="left-annotation-layer"></div>
                    <div class="keyword-overlay-container" id="left-keyword-overlay"></div>
                </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="left-page-number"></div>
                <div class="page-loading-overlay"><div class="page-loading-spinner"></div></div>
            </div>
            <!-- Right Page -->
            <div class="book-page right"> <!-- Initially present, hidden/shown by CSS/JS -->
                 <div class="canvas-container">
                    <canvas id="right-page-canvas" class="pdf-canvas"></canvas>
                     <div class="textLayer" id="right-text-layer"></div>
                     <div class="annotationLayer" id="right-annotation-layer"></div>
                     <div class="keyword-overlay-container" id="right-keyword-overlay"></div>
                 </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="right-page-number"></div>
                <div class="page-loading-overlay"><div class="page-loading-spinner"></div></div>
            </div>
        </div>
    </div>

    <!-- Modals and Overlays -->
    <div class="toc-panel" id="toc-panel"></div>
    <div class="loading-overlay" id="loading-overlay"></div>
    <div class="page-slider-container" id="page-slider-container"></div>
    <div id="page-slider-trigger-zone"></div>

    <!-- Definition Popup -->
    <div class="definition-popup" id="definition-popup">
        <button class="definition-popup-close" id="close-popup-btn" title="Close (Esc)">×</button>
        <div class="definition-popup-title" id="popup-word">Keyword</div>
        <div class="definition-popup-content" id="popup-definition">Loading definition...</div>
    </div>

    <!-- Image Lightbox -->
    <div id="image-lightbox">
        <button id="close-lightbox-btn" title="Close (Esc)">×</button>
        <img id="lightbox-image" src="" alt="Enlarged Image">
    </div>

<script>
    // Populate Inner HTML for static modals/toolbars first
    document.getElementById('toc-panel').innerHTML = `<div class="toc-header"><span>Table of Contents</span><button class="notes-close" id="close-toc-btn">×</button></div><div class="toc-content"><div id="toc-list">Loading...</div></div>`;
    document.getElementById('loading-overlay').innerHTML = `<div class="loading-spinner"></div><div class="loading-message">Processing...</div>`;
    document.getElementById('page-slider-container').innerHTML = `<div class="page-slider-track"><input type="range" id="page-slider" class="page-slider" min="1" max="1" value="1" style="--slider-percent: 0%"></div><div class="page-slider-info"><span id="current-page-display">Page 1</span> of <span id="total-pages-display">1</span></div>`;
</script>
<script>
    // --- UI Elements ---
    const definitionPopup = document.getElementById('definition-popup');
    const popupWord = document.getElementById('popup-word');
    const popupDefinition = document.getElementById('popup-definition');
    const closePopupBtn = document.getElementById('close-popup-btn');
    const statusIndicator = document.getElementById('status-indicator');
    const imageLightbox = document.getElementById('image-lightbox');
    const lightboxImage = document.getElementById('lightbox-image');
    const closeLightboxBtn = document.getElementById('close-lightbox-btn');

    // --- State Variables ---
    let keywordDefinitions = {};
    let pageKeywords = {};
    let currentViewports = {};
    let isMobile = false; // Updated in init()

    // --- PDF.js Setup ---
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    const pdfjsViewer = window['pdfjs-dist/web/pdf_viewer'];
    pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.worker.min.js';

    const book={title:"No Document",totalPages:0,currentPage:1,isDoublePageView:true,pdfDocument:null,outline:[]};
    const user={readingProgress:{furthestPage:1}};

    // --- Timers and Cache ---
    let toolbarTimer=null;
    let toolbarHover=!1;
    const pageCache=new Map();
    const MAX_CACHE_SIZE=20;
    let PAGE_PADDING=15; // Updated based on device type later
    let resizeTimer;
    let sliderHideTimeout=null;

    // --- PDF.js Services ---
    const linkService = new pdfjsViewer.SimpleLinkService();
    const eventBus = new pdfjsViewer.EventBus();

    const updateStatus=m=>console.log(`[Viewer Status] ${m}`);
    // const updateStatus = () => {}; // Production

    // --- Device Detection ---
    function isMobileDevice() {
        // Use a broader check, considering touch capability and screen width
        const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
        return window.matchMedia("(max-width: 1024px)").matches || (hasTouch && window.innerWidth < 1024);
    }

    // --- Toolbar Logic ---
    function manageToolbar(s=null){
        const t=document.getElementById('new-toolbar'); if(!t)return;
        clearTimeout(toolbarTimer);
        const show=s??toolbarHover;
        if(show){t.classList.add('visible')}
        else{toolbarTimer=setTimeout(()=>{if(!toolbarHover)t.classList.remove('visible')},500)}
    }
    function setupToolbarHover(){ // Unchanged logic for showing/hiding
        const t=document.getElementById('new-toolbar'),a=document.getElementById('toolbar-trigger-area');
        if(!t||!a){console.error("Toolbar/trigger missing");return}
        const enter=()=>{toolbarHover=true;manageToolbar(true)};
        const leave=()=>{toolbarHover=false;manageToolbar(false)};
        a.addEventListener('mouseenter',enter);t.addEventListener('mouseenter',enter);
        a.addEventListener('mouseleave',leave);t.addEventListener('mouseleave',leave);
        // Toolbar Handle Click (to toggle visibility)
        t.addEventListener('click',e=>{
            if(e.target.closest('.new-btn') || e.target.closest('.circle-capsule-btn')) return; // Ignore clicks on buttons
            const rect = t.getBoundingClientRect();
            const handleWidth = 25, handleHeight = 40;
            const mobileHandleWidth = 40, mobileHandleHeight = 25;
            let clickedHandle = false;
            if (isMobile) { if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY < rect.top && e.clientY >= rect.top - mobileHandleHeight) clickedHandle = true; }
            else { if (e.clientY >= rect.top && e.clientY <= rect.bottom && e.clientX < rect.left && e.clientX >= rect.left - handleWidth) clickedHandle = true; }
            if (clickedHandle) { toolbarHover = !t.classList.contains('visible'); manageToolbar(); }
        });
        updateStatus("Toolbar setup.")
    }

    // --- Caching & Page Loading ---
    function trimCache(){while(pageCache.size>MAX_CACHE_SIZE){pageCache.delete(pageCache.keys().next().value);}}
    function showPageLoading(canvasId){const o=document.getElementById(canvasId)?.closest('.book-page')?.querySelector('.page-loading-overlay');if(o)o.style.display='flex';}
    function hidePageLoading(canvasId){const o=document.getElementById(canvasId)?.closest('.book-page')?.querySelector('.page-loading-overlay');if(o)o.style.display='none';}

    // --- Custom Keyword Overlay Creation (Unchanged) ---
    async function createKeywordOverlays(pageNum, pageElement, viewport) {
        const overlayContainerId = pageElement.classList.contains('left') ? 'left-keyword-overlay' : 'right-keyword-overlay';
        const overlayContainer = document.getElementById(overlayContainerId);
        const canvasContainer = pageElement.querySelector('.canvas-container');
        if (!book.pdfDocument || !overlayContainer || !canvasContainer) { console.warn(`Skipping keyword overlay for page ${pageNum}: Missing elements.`); return; }
        overlayContainer.innerHTML = '';
        const keywordsForPage = pageKeywords[pageNum.toString()] || [];
        if (keywordsForPage.length === 0) return;
        const lowerCaseKeywords = keywordsForPage.map(k => k.toLowerCase());
        const lowerCaseDefs = {};
        for (const key in keywordDefinitions) { lowerCaseDefs[key.toLowerCase()] = keywordDefinitions[key]; }
        try {
            const page = await book.pdfDocument.getPage(pageNum);
            const textContent = await page.getTextContent({ normalizeWhitespace: true });
            textContent.items.forEach(item => {
                const itemText = item.str; if (!itemText || itemText.trim().length === 0) return;
                keywordsForPage.forEach((originalKeyword, index) => {
                    const keywordLower = lowerCaseKeywords[index]; const definition = lowerCaseDefs[keywordLower]; if (!definition) return;
                    const escapedKeyword = originalKeyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); const regex = new RegExp(`\\b(${escapedKeyword})\\b`, 'gi'); let match;
                    while ((match = regex.exec(itemText)) !== null) {
                        const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                        const itemWidth = item.width; const itemHeight = item.height; let left = tx[4]; let top = tx[5] - itemHeight; if (left < 0) left = 0; if (top < 0) top = 0;
                        const highlightDiv = document.createElement('div'); highlightDiv.className = 'keyword-highlight';
                        highlightDiv.style.cssText = `left: ${left}px; top: ${top}px; width: ${itemWidth}px; height: ${itemHeight}px;`;
                        highlightDiv.dataset.keyword = originalKeyword; highlightDiv.dataset.definition = definition; highlightDiv.title = `Definition: ${originalKeyword}`;
                        highlightDiv.addEventListener('click', (e) => { e.stopPropagation(); const rect = highlightDiv.getBoundingClientRect(); showDefinitionPopup(originalKeyword, definition, rect.left, rect.bottom, rect.top); });
                        overlayContainer.appendChild(highlightDiv);
                        return; // Assume one highlight per text item per keyword for simplicity? Maybe remove this return if multiple needed.
                    }
                });
            });
        } catch (error) { console.error(`Error processing text content for keyword overlays on page ${pageNum}:`, error); overlayContainer.innerHTML = ''; }
    }

    // --- Base Text Layer Rendering (Unchanged) ---
    async function renderAndEnhanceTextLayer(page, container, viewport) {
      if (!page || !container || !viewport) return; container.innerHTML = '';
      container.style.pointerEvents = 'none'; container.style.color = 'transparent';
      try { const textContent = await page.getTextContent({normalizeWhitespace: true}); await pdfjsLib.renderTextLayer({ textContent, container, viewport }).promise; }
      catch (error) { console.error(`Error rendering base text layer for page ${page.pageNumber}:`, error); container.innerHTML = ''; }
    }

    // --- Annotation Layer Rendering (Handles Image Links) ---
    async function renderAnnotationLayer(page, container, viewport) {
        if (!page || !container || !viewport) { console.warn("Skipping annotation layer: params missing."); return }
        container.innerHTML = ''; // Clear previous
        try {
            const annotations = await page.getAnnotations(); if (annotations.length === 0) return;
            pdfjsLib.AnnotationLayer.render({ viewport: viewport.clone({ dontFlip: true }), div: container, annotations: annotations, page: page, linkService: linkService });
            container.removeEventListener('click', handleAnnotationClick); // Remove old listener first
            container.addEventListener('click', handleAnnotationClick); // Add new listener
            const linkElements = container.querySelectorAll('.linkAnnotation > a');
            linkElements.forEach(link => { if (isLikelyImageURL(link.href)) { link.parentElement.classList.add('image-link'); } });
        } catch (error) { console.error(`Error rendering/processing annotation layer for page ${page.pageNumber}:`, error); container.innerHTML = ''; }
    }
    function handleAnnotationClick(event) { // Helper for Annotation Clicks
         const link = event.target.closest('a');
         if (link && link.parentElement.classList.contains('linkAnnotation')) {
             const url = link.href;
             if (isLikelyImageURL(url)) { event.preventDefault(); event.stopPropagation(); showLightbox(url); }
             // Allow normal link behavior otherwise (handled by SimpleLinkService or browser default)
         }
    }
    function isLikelyImageURL(url) { // Helper to check for image URLs
        if (!url || typeof url !== 'string') return false;
        return /\.(jpg|jpeg|png|gif|webp|bmp|svg)(\?.*)?(#.*)?$/i.test(url); // Updated regex for query/hash
    }

    // --- renderPage function ---
    async function renderPage(pageNum, canvasId) {
        const canvas = document.getElementById(canvasId); const ctx = canvas?.getContext('2d');
        const canvasContainer = canvas?.closest('.canvas-container');
        const textLayerContainer = canvasContainer?.querySelector('.textLayer');
        const annotationLayerContainer = canvasContainer?.querySelector('.annotationLayer');
        const keywordOverlayContainer = canvasContainer?.querySelector('.keyword-overlay-container');
        const pageElement = canvas?.closest('.book-page');

        // Clear previous state and layers
        delete currentViewports[canvasId];
        if (textLayerContainer) textLayerContainer.innerHTML = '';
        if (annotationLayerContainer) { annotationLayerContainer.innerHTML = ''; annotationLayerContainer.removeEventListener('click', handleAnnotationClick); }
        if (keywordOverlayContainer) keywordOverlayContainer.innerHTML = '';
        if (canvas && ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas preemptively

        // Validate necessary components and page number
        if (!book.pdfDocument || !canvas || !ctx || !canvasContainer || !textLayerContainer || !annotationLayerContainer || !keywordOverlayContainer || !pageElement || pageNum < 1 || pageNum > book.totalPages) {
            updateStatus(`RenderPage validation failed for page ${pageNum} on ${canvasId}. Marking as placeholder.`);
            if (pageElement) pageElement.classList.add('placeholder-page'); // Mark as placeholder if possible
            hidePageLoading(canvasId);
            return; // Exit if conditions aren't met
        }

        showPageLoading(canvasId);
        pageElement.classList.remove('placeholder-page'); // Ensure it's not marked as placeholder

        let page; let viewport;
        try {
            // --- Dimension Check ---
            // Get container dimensions AFTER showing loading/removing placeholder
            const containerStyle = getComputedStyle(canvasContainer);
            const availableWidth = parseFloat(containerStyle.width);
            const availableHeight = parseFloat(containerStyle.height);

            if (!availableWidth || availableWidth <= 0 || !availableHeight || availableHeight <= 0) {
                 console.warn(`Canvas container ${canvasId} for page ${pageNum} has zero or invalid dimensions (${availableWidth}x${availableHeight}). Aborting render.`);
                 pageElement?.classList.add('placeholder-page'); // Re-mark as placeholder
                 hidePageLoading(canvasId);
                 return; // Stop rendering if container isn't ready
            }
            updateStatus(`Container ${canvasId} dimensions: ${availableWidth}x${availableHeight}`);


            if (pageCache.has(pageNum)) { // Load from cache
                updateStatus(`Rendering page ${pageNum} from cache on ${canvasId}`);
                const cachedData = pageCache.get(pageNum);
                canvas.width = cachedData.width;
                canvas.height = cachedData.height;
                canvas.style.width = `${cachedData.styleWidth}px`;
                canvas.style.height = `${cachedData.styleHeight}px`;
                ctx.putImageData(cachedData.imageData, 0, 0);
                page = await book.pdfDocument.getPage(pageNum); // Still need page object for layers
                viewport = cachedData.viewport;
                currentViewports[canvasId] = viewport;
                // Move item to end of cache order (pseudo LRU)
                pageCache.delete(pageNum);
                pageCache.set(pageNum, cachedData);
                hidePageLoading(canvasId);
            } else { // Render new page
                updateStatus(`Rendering page ${pageNum} fresh on ${canvasId}`);
                page = await book.pdfDocument.getPage(pageNum);

                // Calculate viewport based on confirmed available dimensions
                const defaultViewport = page.getViewport({ scale: 1 });
                const scale = Math.min(availableWidth / defaultViewport.width, availableHeight / defaultViewport.height);
                viewport = page.getViewport({ scale: scale });
                currentViewports[canvasId] = viewport;
                updateStatus(`Calculated scale ${scale} for page ${pageNum} on ${canvasId}`);

                // Prepare canvas for rendering
                const outputScale = window.devicePixelRatio || 1;
                canvas.width = Math.floor(viewport.width * outputScale);
                canvas.height = Math.floor(viewport.height * outputScale);
                canvas.style.width = `${Math.floor(viewport.width)}px`;
                canvas.style.height = `${Math.floor(viewport.height)}px`;
                const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

                // Render the PDF page content
                await page.render({ canvasContext: ctx, transform: transform, viewport: viewport }).promise;
                updateStatus(`Canvas rendered for page ${pageNum} on ${canvasId}`);

                // Cache the rendered data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                pageCache.set(pageNum, { imageData, width: canvas.width, height: canvas.height, styleWidth: Math.floor(viewport.width), styleHeight: Math.floor(viewport.height), viewport });
                trimCache(); // Maintain cache size
                hidePageLoading(canvasId);
            }

            // Render auxiliary layers (Text, Annotations, Keywords) using the determined viewport
            updateStatus(`Rendering layers for page ${pageNum} on ${canvasId}`);
            await renderAndEnhanceTextLayer(page, textLayerContainer, viewport);
            await renderAnnotationLayer(page, annotationLayerContainer, viewport);
            await createKeywordOverlays(pageNum, pageElement, viewport);
            updateStatus(`Layers complete for page ${pageNum} on ${canvasId}`);

        } catch (error) {
            console.error(`Error rendering page ${pageNum} on ${canvasId}:`, error);
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas on error
            hidePageLoading(canvasId);
            pageElement?.classList.add('placeholder-page'); // Mark as placeholder on error
            delete currentViewports[canvasId]; // Clear viewport state on error
        }
    }


    // --- Update Display ---
    async function updateDisplay() {
        if (!book.pdfDocument) { updateStatus("UpdateDisplay skipped: No PDF loaded."); return; }

        // Ensure mobile always uses single page view internally
        const currentModeIsDouble = !isMobile && book.isDoublePageView;
        updateStatus(`Updating display. Mode: ${currentModeIsDouble ? 'Double' : 'Single'}. Current Page: ${book.currentPage}`);

        const leftPageNum = book.currentPage;
        const rightPageNum = currentModeIsDouble ? book.currentPage + 1 : 0; // 0 if single view

        const leftPageDiv = document.querySelector('.book-page.left');
        const rightPageDiv = document.querySelector('.book-page.right');
        const leftPageNumDisplay = document.getElementById('left-page-number');
        const rightPageNumDisplay = document.getElementById('right-page-number');

        if (!leftPageDiv || !rightPageDiv || !leftPageNumDisplay || !rightPageNumDisplay) {
            console.error("Critical page elements missing! Cannot update display.");
            return;
        }

        // Ensure correct visibility/display states based on mode FIRST
        leftPageDiv.style.visibility = 'visible'; // Assume left is always visible unless page doesn't exist
        if (currentModeIsDouble) {
             rightPageDiv.style.display = 'flex'; // Ensure right page container is potentially visible
        } else {
             rightPageDiv.style.display = 'none'; // Hide right page container in single view
        }
        applyCurrentViewModeStyles(); // Apply CSS classes/transforms

        // --- Render Left Page ---
        if (leftPageNum >= 1 && leftPageNum <= book.totalPages) {
            leftPageNumDisplay.textContent = String(leftPageNum);
            leftPageDiv.style.visibility = 'visible';
            await renderPage(leftPageNum, 'left-page-canvas');
        } else {
            // This case should ideally not happen if currentPage is managed well, but handle it defensively
            updateStatus(`Left page number ${leftPageNum} is out of bounds.`);
            leftPageDiv.style.visibility = 'hidden'; // Hide the left page element
            leftPageNumDisplay.textContent = '';
            // Manually clear canvas and layers if needed
             const lCanvas = document.getElementById('left-page-canvas'), lCtx = lCanvas?.getContext('2d');
             if (lCtx) lCtx.clearRect(0, 0, lCanvas.width, lCanvas.height);
             const lTextLayer = document.getElementById('left-text-layer'), lAnnLayer = document.getElementById('left-annotation-layer'), lKeywordOverlay = document.getElementById('left-keyword-overlay');
             if(lTextLayer) lTextLayer.innerHTML = '';
             if(lAnnLayer) { lAnnLayer.innerHTML = ''; lAnnLayer.removeEventListener('click', handleAnnotationClick); }
             if(lKeywordOverlay) lKeywordOverlay.innerHTML = '';
        }

        // --- Render Right Page (Only in Double Page View) ---
        if (currentModeIsDouble) {
            if (rightPageNum >= 1 && rightPageNum <= book.totalPages) {
                // Valid page number for the right side
                rightPageNumDisplay.textContent = String(rightPageNum);
                rightPageDiv.classList.remove('placeholder-page');
                rightPageDiv.style.display = 'flex'; // Ensure it's displayed
                await renderPage(rightPageNum, 'right-page-canvas');
            } else {
                // Reached end of book or only one page left, show placeholder
                updateStatus(`Right page number ${rightPageNum} is out of bounds. Showing placeholder.`);
                rightPageDiv.classList.add('placeholder-page');
                rightPageDiv.style.display = 'flex'; // Ensure placeholder is displayed
                rightPageNumDisplay.textContent = '';
                // Clear canvas/layers for the right page explicitly
                const rCanvas = document.getElementById('right-page-canvas'), rCtx = rCanvas?.getContext('2d');
                if (rCtx) rCtx.clearRect(0, 0, rCanvas.width, rCanvas.height);
                const rTextLayer = document.getElementById('right-text-layer'), rAnnLayer = document.getElementById('right-annotation-layer'), rKeywordOverlay = document.getElementById('right-keyword-overlay');
                if(rTextLayer) rTextLayer.innerHTML = '';
                if(rAnnLayer) { rAnnLayer.innerHTML = ''; rAnnLayer.removeEventListener('click', handleAnnotationClick); }
                if(rKeywordOverlay) rKeywordOverlay.innerHTML = '';
            }
        } else {
             // Single page view - ensure right page is hidden and clean
             rightPageDiv.style.display = 'none';
             rightPageDiv.classList.remove('placeholder-page');
             rightPageNumDisplay.textContent = '';
             // Optional: Clear right canvas/layers just in case
             const rCanvas = document.getElementById('right-page-canvas'), rCtx = rCanvas?.getContext('2d');
             if (rCtx) rCtx.clearRect(0, 0, rCanvas.width, rCanvas.height);
        }

        // Final UI updates
        updateSliderPosition();
        preloadAdjacentPages(book.currentPage);
        updateStatus("Display update complete.");
    }


    // --- Preloading ---
     function preloadAdjacentPages(currentPage) {
        if (!book.pdfDocument) return;
        const pagesToPreload = [];
        const isActuallyDouble = !isMobile && book.isDoublePageView;
        const lookahead = isActuallyDouble ? 2 : 1; // Look further ahead in double page

        // Preload next pages
        for (let i = 1; i <= lookahead; i++) {
            const nextPageOffset = isActuallyDouble ? i * 2 : i;
            const nextPage = currentPage + nextPageOffset;
            if (nextPage <= book.totalPages) {
                pagesToPreload.push(nextPage);
                // If double view, also preload the page next to the upcoming left page
                if (isActuallyDouble && (nextPage + 1) <= book.totalPages) {
                    pagesToPreload.push(nextPage + 1);
                }
            }
        }

        // Preload previous pages
        for (let i = 1; i <= lookahead; i++) {
            const prevPageOffset = isActuallyDouble ? i * 2 : i;
            const prevPage = currentPage - prevPageOffset;
            if (prevPage >= 1) {
                pagesToPreload.push(prevPage);
                // If double view, also preload the page next to the previous left page
                if (isActuallyDouble && (prevPage + 1) < currentPage && (prevPage + 1) >= 1) {
                    pagesToPreload.push(prevPage + 1);
                }
            }
        }

        // Filter out duplicates, current pages, and pages already cached
        const currentLeft = currentPage;
        const currentRight = isActuallyDouble ? currentPage + 1 : 0;
        const uniquePages = [...new Set(pagesToPreload)].filter(p =>
            p > 0 &&
            p <= book.totalPages &&
            p !== currentLeft &&
            p !== currentRight &&
            !pageCache.has(p)
        );

        if (uniquePages.length === 0) {
            // updateStatus("No new pages to preload.");
            return;
        }
        updateStatus(`Preloading pages: ${uniquePages.join(', ')}`);

        // Determine simulated dimensions for preloading render
        let simWidth, simHeight;
        const leftPageDiv = document.querySelector('.book-page.left .canvas-container');
        const spreadDiv = document.querySelector('.book-spread');

        if (leftPageDiv && spreadDiv && window.getComputedStyle(leftPageDiv).width !== 'auto' && window.getComputedStyle(leftPageDiv).height !== 'auto') {
             // Try to use current actual dimensions if available
             const style = getComputedStyle(leftPageDiv);
             simWidth = parseFloat(style.width);
             simHeight = parseFloat(style.height);
        } else {
             // Fallback estimations
             if (isMobile) {
                 simWidth = window.innerWidth - 10; // Approximation
                 simHeight = window.innerHeight - 10; // Approximation
             } else if (book.isDoublePageView) {
                 simWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w')) - (2 * PAGE_PADDING);
                 simHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h')) - (2 * PAGE_PADDING);
             } else { // Single page (fullscreen desktop)
                 simWidth = window.innerWidth * 0.95 - (2 * 10); // Approx 95vw - padding
                 simHeight = window.innerHeight * 0.95 - (2 * 10); // Approx 95vh - padding
             }
        }

        if (!simWidth || simWidth <= 0 || !simHeight || simHeight <= 0) {
            console.warn("Could not determine valid simulation dimensions for preloading. Skipping.");
            return;
        }
        // updateStatus(`Using preload dimensions: ${simWidth}x${simHeight}`);


        uniquePages.forEach(pageNum => {
            // Add a check to ensure we don't try preloading again if already started
            if (pageCache.has(pageNum) || document.body.dataset[`preloadingPage${pageNum}`] === 'true') {
                return;
            }
            document.body.dataset[`preloadingPage${pageNum}`] = 'true'; // Mark as preloading

            book.pdfDocument.getPage(pageNum).then(page => {
                const defaultViewport = page.getViewport({ scale: 1 });
                const scale = Math.min(simWidth / defaultViewport.width, simHeight / defaultViewport.height); // Ensure scale is calculated
                if (scale <= 0) {
                   console.warn(`Calculated preload scale is zero or negative for page ${pageNum}. Skipping.`);
                   delete document.body.dataset[`preloadingPage${pageNum}`];
                   return;
                }
                const viewport = page.getViewport({ scale: scale });

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const outputScale = window.devicePixelRatio || 1;
                tempCanvas.width = Math.floor(viewport.width * outputScale);
                tempCanvas.height = Math.floor(viewport.height * outputScale);

                // Check canvas dimensions before rendering
                 if (tempCanvas.width <= 0 || tempCanvas.height <= 0) {
                      console.warn(`Preload canvas dimensions are invalid for page ${pageNum} (${tempCanvas.width}x${tempCanvas.height}). Skipping.`);
                      delete document.body.dataset[`preloadingPage${pageNum}`];
                      return;
                 }

                const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

                page.render({ canvasContext: tempCtx, transform: transform, viewport: viewport }).promise.then(() => {
                    // Check again if already cached (e.g., user navigated quickly)
                    if (!pageCache.has(pageNum)) {
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        pageCache.set(pageNum, { imageData, width: tempCanvas.width, height: tempCanvas.height, styleWidth: Math.floor(viewport.width), styleHeight: Math.floor(viewport.height), viewport });
                        trimCache();
                        updateStatus(`Page ${pageNum} preloaded and cached.`);
                    }
                     delete document.body.dataset[`preloadingPage${pageNum}`]; // Unmark preloading
                }).catch(err => {
                     console.warn(`Preloading render failed for page ${pageNum}: ${err.message}`);
                     delete document.body.dataset[`preloadingPage${pageNum}`]; // Unmark preloading
                });
            }).catch(err => {
                console.warn(`Failed to get page ${pageNum} for preloading: ${err.message}`);
                delete document.body.dataset[`preloadingPage${pageNum}`]; // Unmark preloading
            });
        });
    }

    // --- Navigation ---
    function nextPage(){ const isActuallyDouble = !isMobile && book.isDoublePageView; const inc = isActuallyDouble ? 2 : 1; const targetPage = book.currentPage + inc; if (targetPage <= book.totalPages) { jumpToPage(targetPage); } else if (!isActuallyDouble && book.currentPage < book.totalPages) { jumpToPage(book.totalPages); } } // Allow going to last page in single view
    function prevPage(){ const isActuallyDouble = !isMobile && book.isDoublePageView; const dec = isActuallyDouble ? 2 : 1; const targetPage = book.currentPage - dec; if (targetPage >= 1) { jumpToPage(targetPage); } else if (book.currentPage > 1) { jumpToPage(1);} } // Allow going back to first page
    function jumpToPage(pageNum){ if (!book.pdfDocument || pageNum < 1 || pageNum > book.totalPages){ console.warn(`Jump to page ${pageNum} out of bounds (1-${book.totalPages})`); return } let targetPage = pageNum; // In double page view, ensure we jump to the left (odd) page of the spread
        // Unless it's the very first page which is allowed to be on the left.
        if (!isMobile && book.isDoublePageView && targetPage > 1 && targetPage % 2 === 0) { targetPage--; updateStatus(`Adjusted jump target to odd page ${targetPage} for double view.`); } if (targetPage === book.currentPage) { updateStatus(`Already on page ${targetPage}. No jump needed.`); return; } updateStatus(`Jumping to page ${targetPage}`); book.currentPage = targetPage; if (targetPage > user.readingProgress.furthestPage) user.readingProgress.furthestPage = targetPage; // Update furthest page
         hideDefinitionPopup(); hideLightbox(); updateDisplay(); // Render new page(s)
         showPageSlider(); // Show slider briefly on navigation
         manageToolbar(false); // Hide toolbar on navigation
     }

    // --- View Modes ---
    function applyCurrentViewModeStyles() {
        const spread = document.querySelector('.book-spread');
        if (!spread) return;
        // Ensure base transforms are set correctly for both modes
        spread.style.transform = 'translate(-50%, -50%)';
        spread.style.transformOrigin = 'center center';
        // CSS classes (.fullscreen-mode) handle the main layout differences now.
        // updateStatus("Applied base view mode styles."); // Reduced verbosity
    }

    // *** MODIFIED FUNCTION ***
    function setSinglePageView() {
        updateStatus("Setting Single Page View");
        book.isDoublePageView = false; // Set state
        document.body.classList.add('fullscreen-mode'); // Add class for CSS rules
        hideDefinitionPopup(); // Close popups
        hideLightbox();

        // *** FIX START: Add delay for CSS transitions/layout ***
        updateStatus("Adding short delay before applying styles and rendering...");
        setTimeout(() => {
            updateStatus("Delay complete. Applying styles and updating display for Single Page View.");
            applyCurrentViewModeStyles(); // Apply transforms etc. if needed after layout settles
            updateDisplay().then(() => { // Re-render pages based on new mode and dimensions
                // Update UI elements after display is updated
                manageToolbar(); // Show/hide toolbar appropriately
                updateSliderTotalPages(); // Slider max might change
                updateSliderPosition(); // Update thumb position
                updateStatus("Single Page View update complete.");
            }).catch(error => {
                 console.error("Error during updateDisplay after setting single page view:", error);
            });
        }, 100); // 100ms delay - adjust if layout issues persist on slow devices
        // *** FIX END ***
    }

    // *** MODIFIED FUNCTION ***
    function setDoublePageView() {
        if (isMobile) {
            console.warn("Double page view ignored on mobile.");
            // Ensure single page view state is consistent on mobile if called accidentally
            if (!document.body.classList.contains('fullscreen-mode')) {
                 setSinglePageView();
            }
            return;
        }
        // Check if already in double page view non-fullscreen
        if (book.isDoublePageView && !document.body.classList.contains('fullscreen-mode')) {
            updateStatus("Already in Double Page View (Desktop). No change.");
            return;
        }

        updateStatus("Setting Double Page View (Desktop)");
        book.isDoublePageView = true; // Set state
        document.body.classList.remove('fullscreen-mode'); // Remove class

        // Adjust current page if necessary (ensure left page is odd)
        if (book.currentPage > 1 && book.currentPage % 2 === 0) {
            updateStatus(`Adjusting current page from ${book.currentPage} to ${book.currentPage - 1} for double view.`);
            book.currentPage--; // Decrement to show the correct left page
        }

        hideDefinitionPopup(); // Close popups
        hideLightbox();

        // Delay usually not needed when switching TO double view,
        // as constraints are often being removed, but apply styles/update immediately.
        applyCurrentViewModeStyles();
        updateDisplay().then(() => {
            // Update UI elements after display is updated
            manageToolbar();
            updateSliderTotalPages();
            updateSliderPosition();
             updateStatus("Double Page View update complete.");
        }).catch(error => {
             console.error("Error during updateDisplay after setting double page view:", error);
        });
    }

    // --- UI Toggles (Unchanged) ---
    function toggleElement(id,show){const el = document.getElementById(id); if(el) el.classList.toggle('visible',show)}
    function showTableOfContents(){if(!document.getElementById('toc-btn')?.disabled){toggleElement('toc-panel',true);manageToolbar(false)}}
    function hideTableOfContents(){toggleElement('toc-panel',false)}
    function showLoading(msg='Processing...'){const lo=document.getElementById('loading-overlay'),lm=lo?.querySelector('.loading-message');if(lo&&lm){lm.textContent=msg;lo.classList.add('visible')}}
    function hideLoading(){toggleElement('loading-overlay',false)}

    // --- Slider Logic (Unchanged) ---
    function showPageSlider(){const s=document.getElementById('page-slider-container');if(s&&book.pdfDocument&&book.totalPages>0){s.classList.add('visible');resetSliderHideTimer()}}
    function hidePageSlider(){document.getElementById('page-slider-container')?.classList.remove('visible')}
    function resetSliderHideTimer(){clearTimeout(sliderHideTimeout);sliderHideTimeout=setTimeout(hidePageSlider,3500)}
    function initPageSlider(){ const s=document.getElementById('page-slider'),sc=document.getElementById('page-slider-container'); if(!s||!sc)return;let isDragging=!1; s.addEventListener('pointerdown', ()=>{ isDragging = true; clearTimeout(sliderHideTimeout); }); s.addEventListener('pointerup', ()=>{ isDragging = false; resetSliderHideTimer(); }); s.addEventListener('input',()=>{ const pageNum=parseInt(s.value,10), d=document.getElementById('current-page-display'); if(d){ let pageText = `Page ${pageNum}`; if (!isMobile && book.isDoublePageView && pageNum > 0 && pageNum + 1 <= book.totalPages) { pageText += `-${pageNum + 1}`; } d.textContent = pageText; } updateSliderStyle(s,pageNum); }); s.addEventListener('change',()=>{ if (!isDragging) { const targetPage = parseInt(s.value, 10); jumpToPage(targetPage); resetSliderHideTimer(); } }); sc.addEventListener('mouseenter',()=>clearTimeout(sliderHideTimeout)); sc.addEventListener('mouseleave',()=>{ if (!isDragging) resetSliderHideTimer() }); updateSliderTotalPages();updateSliderPosition(); }
    function updateSliderTotalPages(){const s=document.getElementById('page-slider'),d=document.getElementById('total-pages-display');if(s&&d){const t=book.totalPages>0?book.totalPages:1;s.max=t;d.textContent=t;updateSliderStyle(s,s.value)}}
    function updateSliderPosition(){ const s=document.getElementById('page-slider'),d=document.getElementById('current-page-display'); if(s&&d){ const currentPageNum=book.currentPage>0?book.currentPage:1, total=book.totalPages>0?book.totalPages:1; s.value=currentPageNum; let pageText=`Page ${currentPageNum}`; if (!isMobile && book.isDoublePageView && currentPageNum > 0 && currentPageNum+1<=total) { pageText+=`-${currentPageNum+1}`; } d.textContent=pageText; updateSliderStyle(s,currentPageNum); } }
    function updateSliderStyle(slider,value){if(!slider)return;const min=parseInt(slider.min||1),max=parseInt(slider.max||1),range=max>min?max-min:1,percent=(parseInt(value)-min)/range*100;slider.style.setProperty('--slider-percent',`${Math.max(0,Math.min(100,percent))}%`)}

    // --- Overlay Data Loading (Unchanged) ---
    async function loadOverlayData(pdfUrl) { const overlayUrl = pdfUrl.replace(/\.pdf$/i, '.overlay.json'); updateStatus(`Loading overlay: ${overlayUrl}`); try { const response = await fetch(overlayUrl); if (!response.ok) { console.warn(`Overlay fetch failed: HTTP ${response.status}`); keywordDefinitions = {}; pageKeywords = {}; return false; } const data = await response.json(); if (!data || typeof data.keywords !== 'object' || typeof data.pages !== 'object') { console.warn("Invalid overlay structure."); keywordDefinitions = {}; pageKeywords = {}; return false; } const processedKeywords = {}; for (const [key, value] of Object.entries(data.keywords)) { if (key && typeof value === 'string') { processedKeywords[key.toLowerCase()] = value; } else { console.warn(`Invalid keyword entry: Key='${key}'`) } } keywordDefinitions = processedKeywords; const processedPages = {}; for (const [pageNum, pageWords] of Object.entries(data.pages)) { if (pageNum && !isNaN(parseInt(pageNum)) && Array.isArray(pageWords) && pageWords.every(w => typeof w === 'string')) { processedPages[pageNum.toString()] = pageWords; } else { console.warn(`Invalid page entry: Page='${pageNum}'`); } } pageKeywords = processedPages; updateStatus(`Overlay loaded: ${Object.keys(keywordDefinitions).length} keywords, ${Object.keys(pageKeywords).length} pages.`); return true; } catch (error) { console.warn(`Overlay error for ${overlayUrl}: ${error.message}`); keywordDefinitions = {}; pageKeywords = {}; return false; } }

    // --- PDF Loading (Unchanged) ---
    async function loadPdf(pdfUrl) { updateStatus(`loadPdf started for: ${pdfUrl}`); showLoading("Initializing PDF..."); pageCache.clear(); currentViewports={}; keywordDefinitions={}; pageKeywords={}; if(book.pdfDocument){try{book.pdfDocument.destroy()}catch(e){console.warn("Error destroying previous PDF:", e)}} book.pdfDocument=null; book.totalPages=0; book.currentPage=1; book.title="No Document"; book.outline=[]; hideDefinitionPopup(); hideLightbox(); document.title = "Heritage History™ Reader"; const tocBtn = document.getElementById('toc-btn'); if(tocBtn) tocBtn.disabled = true; let filename = "Document"; try { filename = decodeURIComponent(pdfUrl.split('/').pop() || filename).replace(/\.pdf$/i, ''); } catch(e){} book.title = filename; try { updateStatus("Starting PDF loading..."); const loadingTask = pdfjsLib.getDocument(pdfUrl); const overlayPromise = loadOverlayData(pdfUrl); showLoading("Loading PDF document..."); book.pdfDocument = await loadingTask.promise; book.totalPages = book.pdfDocument.numPages; book.currentPage = 1; user.readingProgress.furthestPage = 1; updateStatus(`PDF loaded: ${book.title}, Pages: ${book.totalPages}`); document.title = `${book.title} - Heritage History™ Reader`; updateSliderTotalPages(); showLoading("Processing metadata..."); updateStatus("Fetching outline..."); try { book.outline = await book.pdfDocument.getOutline(); populateTOC(); } catch (outlineError) { console.warn("Could not get PDF outline:", outlineError); book.outline = []; populateTOC(); } await overlayPromise; // Determine initial view mode AFTER PDF and overlay data are ready
         if (isMobile) { setSinglePageView(); }
         else { if (window.innerWidth >= 1000) { setDoublePageView(); } // Default to double for large screens
              else { setSinglePageView(); } // Default to single for smaller desktop windows
         }
         // Initial display update is now handled within setSingle/DoublePageView
         // updateDisplay(); // No longer needed here, called by view mode functions

         } catch (error) { console.error("FATAL: Error loading PDF:", error); alert(`Failed to load PDF: ${error.message || error}`); book.pdfDocument=null; book.totalPages=0; book.currentPage=1; book.title="Error Loading"; book.outline=[]; keywordDefinitions={}; pageKeywords={}; document.title="Heritage History™ Reader - Error"; updateSliderTotalPages(); updateSliderPosition(); populateTOC(); const spreadContainer = document.querySelector('.main-container .book-spread'); if (spreadContainer) { spreadContainer.innerHTML = `<div style="color: red; background: white; padding: 30px; text-align: center; width: 100%; border: 1px solid red; border-radius: 5px;">Failed to load document: ${error.message}</div>`; } } finally { hideLoading(); updateStatus("loadPdf finished."); } }

    // --- TOC population (Unchanged) ---
    function populateTOC() { const tocList = document.getElementById('toc-list'), tocButton = document.getElementById('toc-btn'); if (!tocList || !tocButton) return; tocList.innerHTML = ''; tocButton.disabled = true; if (!book.outline || book.outline.length === 0) { tocList.innerHTML = '<em>No table of contents found.</em>'; return; } const createTocItem = (item, level = 0) => { const d = document.createElement('div'); d.className = level === 0 ? 'toc-chapter' : 'toc-section'; const s = document.createElement('span'); s.className = level === 0 ? 'toc-chapter-title' : ''; s.textContent = item.title || 'Untitled'; s.style.cursor = 'pointer'; s.title = `Go to: ${item.title||'Untitled'}`; s.onclick = async (e) => { e.preventDefault(); try { let pageIndex = -1; if (item.dest === null || typeof item.dest === 'undefined') { console.warn("TOC item destination is null/undefined:", item); return; // Cannot navigate } // Handle string destinations (named destinations)
                    if (typeof item.dest === 'string') { const destArray = await book.pdfDocument.getDestination(item.dest); if (destArray && destArray[0]) { pageIndex = await book.pdfDocument.getPageIndex(destArray[0]); } } // Handle array destinations (direct page references)
                    else if (Array.isArray(item.dest) && item.dest[0]) { // item.dest[0] should be the page reference object
                         pageIndex = await book.pdfDocument.getPageIndex(item.dest[0]); }
                    else { console.warn("Unknown or unhandled TOC destination type:", item.dest); } if (pageIndex >= 0) { jumpToPage(pageIndex + 1); // PDF page indices are 0-based, jumpToPage expects 1-based
                         hideTableOfContents(); } else { throw new Error(`Could not resolve page index for TOC item: ${item.title}`); } } catch (navError) { console.error("TOC navigation error:", navError); alert(`Navigation failed: ${navError.message}`); } }; d.appendChild(s); if (item.items && item.items.length > 0) { const sub = document.createElement('div'); if (level === 0) sub.className = 'toc-sections'; else sub.style.paddingLeft = '15px'; item.items.forEach(subItem => { const subEl = createTocItem(subItem, level + 1); if (subEl) sub.appendChild(subEl); }); if (sub.hasChildNodes()) d.appendChild(sub); } return d; }; book.outline.forEach(topItem => { const tocEl = createTocItem(topItem); if (tocEl) tocList.appendChild(tocEl); }); if (tocList.hasChildNodes()) tocButton.disabled = false; else tocList.innerHTML = '<em>Error processing TOC data.</em>'; }

    // --- Popup Handling Functions (Unchanged) ---
    function showDefinitionPopup(word, definition, clickLeft, clickBottom, clickTop) { if (!definitionPopup || !popupWord || !popupDefinition || !closePopupBtn) return; popupWord.textContent = word; popupDefinition.innerHTML = definition || `<span class="error-message">Definition not available.</span>`; popupDefinition.scrollTop = 0; // Reset scroll
        const popupRect = definitionPopup.getBoundingClientRect(); const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; const margin = 10; // Min distance from viewport edge
        // Use current computed dimensions or estimate if hidden
        const estWidth = definitionPopup.offsetWidth > 0 ? definitionPopup.offsetWidth : Math.min(viewportWidth * 0.8, 320); const estHeight = definitionPopup.offsetHeight > 0 ? definitionPopup.offsetHeight : Math.min(viewportHeight * 0.5, 250); // Use actual height if visible, else estimate
        const clickCenterX = clickLeft + 5; // Position relative to click point
        // Try positioning above first
        let posY = clickTop - estHeight - 10; // 10px gap above
        let transformOrigin = 'bottom center';
         // If positioning above goes off-screen, position below
         if (posY < margin) { posY = clickBottom + 10; // 10px gap below
             transformOrigin = 'top center'; }
        // Ensure it doesn't go off bottom edge either
        if (posY + estHeight > viewportHeight - margin) { posY = viewportHeight - estHeight - margin; // Place at bottom edge
             // If it was initially positioned below, keep top origin, otherwise (if forced down from top), keep bottom origin
             transformOrigin = (clickBottom + 10 + estHeight > viewportHeight - margin) ? 'top center' : 'bottom center';
        }
        // Adjust horizontal position
        let posX = clickCenterX - (estWidth / 2);
        if (posX < margin) { posX = margin; }
        else if (posX + estWidth > viewportWidth - margin) { posX = viewportWidth - estWidth - margin; }
         definitionPopup.style.left = `${Math.round(posX)}px`; definitionPopup.style.top = `${Math.round(posY)}px`; definitionPopup.style.transformOrigin = transformOrigin; definitionPopup.classList.add('visible'); }
    function hideDefinitionPopup() { if (definitionPopup) { definitionPopup.classList.remove('visible'); } }

    // --- Image Lightbox Functions (Unchanged) ---
    function showLightbox(imageUrl) { if (!imageLightbox || !lightboxImage) return; updateStatus(`Showing lightbox for: ${imageUrl}`); lightboxImage.src = imageUrl; imageLightbox.classList.add('visible'); }
    function hideLightbox() { if (imageLightbox && imageLightbox.classList.contains('visible')) { updateStatus("Hiding lightbox"); imageLightbox.classList.remove('visible'); lightboxImage.src = ""; } }

    // --- Event Setup (MODIFIED for new buttons) ---
    function setupEvents() {
        updateStatus("Setting up events");
        const toolbar = document.getElementById('new-toolbar');
        const mainContainer = document.querySelector('.main-container');
        const bookSpread = mainContainer?.querySelector('.book-spread');

        // --- Toolbar Button Clicks (Using Delegation) ---
        toolbar?.addEventListener('click', e => {
            const button = e.target.closest('button'); // Find the clicked button element
            if (!button || button.disabled) return; // Exit if click wasn't on or inside an enabled button

            const id = button.id;
            let hideToolbar = true; // Hide toolbar after most actions

            switch (id) {
                case 'exit-btn':
                    if (window.history.length > 1) { window.history.back(); }
                    else { console.warn("No history to go back to."); /* Optionally close window or redirect */ }
                    hideToolbar = false; // Don't hide toolbar immediately when exiting
                    break;
                case 'single-page-btn':
                    setSinglePageView();
                    break;
                case 'double-page-btn':
                    setDoublePageView(); // Ignored on mobile by the function itself
                    break;
                case 'toc-btn':
                    showTableOfContents();
                    hideToolbar = false; // Keep toolbar potentially visible when opening TOC
                    break;
                case 'time-capsule-btn':
                    console.log("Time Capsule button clicked!"); // Placeholder action
                    alert("Time Capsule feature not yet implemented.");
                     hideToolbar = false; // Maybe keep toolbar open for this?
                    break;
                default:
                     updateStatus(`Unknown button clicked: #${id}`);
                     hideToolbar = false; // Don't hide toolbar if it wasn't a recognized button ID
                     break;
            }

            resetSliderHideTimer(); // Keep slider visible after interaction
            if (hideToolbar) {
                toolbarHover = false;
                manageToolbar(false); // Hide toolbar after click
            }
        });

        // --- Modal Closes ---
        document.getElementById('close-toc-btn')?.addEventListener('click', hideTableOfContents);
        closePopupBtn?.addEventListener('click', hideDefinitionPopup);
        closeLightboxBtn?.addEventListener('click', hideLightbox);
        imageLightbox?.addEventListener('click', (e) => { if (e.target === imageLightbox) hideLightbox(); }); // Click background to close lightbox

        // --- Page Navigation (Edges) ---
        bookSpread?.addEventListener('click', e => {
             if (e.target.classList.contains('page-edge-nav')) {
                 const pageDiv = e.target.closest('.book-page');
                 if (!pageDiv || pageDiv.classList.contains('placeholder-page')) return; // Ignore clicks on placeholder edges
                  if (e.target.classList.contains('page-edge-left')) {
                      prevPage();
                  } else if (e.target.classList.contains('page-edge-right')) {
                      nextPage();
                  }
                  showPageSlider();
                  manageToolbar(false);
             }
        });

        // --- Keyboard Navigation ---
        document.addEventListener('keydown', e => {
            // Ignore keydown if focus is inside an input/textarea or a modal is open
             if (document.getElementById('toc-panel')?.classList.contains('visible') || imageLightbox?.classList.contains('visible') || definitionPopup?.classList.contains('visible') || document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                  if (e.key === 'Escape') {
                       if (imageLightbox?.classList.contains('visible')) { hideLightbox(); e.preventDefault(); e.stopPropagation(); }
                       else if (definitionPopup?.classList.contains('visible')) { hideDefinitionPopup(); e.preventDefault(); e.stopPropagation(); }
                       else if (document.getElementById('toc-panel')?.classList.contains('visible')) { hideTableOfContents(); e.preventDefault(); e.stopPropagation(); }
                  }
                  return;
             }
             // Ignore if modifier keys are pressed (except for potential future shortcuts)
             if (e.ctrlKey || e.altKey || e.metaKey) return;

             let navAction = false;
             switch(e.key){
                 case 'ArrowRight':
                 case 'PageDown':
                      nextPage(); navAction = true; break;
                 case 'ArrowLeft':
                 case 'PageUp':
                      prevPage(); navAction = true; break;
                 case 'Home':
                      if(book.pdfDocument && book.totalPages > 0) jumpToPage(1); navAction = true; break;
                 case 'End':
                      if(book.pdfDocument && book.totalPages > 0) jumpToPage(book.totalPages); navAction = true; break;
                 case 'Escape': // Added Escape to close popups even if not focused
                     if (definitionPopup?.classList.contains('visible')) { hideDefinitionPopup(); navAction = true; }
                     else if (imageLightbox?.classList.contains('visible')) { hideLightbox(); navAction = true; }
                     break;
             }
             if(navAction){
                 e.preventDefault(); // Prevent default browser scroll behavior
                 e.stopPropagation();
                 if (e.key !== 'Escape') { // Don't show slider just for closing a popup
                    showPageSlider();
                    manageToolbar(false);
                 }
             }
        });

        // --- Resize Handling ---
        window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>{ updateStatus("Resize detected."); const oldMobileState = isMobile; isMobile = isMobileDevice(); let viewModeChanged = false; if (oldMobileState !== isMobile) { updateStatus(`Device type changed: ${oldMobileState ? 'Mobile' : 'Desktop'} -> ${isMobile ? 'Mobile' : 'Desktop'}`); document.body.classList.toggle('mobile-device', isMobile); // Update body class immediately
                 PAGE_PADDING = isMobile ? 5 : 15; // Update padding variable
                 buildToolbar(); // Rebuild toolbar for new device type
                 setupToolbarHover(); // Re-attach hover listeners to new toolbar/trigger
                 initPageSlider(); // Re-initialize slider (might change orientation)
                 viewModeChanged = true; } // Determine target view mode after potential device change
             if (isMobile) { // Force single page on mobile regardless of window size
                 if (!document.body.classList.contains('fullscreen-mode') || !book.isDoublePageView === false) { // Check if not already single
                      setSinglePageView(); viewModeChanged = true; } } else { // Desktop logic based on width
                  const shouldBeDouble = window.innerWidth >= 1000; if (shouldBeDouble && (!book.isDoublePageView || document.body.classList.contains('fullscreen-mode'))) { setDoublePageView(); viewModeChanged = true; } else if (!shouldBeDouble && (book.isDoublePageView || !document.body.classList.contains('fullscreen-mode'))) { setSinglePageView(); viewModeChanged = true; } } // If the view mode wasn't changed by the logic above, force a redraw anyway
             if (!viewModeChanged) { hideDefinitionPopup(); hideLightbox(); applyCurrentViewModeStyles(); // Reapply styles for current mode
                  updateDisplay(); // Redraw content for new size
                  manageToolbar(); // Ensure toolbar visibility is correct
             } }, 250); });

        // --- Touch Swipe Navigation (Unchanged) ---
        let touchStartX=0, touchStartY=0, touchStartTime=0; const SWIPE_MIN_X = 50, SWIPE_MAX_Y = 70, SWIPE_MAX_TIME = 500; document.body.addEventListener('touchstart', e => { // Ignore swipes starting on interactive elements
             if (e.target.closest('#new-toolbar, .toolbar-trigger-area, #page-slider-container, #page-slider-trigger-zone, .toc-panel, .page-edge-nav, .new-btn, button, input, a, #definition-popup, #image-lightbox, .keyword-highlight, .annotationLayer section')){ touchStartX=0; touchStartY=0; return; } if (e.touches.length === 1) { touchStartX = e.touches[0].screenX; touchStartY = e.touches[0].screenY; touchStartTime = Date.now(); } else { // Reset if multi-touch
                  touchStartX = 0; touchStartY = 0; } }, {passive:true}); document.body.addEventListener('touchend', e => { if (touchStartX === 0 && touchStartY === 0) return; // Swipe didn't start properly
             if (e.changedTouches.length === 1) { const touchEndX = e.changedTouches[0].screenX; const touchEndY = e.changedTouches[0].screenY; const timeElapsed = Date.now() - touchStartTime; if (timeElapsed < SWIPE_MAX_TIME) { const deltaX = touchEndX - touchStartX; const deltaY = touchEndY - touchStartY; const absX = Math.abs(deltaX); const absY = Math.abs(deltaY); if (absX > SWIPE_MIN_X && absY < SWIPE_MAX_Y) { // Horizontal swipe detected
                      if (deltaX > 0) { prevPage(); } // Swipe right (prev)
                      else { nextPage(); } // Swipe left (next)
                      showPageSlider(); manageToolbar(false); } } } // Reset touch start points
             touchStartX = 0; touchStartY = 0; touchStartTime = 0; });

        // --- Slider Trigger Zone Hover (Unchanged) ---
        const sliderTriggerZone=document.getElementById('page-slider-trigger-zone'), sliderContainer=document.getElementById('page-slider-container'); if(sliderTriggerZone && sliderContainer){ const enterTrigger=()=>{ if(book.pdfDocument&&book.totalPages>0){ showPageSlider(); clearTimeout(sliderHideTimeout); } }; const leaveTrigger= e =>{ const related = e.relatedTarget; // Don't hide if moving between trigger and slider itself
             if(!sliderContainer.contains(related) && !sliderTriggerZone.contains(related)){ resetSliderHideTimer(); } }; sliderTriggerZone.addEventListener('mouseenter', enterTrigger); sliderContainer.addEventListener('mouseenter', ()=>clearTimeout(sliderHideTimeout)); // Keep open if mouse enters slider
             sliderTriggerZone.addEventListener('mouseleave', leaveTrigger); sliderContainer.addEventListener('mouseleave', resetSliderHideTimer); // Hide after leaving slider
         }

        // --- Click Outside Definition Popup (Unchanged) ---
        document.addEventListener('click', e => { if (definitionPopup.classList.contains('visible') && !definitionPopup.contains(e.target) && !e.target.closest('.keyword-highlight')) { hideDefinitionPopup(); } }, true); // Use capture phase

        updateStatus("Events setup complete");
    }

    // --- Build Toolbar Dynamically ---
    function buildToolbar() {
         const toolbarContainer = document.getElementById('new-toolbar');
         if (!toolbarContainer) return;

         // Start with Exit button (Always present)
         let buttonsHTML = `
            <button class="new-btn" id="exit-btn" title="Exit Reader">←</button>
         `; // Unicode Left Arrow

         // Add View Mode buttons based on device type
         if (isMobile) {
              // Mobile only needs Single Page toggle (implicitly always single)
              // Could potentially have a 'fit width/height' toggle here instead if desired
              // For now, just add the single page button, it won't do much but shows the state
              buttonsHTML += `
                 <button class="new-btn" id="single-page-btn" title="Single Page View">☰</button>
              `;
         } else {
             // Desktop gets both view mode buttons
             buttonsHTML += `
                <button class="new-btn" id="single-page-btn" title="Single Page View (Fullscreen)">☰</button> <!-- Single Bar = Fullscreen -->
                <button class="new-btn" id="double-page-btn" title="Double Page View (Standard)">◫</button> <!-- Double Bar = Spread -->
             `;
         }

         // Add TOC button (Always present, disabled initially)
         buttonsHTML += `<button class="new-btn" id="toc-btn" title="Table of Contents" disabled>📑</button>`; // Document with lines icon

         // Add Time Capsule button (Always present)
         // Using Font Awesome Unicode for clock: f017 -> \f017. Needs appropriate font-family support or replace with SVG/image.
         // Placeholder character if font doesn't load: 
         // Let's use a simpler unicode clock: 🕒 (U+1F552) or ⏰ (U+23F0)
         buttonsHTML += `
            <button class="circle-capsule-btn" id="time-capsule-btn" title="Time Capsule">
                <span class="icon">🕒</span> <!-- Clock icon -->
            </button>
         `;

         toolbarContainer.innerHTML = buttonsHTML;
         updateStatus(`Toolbar built for ${isMobile ? 'Mobile' : 'Desktop'}`);

         // Re-apply active state based on current view mode? (Optional visual feedback)
         if (document.body.classList.contains('fullscreen-mode')) {
              toolbarContainer.querySelector('#single-page-btn')?.classList.add('active'); // Add an 'active' class if needed
         } else {
              toolbarContainer.querySelector('#double-page-btn')?.classList.add('active');
         }
    }


    // --- Initialization ---
    async function init() {
        updateStatus("Initializing application...");
        try {
            isMobile = isMobileDevice(); document.body.classList.toggle('mobile-device', isMobile); updateStatus(`Detected device type: ${isMobile ? 'Mobile' : 'Desktop'}`);
            PAGE_PADDING = isMobile ? 5 : 15; // Set initial padding based on device
            document.documentElement.style.setProperty('--page-padding', `${PAGE_PADDING}px`); // Set CSS variable

            buildToolbar(); // Build toolbar based on initial device type
            setupEvents(); // Setup all event listeners (uses delegation for toolbar)
            setupToolbarHover(); // Setup hover logic for the toolbar
            initPageSlider(); // Setup the page slider functionality
            hideLoading(); // Ensure loading overlay is hidden initially

            const urlParams = new URLSearchParams(window.location.search); const pdfUrlParam = urlParams.get('pdf');
            if (pdfUrlParam) { updateStatus(`PDF URL parameter found: ${pdfUrlParam}`); await loadPdf(pdfUrlParam); }
            else { // No PDF specified - show placeholder message
                 updateStatus("No PDF specified. Displaying placeholder message.");
                 const spreadContainer = document.querySelector('.main-container .book-spread');
                 if(spreadContainer) {
                      spreadContainer.innerHTML = `<div style="color: var(--text-on-dark); background: rgba(28,37,54,.8); border-radius: 8px; padding: 40px; text-align: center; max-width: 500px; margin: auto; font-family: var(--font-sans);"><h2>Interactive Reader</h2><p style="margin-top: 15px;">To load a book, add <code>?pdf=URL_TO_YOUR_PDF</code> to the end of the current web address.</p></div>`;
                 }
                 // Hide page elements that don't make sense without a PDF
                 document.querySelector('.book-page.left')?.style.setProperty('visibility','hidden');
                 document.querySelector('.book-page.right')?.style.setProperty('display','none');
                 document.getElementById('page-slider-container')?.classList.remove('visible');
                 document.getElementById('new-toolbar')?.classList.remove('visible'); // Keep toolbar hidden if no PDF
            }

            // Cleanup on unload
            window.addEventListener('beforeunload', () => { updateStatus("Unloading - Performing cleanup."); pageCache.clear(); // Clear page cache
                 if (book.pdfDocument) { try { book.pdfDocument.destroy(); updateStatus("Destroyed PDF document object."); } catch(e){ console.warn("Error destroying PDF document on unload:", e); } book.pdfDocument = null; } });

            updateStatus("Initialization complete.");

        } catch (initError) {
             console.error("FATAL: Initialization failed:", initError);
             document.body.innerHTML = `<div style="color: red; background: white; padding: 20px; border: 2px solid red; font-family: monospace; white-space: pre-wrap;"><h2>Application Initialization Error</h2><p>The reader could not start correctly.</p><pre>Error Details:\n${initError.stack || initError}</pre></div>`;
        }
    }

    // --- Start the application ---
    document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
