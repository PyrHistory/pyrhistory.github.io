<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heritage History™ - Digital Book Reader</title>
    <!-- Use PDF.js v3.4.120 as specified -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf_viewer.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf_viewer.css">
    <style>
:root{--primary:#4a90e2;--secondary:#50e3c2;--accent:#f5a623;--lab-blue:#080e1c;--page:#fff;--text-on-dark:rgba(255,255,255,.9);--text-on-page:#333;--header-h:60px;--page-w:650px;--page-h:842px;--page-padding:15px}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Georgia',serif;background-color:var(--lab-blue);color:var(--text-on-dark);height:100vh;width:100vw;overflow:hidden;display:flex;flex-direction:column;position:fixed;line-height:1.6}
body::before{content:'';position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;background-image:radial-gradient(circle at 15% 15%,rgba(249,115,22,.12) 0,transparent 45%),radial-gradient(circle at 85% 85%,rgba(197,83,235,.12) 0,transparent 45%),radial-gradient(circle at 85% 15%,rgba(56,189,248,.05) 0,transparent 40%),radial-gradient(circle at 15% 85%,rgba(251,191,36,.08) 0,transparent 40%);animation:ambient-shift 30s ease infinite alternate}
@keyframes ambient-shift{0%{background-position:0 0,0 0,0 0,0 0}100%{background-position:5% 10%,-5% -5%,10% -5%,-10% 5%}}
@media (prefers-reduced-motion:reduce){body::before{animation:none!important}}
#new-toolbar{position:fixed!important;top:15px!important;right:-60px!important;z-index:9999!important;display:flex!important;flex-direction:column!important;gap:10px!important;transition:right .3s ease,bottom .3s ease,transform .3s ease!important;background:rgba(28,37,54,.9)!important;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);padding:5px!important;border-radius:8px 0 0 8px!important;box-shadow:-2px 2px 10px rgba(0,0,0,.4)!important;width:58px;border:1px solid rgba(255,255,255,.1)}
#new-toolbar::before{content:"≡";position:absolute;left:-25px;top:50%;transform:translateY(-50%);background:rgba(28,37,54,.9);backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);width:25px;height:40px;display:flex;align-items:center;justify-content:center;border-radius:4px 0 0 4px;color:var(--text-on-dark);font-size:20px;box-shadow:-2px 2px 5px rgba(0,0,0,.3);transition:all .3s ease;border:1px solid rgba(255,255,255,.1);border-right:none;cursor:pointer}
.toolbar-trigger-area{position:fixed;top:0;right:0;width:30px;height:100%;z-index:9998;transition:all .3s ease}
#new-toolbar.visible{right:0!important;transform:none!important}
.new-btn{background:rgba(44,62,80,.8)!important;border:1px solid rgba(255,255,255,.15)!important;color:var(--text-on-dark)!important;width:48px!important;height:48px!important;border-radius:4px!important;display:flex!important;align-items:center!important;justify-content:center!important;font-size:25px!important;cursor:pointer!important;transition:all .2s!important;box-shadow:0 2px 5px rgba(0,0,0,.2)!important;user-select:none!important;flex-shrink:0}
.new-btn:hover{background:rgba(52,73,94,.9)!important;border-color:rgba(255,255,255,.25)!important;box-shadow:0 2px 8px rgba(0,0,0,.3)!important;transform:translateY(-2px)!important}
.new-btn:active{transform:translateY(1px)!important}
.new-btn[disabled]{opacity:.5;cursor:not-allowed;pointer-events:none}
.rotated-mode #new-toolbar{top:auto!important;right:50%!important;bottom:-60px!important;transform:translateX(50%)!important;flex-direction:row!important;width:auto!important;height:58px!important;background:rgba(28,37,54,.9)!important;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);border-radius:8px 8px 0 0!important;padding:5px 10px!important;box-shadow:0 -2px 10px rgba(0,0,0,.4)!important;border:1px solid rgba(255,255,255,.1);border-bottom:none}
.rotated-mode #new-toolbar.visible{bottom:0!important;transform:translateX(50%)!important}
.rotated-mode #new-toolbar::before{left:50%!important;transform:translateX(-50%)!important;top:-25px!important;width:40px!important;height:25px!important;background:rgba(28,37,54,.9);backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);border-radius:4px 4px 0 0!important;content:"≡";padding-bottom:5px;color:var(--text-on-dark);border:1px solid rgba(255,255,255,.1);border-bottom:none;cursor:pointer}
.rotated-mode .toolbar-trigger-area{top:auto!important;bottom:0!important;left:0!important;transform:none!important;right:auto!important;width:100%!important;height:30px!important}
.rotated-mode #new-toolbar .new-btn{width:40px!important;height:40px!important;font-size:20px!important;transform: rotate(90deg)}
.rotated-mode .new-btn:hover {transform: rotate(90deg) scale(1.1);background:rgba(52,73,94,.9)!important;border-color:rgba(255,255,255,.25)!important;box-shadow:0 2px 8px rgba(0,0,0,.3)!important}
.rotated-mode .new-btn:active {transform: rotate(90deg) scale(0.95)}
.main-container{flex:1;display:flex;justify-content:center!important;align-items:center!important;padding:0;height:100%;width:100%;overflow:hidden;position:relative;background:transparent}
.book-spread{display:flex;box-shadow:0 10px 35px rgba(0,0,0,.5);position:fixed!important;top:50%!important;left:50%!important;transform-origin:center center;width:auto!important;height:auto!important;transition:transform .3s ease; transform: translate(-50%, -50%)}
.book-page{width:var(--page-w);height:var(--page-h);background-color:var(--page);position:relative;overflow:hidden; flex-shrink:0;display:flex;justify-content:center;align-items:center;border:1px solid rgba(255,255,255,.08);padding:0;}
.book-page.left{border-right:1px solid rgba(255,255,255,.15);border-radius:3px 0 0 3px}
.book-page.right{border-left:1px solid rgba(255,255,255,.15);border-radius:0 3px 3px 0}
.fullscreen-mode:not(.rotated-mode) .book-page.left{border-right:1px solid rgba(255,255,255,.08)!important}
.canvas-container {
    position: relative; /* Important for positioning layers */
    width: calc(100% - 2 * var(--page-padding));
    height: calc(100% - 2 * var(--page-padding));
    margin: var(--page-padding);
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden; /* Clip layers */
}
.pdf-canvas{max-width:100%;max-height:100%;display:block;object-fit:contain;box-shadow: none; position: absolute; top: 0; left: 0; z-index: 1; } /* Canvas layer */
.page-number{display:none}
.page-loading-overlay{position:absolute;inset:var(--page-padding);background:rgba(255,255,255,.6);z-index:50;display:none;justify-content:center;align-items:center;border-radius:3px}
.page-loading-spinner{width:32px;height:32px;border-radius:50%;border:3px solid rgba(0,0,0,.1);border-top-color:var(--primary);animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.page-edge-nav{position:absolute;top:0;height:100%;width:50px;cursor:pointer;z-index:10;transition:background-color .2s;-webkit-tap-highlight-color:transparent}
.page-edge-nav:hover{background-color:rgba(0,0,0,.03)}
.page-edge-left{left:0;border-radius:3px 0 0 3px}
.page-edge-right{right:0;border-radius:0 3px 3px 0}
.page-edge-left:hover::after,.page-edge-right:hover::after{content:"";position:absolute;top:50%;width:12px;height:12px;border-style:solid;border-color:rgba(0,0,0,.6);border-width:2px 2px 0 0;opacity:.8}
.page-edge-left:hover::after{left:18px;transform:translateY(-50%) rotate(-135deg)}
.page-edge-right:hover::after{right:18px;transform:translateY(-50%) rotate(45deg)}
.fullscreen-mode .book-page.right{display:none!important}
.fullscreen-mode .book-page.left{max-width:95vw;max-height:95vh;width:auto;height:auto;border-radius:5px!important;display:flex;justify-content:center;align-items:center;border:1px solid rgba(255,255,255,.08)!important;padding:0;}
.fullscreen-mode .canvas-container { margin: var(--page-padding); }
.fullscreen-mode .pdf-canvas{max-width:100%;max-height:100%;object-fit:contain; position:relative; z-index: 1; }
.rotated-mode .book-page.left{width:var(--page-w)!important;height:var(--page-h)!important;border-radius:0!important;border:none!important;padding:0 !important;background-color:var(--page);display:flex;justify-content:center;align-items:center}
.rotated-mode .canvas-container { margin: 10px !important; width: calc(100% - 20px); height: calc(100% - 20px); }
.rotated-mode .book-page.right{display:none!important}
.rotated-mode .pdf-canvas{box-shadow:none;max-width:100%;max-height:100%;object-fit:contain; position: relative; z-index: 1;}
body:not(.fullscreen-mode):not(.rotated-mode) .book-page{width:var(--page-w);height:var(--page-h)}
.book-page.right.placeholder-page{background-color:var(--page)!important;border-left:1px solid rgba(0,0,0,.1);position:relative;display:flex!important;justify-content:center;align-items:center}
.book-page.right.placeholder-page::after{content:"End of document";font-size:14px;font-style:italic;color:rgba(0,0,0,.5)}
.book-page.right.placeholder-page .canvas-container,.book-page.right.placeholder-page .page-edge-nav,.book-page.right.placeholder-page .page-loading-overlay{display:none}
body:not(.fullscreen-mode):not(.rotated-mode) .book-page.left .canvas-container::after { content: ''; position: absolute; top: 0; right: calc(0px - var(--page-padding)); width: 15px; height: 100%; background: linear-gradient(to left, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0)); pointer-events: none; z-index: 5; border-radius: 0 2px 2px 0; }
body:not(.fullscreen-mode):not(.rotated-mode) .book-page.right:not(.placeholder-page) .canvas-container::before { content: ''; position: absolute; top: 0; left: calc(0px - var(--page-padding)); width: 15px; height: 100%; background: linear-gradient(to right, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0)); pointer-events: none; z-index: 5; border-radius: 2px 0 0 2px; }
body:not(.fullscreen-mode):not(.rotated-mode) .book-page.right.placeholder-page { border-left: 1px solid rgba(0,0,0,.1) !important; }
.toc-panel{position:fixed;z-index:10000;display:none;color:var(--text-on-page); left:50%;top:50%;transform:translate(-50%,-50%);width:90%;max-width:500px;height:80vh;background:#f0f4f8;border-radius:8px;box-shadow:0 5px 25px rgba(0,0,0,.5);flex-direction:column;overflow:hidden}
.toc-panel.visible,.loading-overlay.visible{display:flex!important}
.toc-header{padding:15px 20px;background:var(--primary);color:#fff;font-weight:700;display:flex;justify-content:space-between;align-items:center;flex-shrink:0}
.toc-header .notes-close{background:none;border:none;color:#fff;font-size:24px;cursor:pointer;padding:0 5px;line-height:1}
.toc-content{flex:1;padding:10px 20px;overflow-y:auto}
.toc-chapter{padding:8px 0;border-bottom:1px solid #d8dfe6}
.toc-chapter-title{font-weight:700;color:var(--primary);cursor:pointer;padding:5px 0}
.toc-chapter-title:hover,.toc-section:hover{color:var(--accent)}
.toc-sections{padding-left:20px;margin-top:5px}
.toc-section{padding:4px 0;cursor:pointer;color:#4a5568;font-size:.95em}
.loading-overlay{position:fixed;inset:0;background:rgba(8,14,28,.85);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);z-index:10001;display:none;justify-content:center;align-items:center;flex-direction:column}
.loading-spinner{width:50px;height:50px;border-radius:50%;border:4px solid rgba(255,255,255,.2);border-top-color:var(--accent);animation:spin 1s linear infinite;margin-bottom:15px}
.loading-message{font-size:16px;color:var(--text-on-dark)}
#status-indicator{display:none}
.page-slider-container{position:fixed;bottom:-80px;left:50%;transform:translateX(-50%);width:90%;max-width:700px;padding:14px 20px;background:rgba(28,37,54,.9);backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);border:1px solid rgba(255,255,255,.1);border-bottom:none;box-shadow:0 -4px 20px rgba(0,0,0,.4);display:flex;flex-direction:column;align-items:center;z-index:9998;transition:bottom .35s cubic-bezier(.2,.9,.3,1),transform .35s cubic-bezier(.2,.9,.3,1), left .35s cubic-bezier(.2,.9,.3,1);border-radius:16px 16px 0 0}
.page-slider-container.visible{bottom:0}
.page-slider-track{width:100%;margin-bottom:8px;padding:0 10px}
.page-slider{width:100%;height:6px;-webkit-appearance:none;appearance:none;background:rgba(255,255,255,.1);outline:none;border-radius:3px;overflow:visible;cursor:pointer;transition:height .2s}
.page-slider:hover{height:8px}
.page-slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;border-radius:50%;background:var(--accent);cursor:pointer;border:3px solid rgba(28,37,54,.9);box-shadow:0 1px 6px rgba(0,0,0,.4);transition:all .2s ease;margin-top:-7px}
.page-slider::-webkit-slider-thumb:hover{width:24px;height:24px;margin-top:-8px}
.page-slider::-webkit-slider-runnable-track{height:100%;background:linear-gradient(to right,var(--accent) var(--slider-percent,0%),rgba(255,255,255,.1) var(--slider-percent,0%));border-radius:3px}
.page-slider::-moz-range-thumb{width:20px;height:20px;border-radius:50%;background:var(--accent);cursor:pointer;border:3px solid rgba(28,37,54,.9);box-shadow:0 1px 6px rgba(0,0,0,.4)}
.page-slider::-moz-range-thumb:hover{width:24px;height:24px}
.page-slider::-moz-range-progress{background-color:var(--accent);height:100%;border-radius:3px}
.page-slider::-moz-range-track{background-color:rgba(255,255,255,.1);height:100%;border-radius:3px}
.page-slider-info{font-size:12px;color:var(--text-on-dark);font-weight:500;letter-spacing:.3px;opacity:.8}
.rotated-mode .page-slider-container{bottom:50%!important;left:-80px!important;top:auto!important;transform:translateY(50%)!important;width:60px!important;height:70vh!important;max-width:none!important;max-height:500px;flex-direction:column-reverse!important;padding:10px 5px!important;background:rgba(28,37,54,.9);backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);border:1px solid rgba(255,255,255,.1);border-left:none;border-radius:0 12px 12px 0!important;box-shadow:2px 0 20px rgba(0,0,0,.4)!important}
.rotated-mode .page-slider-container.visible{left:0!important}
.rotated-mode .page-slider-track{width:100%!important;height:100%!important;margin-bottom:0!important;padding:10px 0!important;display:flex;align-items:center;flex:1}
.rotated-mode .page-slider{width:6px!important;height:100%!important;writing-mode:vertical-lr!important;-webkit-appearance:slider-vertical!important;appearance:slider-vertical;margin:0 auto!important;padding:0!important;background:rgba(255,255,255,.1)!important;border-radius:3px}
.rotated-mode .page-slider::-webkit-slider-runnable-track{width:6px!important;height:100%;background:linear-gradient(to top,var(--accent) var(--slider-percent,0%),rgba(255,255,255,.1) var(--slider-percent,0%))!important;border-radius:3px}
.rotated-mode .page-slider::-webkit-slider-thumb{-webkit-appearance: none;appearance: none;width:20px!important;height:20px!important;border-radius: 50%;background: var(--accent);cursor: pointer;border: 3px solid rgba(28,37,54,.9)!important;box-shadow: 0 1px 6px rgba(0,0,0,.4);transition: all .2s ease;margin-top:0!important;margin-left:-7px!important}
.rotated-mode .page-slider:hover::-webkit-slider-thumb {width: 24px !important;height: 24px !important;margin-left: -9px !important}
.rotated-mode .page-slider::-moz-range-thumb{width: 20px;height: 20px;border-radius:50%;background:var(--accent);cursor:pointer;border:3px solid rgba(28,37,54,.9);box-shadow:0 1px 6px rgba(0,0,0,.4);transition: all .2s ease}
.rotated-mode .page-slider:hover::-moz-range-thumb {width: 24px;height: 24px}
.rotated-mode .page-slider::-moz-range-progress{background-color:var(--accent)!important;width:6px!important;border-radius:3px}
.rotated-mode .page-slider::-moz-range-track{background-color:rgba(255,255,255,.1);width:6px!important;border-radius:3px}
.rotated-mode .page-slider-info{transform:rotate(90deg);white-space:nowrap;margin-bottom:15px;padding-top:10px;color:var(--text-on-dark)}
#page-slider-trigger-zone {position: fixed;bottom: 0;left: 0;width: 100%;height: 30px;z-index: 9997;pointer-events: auto}
.rotated-mode #page-slider-trigger-zone {bottom: auto;top: 50%;left: 0;width: 30px;height: 100%;transform: translateY(-50%);pointer-events: auto;}

/* --- START: Updated Text Layer, Keyword, Annotation, Popup Styles --- */

/* --- Text Layer & Keyword Styles --- */
.textLayer {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
    opacity: 1; /* Make visible for interactions */
    line-height: 1.0;
    color: rgba(0, 0, 0, 0.8); /* Make text slightly visible for better UX */
    user-select: none;
    -webkit-user-select: none;
    pointer-events: none; /* Layer doesn't capture events by default */
    z-index: 2; /* Above canvas, below annotation */
}

.textLayer > span {
    position: absolute;
    white-space: pre;
    cursor: text;
    transform-origin: 0% 0%;
    pointer-events: none; /* Individual spans off by default */
    border-radius: 2px;
}

.textLayer .keyword-interactive {
    pointer-events: auto !important; /* Keywords ARE interactive */
    cursor: pointer !important; /* Use pointer cursor for keywords */
    transition: background 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.textLayer .keyword-hover-highlight {
    /* Use the updated linear gradient highlight */
    background: linear-gradient(to right, rgba(255, 100, 0, 0.4), rgba(255, 191, 36, 0.4)) !important;
    box-shadow: 0 0 3px rgba(255, 165, 0, 0.5) !important;
    color: #000 !important; /* Ensure text is readable on highlight */
}

/* Additional helper styles for better keyword visibility (underline effect) */
.textLayer .keyword-interactive::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 1px;
    background: rgba(255, 165, 0, 0.3); /* Subtle accent underline */
    transition: height 0.2s ease, background 0.2s ease;
    pointer-events: none;
}

.textLayer .keyword-interactive:hover::after {
    height: 2px; /* Make underline thicker on hover */
    background: rgba(255, 165, 0, 0.6);
}
/* --- END: Text Layer & Keyword Styles --- */


/* --- START: Annotation Layer Styles (for Links) --- */
.annotationLayer {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
    pointer-events: none; /* Layer itself doesn't capture */
    z-index: 3; /* Above text layer */
}
.annotationLayer section { /* Styles likely inherited from pdf_viewer.css */
    position: absolute;
    pointer-events: auto; /* Annotations ARE interactive */
}
.annotationLayer .linkAnnotation > a { /* Styles likely inherited from pdf_viewer.css, adapted slightly */
    position: absolute;
    font-size: 1em;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: 1px solid transparent;
    transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out;
}
.annotationLayer .linkAnnotation > a:hover {
    cursor: pointer;
    background-color: rgba(255, 255, 0, 0.2); /* Standard yellow highlight for links */
    border: 1px solid rgba(255, 255, 0, 0.5);
    box-shadow: 0px 0px 2px rgba(255, 255, 0, 0.5);
}
/* --- END: Annotation Layer Styles --- */


/* --- START: Definition Pop-up Styles (Updated) --- */
#definition-popup {
    display: none;
    position: fixed;
    z-index: 10002; /* Above everything else */
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px; /* Standard rounding */
    box-shadow: 0 2px 10px rgba(0,0,0,0.2); /* Standard shadow */
    padding: 10px 15px;
    max-width: 300px; /* Standard max width */
    min-width: 150px;
    font-family: sans-serif; /* Use sans-serif for UI elements */
    font-size: 14px; /* Standard UI font size */
    color: #333;
    line-height: 1.4; /* Better readability */
    transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    transform: scale(0.95) translateY(5px); /* Start slightly down/scaled */
    opacity: 0;
    pointer-events: none;
}
#definition-popup.visible {
    display: block;
    transform: scale(1) translateY(0); /* Animate to full scale/position */
    opacity: 1;
    pointer-events: auto;
}
#close-popup-btn {
    position: absolute;
    top: 3px;
    right: 3px;
    background: none;
    border: none;
    font-size: 18px; /* Standard close button size */
    cursor: pointer;
    color: #888; /* Lighter gray */
    padding: 0 5px;
    line-height: 1;
}
#close-popup-btn:hover { color: #333; }
#popup-word {
    display: block;
    margin-bottom: 5px;
    color: var(--primary); /* Use theme color */
    font-weight: bold;
    font-size: 15px; /* Slightly larger keyword */
    border-bottom: 1px solid #eee; /* Separator */
    padding-bottom: 4px;
}
#popup-definition {
    max-height: 150px; /* Standard max height */
    overflow-y: auto;
    padding-right: 5px; /* Space for scrollbar if needed */
    margin-right: -5px;
}
#popup-definition i { color: #777; } /* Keep italics style */
#popup-definition span.error-message { color: #e74c3c; font-style: italic; } /* Error style */
/* Improve scrollbar appearance (optional, webkit only) */
#popup-definition::-webkit-scrollbar { width: 6px; }
#popup-definition::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 3px;}
#popup-definition::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px;}
#popup-definition::-webkit-scrollbar-thumb:hover { background: #aaa; }
/* --- END: Definition Pop-up Styles --- */

/* --- END: Updated Styles --- */

    </style>
</head>
<body>
    <div id="new-toolbar"></div>
    <div class="toolbar-trigger-area" id="toolbar-trigger-area"></div>
    <div id="status-indicator">Status: Initializing...</div>
    <div class="main-container">
        <div class="book-spread">
            <div class="book-page left">
                <div class="canvas-container">
                    <canvas id="left-page-canvas" class="pdf-canvas"></canvas>
                    <div class="textLayer" id="left-text-layer"></div>
                    <div class="annotationLayer" id="left-annotation-layer"></div>
                </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="left-page-number"></div>
                <div class="page-loading-overlay"><div class="page-loading-spinner"></div></div>
            </div>
            <div class="book-page right placeholder-page">
                 <div class="canvas-container">
                    <canvas id="right-page-canvas" class="pdf-canvas"></canvas>
                     <div class="textLayer" id="right-text-layer"></div>
                     <div class="annotationLayer" id="right-annotation-layer"></div>
                 </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="right-page-number"></div>
                <div class="page-loading-overlay"><div class="page-loading-spinner"></div></div>
            </div>
        </div>
    </div>
    <div class="toc-panel" id="toc-panel"></div>
    <div class="loading-overlay" id="loading-overlay"></div>
    <div class="page-slider-container" id="page-slider-container"></div>
    <div id="page-slider-trigger-zone"></div>

<div id="definition-popup">
    <button id="close-popup-btn" title="Close (Esc)">×</button>
    <strong id="popup-word">Word</strong>
    <div id="popup-definition">Definition</div>
</div>

<script>
    // Populate Inner HTML directly (Toolbar, TOC, Loading, Slider)
    document.getElementById('new-toolbar').innerHTML = `<button class="new-btn" id="single-page-btn" title="Single Page View">☰</button><button class="new-btn" id="double-page-btn" title="Double Page View">◫</button><button class="new-btn" id="rotate-btn" title="Rotate View">📱</button><button class="new-btn" id="toc-btn" title="Table of Contents" disabled>📑</button>`;
    document.getElementById('toc-panel').innerHTML = `<div class="toc-header"><span>Table of Contents</span><button class="notes-close" id="close-toc-btn">×</button></div><div class="toc-content"><div id="toc-list">Loading...</div></div>`;
    document.getElementById('loading-overlay').innerHTML = `<div class="loading-spinner"></div><div class="loading-message">Processing...</div>`;
    document.getElementById('page-slider-container').innerHTML = `<div class="page-slider-track"><input type="range" id="page-slider" class="page-slider" min="1" max="1" value="1" style="--slider-percent: 0%"></div><div class="page-slider-info"><span id="current-page-display">Page 1</span> of <span id="total-pages-display">1</span></div>`;
</script>
<script>
    // --- UI Elements ---
    const definitionPopup = document.getElementById('definition-popup');
    const popupWord = document.getElementById('popup-word');
    const popupDefinition = document.getElementById('popup-definition');
    const closePopupBtn = document.getElementById('close-popup-btn');
    const statusIndicator = document.getElementById('status-indicator');

    // --- State Variables ---
    let keywordDefinitions = {}; // Stores { lowercase_keyword: definition }
    let pageKeywords = {};     // Stores { page_number_string: ["OriginalCaseKeyword1", ...] }
    let currentViewports = {}; // Stores { canvasId: viewport }

    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    const pdfjsViewer = window['pdfjs-dist/web/pdf_viewer'];
    pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    const book={title:"No Document",totalPages:0,currentPage:1,isDoublePageView:true,pdfDocument:null,outline:[]};
    const user={readingProgress:{furthestPage:1}};

    let toolbarTimer=null;
    let toolbarHover=!1;
    const pageCache=new Map();
    const MAX_CACHE_SIZE=20;
    let PAGE_PADDING=15;
    let resizeTimer;
    let sliderHideTimeout=null;

    const linkService = new pdfjsViewer.SimpleLinkService();
    const eventBus = new pdfjsViewer.EventBus();

    const updateStatus=m=>console.log(`[Viewer Status] ${m}`);
    // const updateStatus = () => {}; // Production

    // --- Toolbar Logic ---
    function manageToolbar(s=null){const t=document.getElementById('new-toolbar');if(!t)return;clearTimeout(toolbarTimer);const show=s??toolbarHover;if(show){t.classList.add('visible')}else{toolbarTimer=setTimeout(()=>{if(!toolbarHover)t.classList.remove('visible')},500)}}
    function setupToolbarHover(){const t=document.getElementById('new-toolbar'),a=document.getElementById('toolbar-trigger-area'),h=t;if(!t||!a){console.error("Toolbar/trigger missing");return}const enter=()=>{toolbarHover=true;manageToolbar(true)};const leave=()=>{toolbarHover=false;manageToolbar(false)};a.addEventListener('mouseenter',enter);t.addEventListener('mouseenter',enter);a.addEventListener('mouseleave',leave);t.addEventListener('mouseleave',leave);h.addEventListener('click',e=>{if(e.target.closest('.new-btn'))return;const r=h.getBoundingClientRect(),i=document.body.classList.contains('rotated-mode');let c=false;const w=25,rh=25;if(i){if(e.clientX>=r.left&&e.clientX<=r.right&&e.clientY<r.top&&e.clientY>=r.top-rh)c=true}else{if(e.clientY>=r.top&&e.clientY<=r.bottom&&e.clientX<r.left&&e.clientX>=r.left-w)c=true}if(c){toolbarHover=!t.classList.contains('visible');manageToolbar()}});updateStatus("Toolbar setup.")}

    // --- Caching & Page Loading ---
    function trimCache(){while(pageCache.size>MAX_CACHE_SIZE){pageCache.delete(pageCache.keys().next().value); /* updateStatus(`Cache trimmed, size: ${pageCache.size}`)*/}}
    function showPageLoading(canvasId){const o=document.getElementById(canvasId)?.closest('.book-page')?.querySelector('.page-loading-overlay');if(o)o.style.display='flex';}
    function hidePageLoading(canvasId){const o=document.getElementById(canvasId)?.closest('.book-page')?.querySelector('.page-loading-overlay');if(o)o.style.display='none';}

    async function renderPage(pageNum, canvasId) {
        const canvas = document.getElementById(canvasId);
        const ctx = canvas?.getContext('2d');
        const canvasContainer = canvas?.closest('.canvas-container');
        const textLayerContainer = canvasContainer?.querySelector('.textLayer');
        const annotationLayerContainer = canvasContainer?.querySelector('.annotationLayer');
        const pageElement = canvas?.closest('.book-page');

        delete currentViewports[canvasId];
        if (textLayerContainer) textLayerContainer.innerHTML = '';
        if (annotationLayerContainer) annotationLayerContainer.innerHTML = '';

        if (!book.pdfDocument || !canvas || !ctx || !canvasContainer || !textLayerContainer || !annotationLayerContainer || !pageElement || pageNum < 1 || pageNum > book.totalPages) {
            if (canvas && ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (pageElement) pageElement.classList.add('placeholder-page');
            hidePageLoading(canvasId);
            return;
        }

        showPageLoading(canvasId);
        pageElement.classList.remove('placeholder-page');

        let page;
        let viewport;

        try {
            if (pageCache.has(pageNum)) {
                const cachedData = pageCache.get(pageNum);
                canvas.width = cachedData.width; canvas.height = cachedData.height;
                canvas.style.width = `${cachedData.styleWidth}px`; canvas.style.height = `${cachedData.styleHeight}px`;
                ctx.putImageData(cachedData.imageData, 0, 0);
                page = await book.pdfDocument.getPage(pageNum);
                viewport = cachedData.viewport;
                currentViewports[canvasId] = viewport;
                pageCache.delete(pageNum); pageCache.set(pageNum, cachedData);
                hidePageLoading(canvasId);
                // updateStatus(`Rendered canvas page ${pageNum} from cache`);

            } else {
                page = await book.pdfDocument.getPage(pageNum);
                const containerStyle = getComputedStyle(canvasContainer);
                const availableWidth = parseFloat(containerStyle.width);
                const availableHeight = parseFloat(containerStyle.height);
                 if (availableWidth <= 0 || availableHeight <= 0) {
                     console.warn(`Canvas container ${canvasId} has zero dimensions. Skipping render.`); hidePageLoading(canvasId); return;
                }
                const defaultViewport = page.getViewport({ scale: 1 });
                const scale = Math.min(availableWidth / defaultViewport.width, availableHeight / defaultViewport.height);
                viewport = page.getViewport({ scale: scale });
                currentViewports[canvasId] = viewport;
                const outputScale = window.devicePixelRatio || 1;
                canvas.width = Math.floor(viewport.width * outputScale); canvas.height = Math.floor(viewport.height * outputScale);
                canvas.style.width = `${Math.floor(viewport.width)}px`; canvas.style.height = `${Math.floor(viewport.height)}px`;
                const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
                await page.render({ canvasContext: ctx, transform: transform, viewport: viewport }).promise;
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                pageCache.set(pageNum, { imageData, width: canvas.width, height: canvas.height, styleWidth: Math.floor(viewport.width), styleHeight: Math.floor(viewport.height), viewport });
                trimCache();
                // updateStatus(`Rendered canvas page ${pageNum} and cached`);
                hidePageLoading(canvasId);
            }

            // RENDER LAYERS (Using the LATEST corrected functions)
            await renderAndEnhanceTextLayer(page, textLayerContainer, viewport);
            await renderAnnotationLayer(page, annotationLayerContainer, viewport);

        } catch (error) {
            console.error(`Error rendering page ${pageNum} on ${canvasId}:`, error);
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
            hidePageLoading(canvasId);
            pageElement?.classList.add('placeholder-page');
        }
    }

    // --- START: LATEST Corrected renderAndEnhanceTextLayer for PDF.js v3.4.120 ---
    /**
     * Properly fixed text layer rendering function for PDF.js v3.4.120
     */
    async function renderAndEnhanceTextLayer(page, container, viewport) {
        if (!page || !container || !viewport) {
            console.warn("Skipping text layer render: missing page, container, or viewport.");
            return;
        }
        const pageNum = page.pageNumber;

        // Check if we have keywords for this page (using string key)
        const keywordsForPage = pageKeywords[pageNum.toString()] || [];

        container.innerHTML = ''; // Clear previous content
        try {
            const textContent = await page.getTextContent({ normalizeWhitespace: true });

            // *** FIX APPLIED HERE ***
            // Create the text layer using pdfjsViewer component with the correct parameters
            const textLayerBuilder = new pdfjsViewer.TextLayerBuilder({
                textLayerDiv: container,
                eventBus: eventBus,
                pageIndex: page.pageIndex,
                viewport: viewport,
                textContentSource: textContent, // This is the key parameter for v3.4.120
                enhanceTextSelection: false
            });

            // *** FIX APPLIED HERE ***
            // Now just call render() without arguments
            textLayerBuilder.render();

            // Wait a brief moment for the DOM to update reliably before enhancing
            setTimeout(() => {
                enhanceKeywords(container, keywordsForPage);
            }, 100);

            // updateStatus(`Text layer rendered for page ${pageNum}. Enhancement scheduled.`);

        } catch (error) {
            console.error(`Error rendering base text layer for page ${pageNum}:`, error);
            container.innerHTML = ''; // Clear on error
        }
    }
    // --- END: LATEST Corrected renderAndEnhanceTextLayer ---

    // --- START: NEW enhanceKeywords function ---
    /**
     * Enhance text spans with keywords by adding interaction classes and data attributes.
     * This function is called *after* the TextLayerBuilder has rendered spans.
     */
    function enhanceKeywords(container, pageKeywords) {
        if (!pageKeywords || pageKeywords.length === 0 || !container || Object.keys(keywordDefinitions).length === 0) {
            // updateStatus(`Keyword enhancement skipped for container: No keywords for page or definitions missing.`);
            return; // Nothing to enhance
        }

        // Convert all definition keys to lowercase once for efficient lookup
        const lowerCaseDefs = {};
        for (const key in keywordDefinitions) {
             lowerCaseDefs[key.toLowerCase()] = keywordDefinitions[key];
        }

        // Get all text spans rendered by TextLayerBuilder inside the container
        const textSpans = container.querySelectorAll('span[role="presentation"]');
        let enhancedCount = 0;

        textSpans.forEach(span => {
            const spanText = span.textContent?.trim(); // Use optional chaining and trim
            if (!spanText) return; // Skip empty spans

            // Check if this span's text contains any of the page's keywords (case-insensitive, whole word)
            for (const originalKeyword of pageKeywords) {
                const keywordLower = originalKeyword.toLowerCase();

                // Ensure definition exists for the lowercase keyword
                const definition = lowerCaseDefs[keywordLower];
                if (!definition) {
                     // console.warn(`Definition not found for keyword '${keywordLower}'`);
                     continue; // Skip to next keyword if no definition
                }

                // Create a word boundary regex to match whole words only, case-insensitive
                // Escape special regex characters in the keyword just in case
                const escapedKeyword = originalKeyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const regex = new RegExp(`\\b(${escapedKeyword})\\b`, 'i'); // 'i' for case-insensitive

                if (regex.test(spanText)) {
                    // This span contains our keyword - make it interactive
                    span.classList.add('keyword-interactive');

                    // Store original case version for display (popup title)
                    // Store definition itself
                    span.dataset.keyword = originalKeyword;
                    span.dataset.definition = definition;
                    span.title = `Click for definition of "${originalKeyword}"`; // Add tooltip

                    enhancedCount++;
                    break; // Apply only the first found keyword to this span instance
                }
            }
        });

        // updateStatus(`Enhanced ${enhancedCount} keyword instances in container.`);
    }
    // --- END: NEW enhanceKeywords function ---

    // --- START: LATEST Corrected renderAnnotationLayer for PDF.js v3.4.120 ---
     /**
     * Similarly fixed annotation layer rendering for PDF.js v3.4.120
     */
    async function renderAnnotationLayer(page, container, viewport) {
        if (!page || !container || !viewport) {
            console.warn("Skipping annotation layer render: missing page, container, or viewport.");
            return;
        }

        container.innerHTML = ''; // Clear previous content

        try {
            const annotations = await page.getAnnotations({ intent: 'display' });
            if (annotations.length === 0) {
                // updateStatus(`Annotation layer: No annotations found on page ${page.pageNumber}.`);
                return;
            }

            // Create annotation layer builder with the correct parameters for v3.4.120
            const annotationLayerBuilder = new pdfjsViewer.AnnotationLayerBuilder({
                pageDiv: container,
                pdfPage: page,
                linkService: linkService,
                downloadManager: null // Keep this based on previous attempt, seems standard
                // Other params like annotationStorage usually not needed for basic display
            });

            // Render with correct parameters for this version (viewport and intent string)
            annotationLayerBuilder.render(viewport, 'display');

            // updateStatus(`Annotation layer rendered for page ${page.pageNumber} with ${annotations.length} annotations.`);
        } catch (error) {
            console.error(`Error rendering annotation layer for page ${page.pageNumber}:`, error);
            container.innerHTML = ''; // Clear on error
        }
    }
    // --- END: LATEST Corrected renderAnnotationLayer ---

    // --- Update Display ---
    async function updateDisplay() {
        if (!book.pdfDocument) { updateStatus("UpdateDisplay skipped: No PDF loaded."); return; }
        const leftPageNum = book.currentPage;
        const rightPageNum = book.isDoublePageView ? book.currentPage + 1 : 0;
        updateStatus(`Updating display for page(s): ${leftPageNum}${rightPageNum > 0 ? ' & ' + rightPageNum : ''}`);

        const leftPageDiv = document.querySelector('.book-page.left');
        const rightPageDiv = document.querySelector('.book-page.right');
        const leftPageNumDisplay = document.getElementById('left-page-number');
        const rightPageNumDisplay = document.getElementById('right-page-number');
        if (!leftPageDiv || !rightPageDiv || !leftPageNumDisplay || !rightPageNumDisplay) { console.error("Critical page elements missing!"); return; }

        leftPageDiv.style.visibility = 'hidden';
        rightPageDiv.style.display = 'none';
        rightPageDiv.classList.remove('placeholder-page');
        const rCanvas = document.getElementById('right-page-canvas'), rCtx = rCanvas?.getContext('2d');
        if (rCtx) rCtx.clearRect(0, 0, rCanvas.width, rCanvas.height);
        const rTextLayer = document.getElementById('right-text-layer'), rAnnLayer = document.getElementById('right-annotation-layer');
        if(rTextLayer) rTextLayer.innerHTML = ''; if(rAnnLayer) rAnnLayer.innerHTML = '';
        rightPageNumDisplay.textContent = '';

        // Render Left Page
        if (leftPageNum >= 1 && leftPageNum <= book.totalPages) {
            leftPageNumDisplay.textContent = String(leftPageNum);
            await renderPage(leftPageNum, 'left-page-canvas');
            leftPageDiv.style.visibility = 'visible';
        } else {
            leftPageDiv.style.visibility = 'hidden'; leftPageNumDisplay.textContent = '';
            const lCanvas = document.getElementById('left-page-canvas'), lCtx = lCanvas?.getContext('2d');
            if (lCtx) lCtx.clearRect(0, 0, lCanvas.width, lCanvas.height);
            const lTextLayer = document.getElementById('left-text-layer'), lAnnLayer = document.getElementById('left-annotation-layer');
            if(lTextLayer) lTextLayer.innerHTML = ''; if(lAnnLayer) lAnnLayer.innerHTML = '';
        }

        // Render Right Page (only if in double page view)
        if (book.isDoublePageView) {
            if (rightPageNum >= 1 && rightPageNum <= book.totalPages) {
                rightPageNumDisplay.textContent = String(rightPageNum);
                rightPageDiv.style.display = 'flex';
                await renderPage(rightPageNum, 'right-page-canvas');
            } else if (leftPageNum >= 1 && leftPageNum <= book.totalPages) {
                 rightPageDiv.style.display = 'flex'; rightPageDiv.classList.add('placeholder-page'); rightPageNumDisplay.textContent = '';
            } else {
                 rightPageDiv.style.display = 'none';
            }
        }

        updateSliderPosition();
        preloadAdjacentPages(book.currentPage);
        updateStatus("Display update complete.");
    }

     // --- Preloading (Unchanged from previous working version) ---
     function preloadAdjacentPages(currentPage) {
        if (!book.pdfDocument) return;
        const pagesToPreload = [];
        const lookahead = book.isDoublePageView ? 2 : 1;
        for (let i = 1; i <= lookahead; i++) {
            const nextPage = currentPage + (book.isDoublePageView ? i * 2 : i);
            if (nextPage <= book.totalPages) { pagesToPreload.push(nextPage); if (book.isDoublePageView && nextPage + 1 <= book.totalPages) pagesToPreload.push(nextPage + 1); }
        }
        for (let i = 1; i <= lookahead; i++) {
             const prevPage = currentPage - (book.isDoublePageView ? i * 2 : i);
             if (prevPage >= 1) { pagesToPreload.push(prevPage); if (book.isDoublePageView && prevPage + 1 <= book.totalPages && prevPage + 1 < currentPage) pagesToPreload.push(prevPage + 1); }
         }
        const uniquePages = [...new Set(pagesToPreload)].filter(p => p > 0 && p <= book.totalPages && !pageCache.has(p));
        if (uniquePages.length === 0) return;
        // updateStatus(`Preloading pages: ${uniquePages.join(', ')}`);
        uniquePages.forEach(pageNum => {
            book.pdfDocument.getPage(pageNum).then(page => {
                const defaultViewport = page.getViewport({ scale: 1 });
                const simWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w')) - (2 * PAGE_PADDING);
                const simHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h')) - (2 * PAGE_PADDING);
                const scale = Math.min(simWidth / defaultViewport.width, simHeight / defaultViewport.height, 1);
                const viewport = page.getViewport({ scale: scale });
                const tempCanvas = document.createElement('canvas'), tempCtx = tempCanvas.getContext('2d');
                const outputScale = window.devicePixelRatio || 1;
                tempCanvas.width = Math.floor(viewport.width * outputScale); tempCanvas.height = Math.floor(viewport.height * outputScale);
                const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
                page.render({ canvasContext: tempCtx, transform: transform, viewport: viewport }).promise.then(() => {
                    if (!pageCache.has(pageNum)) {
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        pageCache.set(pageNum, { imageData, width: tempCanvas.width, height: tempCanvas.height, styleWidth: Math.floor(viewport.width), styleHeight: Math.floor(viewport.height), viewport });
                        trimCache();
                        // updateStatus(`Preloaded and cached page ${pageNum}`);
                    }
                }).catch(err => console.warn(`Preloading page ${pageNum} failed: ${err.message}`));
            }).catch(err => console.warn(`Failed to get page ${pageNum} for preloading: ${err.message}`));
        });
    }

    // --- Navigation ---
    function nextPage(){ const inc=book.isDoublePageView?2:1,t=book.currentPage+inc; if(t<=book.totalPages)jumpToPage(t); else if(!book.isDoublePageView&&book.currentPage<book.totalPages)jumpToPage(book.totalPages) }
    function prevPage(){ const dec=book.isDoublePageView?2:1,t=book.currentPage-dec; if(t>=1)jumpToPage(t) }
    function jumpToPage(pageNum){ if(!book.pdfDocument||pageNum<1||pageNum>book.totalPages){console.warn(`Jump to page ${pageNum} out of bounds (1-${book.totalPages})`);return} let targetPage=pageNum; if(book.isDoublePageView&&targetPage>1&&targetPage%2===0)targetPage--; if(targetPage===book.currentPage)return; updateStatus(`Jumping to page ${targetPage}`); book.currentPage=targetPage; if(targetPage>user.readingProgress.furthestPage)user.readingProgress.furthestPage=targetPage; hideDefinitionPopup(); updateDisplay(); showPageSlider(); manageToolbar(false) }

    // --- View Modes (Unchanged from previous working version) ---
    function applyCurrentViewModeStyles() { const i=document.body.classList.contains('rotated-mode'),s=document.querySelector('.book-spread');if(!s)return; if(i){const w=window.innerWidth,h=window.innerHeight,bW=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w')),bH=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h')),sX=w/bH,sY=h/bW,sc=Math.min(sX,sY)*.95;s.style.transformOrigin='center center';s.style.transform=`translate(-50%, -50%) rotate(90deg) scale(${sc})`}else{s.style.transformOrigin='center center';s.style.transform='translate(-50%, -50%)'} }
    function setSinglePageView(){ if(!book.isDoublePageView&&!document.body.classList.contains('rotated-mode'))return; updateStatus("Setting Single Page View"); book.isDoublePageView=false; document.body.classList.remove('rotated-mode'); document.body.classList.add('fullscreen-mode'); hideDefinitionPopup(); applyCurrentViewModeStyles(); updateDisplay().then(()=>{manageToolbar();updateSliderTotalPages();updateSliderPosition()}); }
    function setDoublePageView(){ if(book.isDoublePageView&&!document.body.classList.contains('rotated-mode'))return; updateStatus("Setting Double Page View"); book.isDoublePageView=true; document.body.classList.remove('rotated-mode','fullscreen-mode'); if(book.currentPage>1&&book.currentPage%2===0)book.currentPage--; hideDefinitionPopup(); applyCurrentViewModeStyles(); updateDisplay().then(()=>{manageToolbar();updateSliderTotalPages();updateSliderPosition()}); }
    function setRotatedView() { if(document.body.classList.contains('rotated-mode'))return; updateStatus("Setting Rotated View"); book.isDoublePageView=false; document.body.classList.remove('fullscreen-mode'); document.body.classList.add('rotated-mode'); hideDefinitionPopup(); applyCurrentViewModeStyles(); updateDisplay().then(()=>{manageToolbar();updateSliderTotalPages();updateSliderPosition()}); }

    // --- UI Toggles ---
    function toggleElement(id,show){const el = document.getElementById(id); if(el) el.classList.toggle('visible',show)}
    function showTableOfContents(){if(!document.getElementById('toc-btn')?.disabled){toggleElement('toc-panel',true);manageToolbar(false)}}
    function hideTableOfContents(){toggleElement('toc-panel',false)}
    function showLoading(msg='Processing...'){const lo=document.getElementById('loading-overlay'),lm=lo?.querySelector('.loading-message');if(lo&&lm){lm.textContent=msg;lo.classList.add('visible')}}
    function hideLoading(){toggleElement('loading-overlay',false)}

    // --- Slider Logic (Unchanged from previous working version) ---
    function showPageSlider(){const s=document.getElementById('page-slider-container');if(s&&book.totalPages>0){s.classList.add('visible');resetSliderHideTimer()}}
    function hidePageSlider(){document.getElementById('page-slider-container')?.classList.remove('visible')}
    function resetSliderHideTimer(){clearTimeout(sliderHideTimeout);sliderHideTimeout=setTimeout(hidePageSlider,3500)}
    function initPageSlider(){const s=document.getElementById('page-slider'),sc=document.getElementById('page-slider-container');if(!s||!sc)return;let i=!1;s.addEventListener('input',()=>{if(!i)return;const n=parseInt(s.value,10),d=document.getElementById('current-page-display');if(d){let t=`Page ${n}`;if(book.isDoublePageView&&n+1<=book.totalPages)t+=`-${n+1}`;d.textContent=t}updateSliderStyle(s,n);resetSliderHideTimer()});s.addEventListener('pointerdown',()=>{i=!0});s.addEventListener('pointerup',()=>{i=!1});s.addEventListener('change',()=>{jumpToPage(parseInt(s.value,10));resetSliderHideTimer()});sc.addEventListener('mouseenter',()=>clearTimeout(sliderHideTimeout));sc.addEventListener('mouseleave',resetSliderHideTimer);updateSliderTotalPages();updateSliderPosition()}
    function updateSliderTotalPages(){const s=document.getElementById('page-slider'),d=document.getElementById('total-pages-display');if(s&&d){const t=book.totalPages>0?book.totalPages:1;s.max=t;d.textContent=t;updateSliderStyle(s,s.value)}}
    function updateSliderPosition(){const s=document.getElementById('page-slider'),d=document.getElementById('current-page-display');if(s&&d){const c=book.currentPage>0?book.currentPage:1,t=book.totalPages>0?book.totalPages:1;s.value=c;let p=`Page ${c}`;if(book.isDoublePageView&&c+1<=t)p+=`-${c+1}`;d.textContent=p;updateSliderStyle(s,c)}}
    function updateSliderStyle(s,v){if(!s)return;const i=parseInt(s.min||1),a=parseInt(s.max||1),r=a>i?a-i:1,p=(parseInt(v)-i)/r*100;s.style.setProperty('--slider-percent',`${Math.max(0,Math.min(100,p))}%`)}

    // --- START: NEW Overlay Data Loading ---
    /**
     * Enhanced overlay JSON loading and processing
     */
    async function loadOverlayData(pdfUrl) {
        const overlayUrl = pdfUrl.replace(/\.pdf$/i, '.overlay.json');
        updateStatus(`Attempting to load overlay from: ${overlayUrl}`);

        try {
            const response = await fetch(overlayUrl);
            if (!response.ok) {
                // Don't throw critical error, just log and return failure
                console.warn(`Overlay fetch failed: HTTP error ${response.status} for ${overlayUrl}`);
                keywordDefinitions = {}; pageKeywords = {}; return false;
            }

            const data = await response.json();

            // Basic structure validation
            if (!data || typeof data.keywords !== 'object' || typeof data.pages !== 'object') {
                console.warn("Invalid overlay structure in JSON file. Keywords/pages object missing.");
                keywordDefinitions = {}; pageKeywords = {}; return false;
            }

            // Process keywords: Store with lowercase keys for consistent lookups
            const processedKeywords = {};
            for (const [key, value] of Object.entries(data.keywords)) {
                if (key && typeof value === 'string') { // Basic validation
                    processedKeywords[key.toLowerCase()] = value;
                } else {
                    console.warn(`Invalid keyword entry skipped: Key='${key}', Value type='${typeof value}'`)
                }
            }
            keywordDefinitions = processedKeywords;

            // Process page keywords: Ensure page numbers are strings keys
            const processedPages = {};
            for (const [pageNum, pageWords] of Object.entries(data.pages)) {
                 // Check if pageNum is numeric-like and pageWords is an array of strings
                if (pageNum && !isNaN(parseInt(pageNum)) && Array.isArray(pageWords) && pageWords.every(w => typeof w === 'string')) {
                     processedPages[pageNum.toString()] = pageWords;
                 } else {
                      console.warn(`Invalid page entry skipped: Page='${pageNum}', Words type='${typeof pageWords}'`);
                 }
            }
            pageKeywords = processedPages;

            updateStatus(`Overlay loaded successfully: ${Object.keys(keywordDefinitions).length} keywords, ${Object.keys(pageKeywords).length} pages defined.`);
            return true; // Indicate success
        } catch (error) {
            // Catch fetch errors (network issue) or JSON parse errors
            console.warn(`Overlay fetch/parse error for ${overlayUrl}: ${error.message}. Interactive keywords disabled.`);
            keywordDefinitions = {}; // Reset state
            pageKeywords = {};
            return false; // Indicate failure gracefully
        }
    }
    // --- END: NEW Overlay Data Loading ---

    // --- START: Updated loadPdf to use loadOverlayData ---
    async function loadPdf(pdfUrl) {
        updateStatus(`loadPdf started for: ${pdfUrl}`);
        showLoading("Initializing PDF...");
        // Reset state
        pageCache.clear(); currentViewports={}; keywordDefinitions={}; pageKeywords={};
        if(book.pdfDocument){try{book.pdfDocument.destroy()}catch(e){console.warn("Error destroying previous PDF doc:", e)}}
        book.pdfDocument=null; book.totalPages=0; book.currentPage=1; book.title="No Document"; book.outline=[];
        hideDefinitionPopup();
        document.title = "Heritage History™ Reader"; document.getElementById('toc-btn').disabled = true;

        let filename = "Document";
        try { filename = decodeURIComponent(pdfUrl.split('/').pop() || filename).replace(/\.pdf$/i, ''); } catch(e){}
        book.title = filename;

        try {
            // --- Start PDF loading task ---
            updateStatus("Starting PDF document loading...");
            const loadingTask = pdfjsLib.getDocument(pdfUrl);

            // --- Start overlay fetching concurrently ---
            const overlayPromise = loadOverlayData(pdfUrl); // Use the new function

            // --- Wait for PDF document to load ---
            showLoading("Loading PDF document...");
            book.pdfDocument = await loadingTask.promise;
            book.totalPages = book.pdfDocument.numPages;
            book.currentPage = 1; user.readingProgress.furthestPage = 1;
            updateStatus(`PDF loaded: ${book.title}, Pages: ${book.totalPages}`);
            document.title = `${book.title} - Heritage History™ Reader`;
            updateSliderTotalPages(); // Update slider range now we know total pages

            // --- Process Metadata (TOC) ---
            showLoading("Processing metadata..."); updateStatus("Fetching outline...");
            try {
                book.outline = await book.pdfDocument.getOutline();
                populateTOC(); // Populates and enables/disables button
            } catch (outlineError) {
                console.warn("Could not get PDF outline:", outlineError);
                book.outline = []; populateTOC();
            }

            // --- Wait for the overlay fetch attempt to finish ---
            // We already started it, now we just wait for its result.
            const overlayLoaded = await overlayPromise;
            if (!overlayLoaded) {
                // Log is already done in loadOverlayData, no extra action needed here.
                // Application continues without keyword functionality.
            }

            // --- Determine Initial Display Mode & Render ---
            if (window.innerWidth < 1000) { // Threshold can be adjusted
                setSinglePageView(); // Calls updateDisplay internally
            } else {
                setDoublePageView(); // Calls updateDisplay internally
            }
            // Initial render is now handled by the view mode functions.

        } catch (error) {
            console.error("FATAL: Error loading PDF document:", error);
            alert(`Failed to load PDF: ${error.message || error}`);
            book.pdfDocument=null; book.totalPages=0; book.currentPage=1; book.title="Error Loading"; book.outline=[];
            keywordDefinitions={}; pageKeywords={}; document.title="Heritage History™ Reader - Error";
            updateSliderTotalPages(); updateSliderPosition(); populateTOC();
            const spreadContainer = document.querySelector('.main-container .book-spread');
             if (spreadContainer) {
                  spreadContainer.innerHTML = `<div style="color: red; background: white; padding: 30px; text-align: center; width: 100%; border: 1px solid red; border-radius: 5px;">Failed to load document: ${error.message}</div>`;
             }
        } finally {
            hideLoading();
            updateStatus("loadPdf finished.");
        }
    }
    // --- END: Updated loadPdf ---

    // --- TOC population (Unchanged from previous working version) ---
    function populateTOC() {
        const tocList = document.getElementById('toc-list'), tocButton = document.getElementById('toc-btn'); if (!tocList || !tocButton) return;
        tocList.innerHTML = ''; tocButton.disabled = true;
        if (!book.outline || book.outline.length === 0) { tocList.innerHTML = '<em>No table of contents found.</em>'; updateStatus("TOC: No outline."); return; }
        updateStatus(`TOC: Populating with ${book.outline.length} items.`);
        const createTocItem = (item, level = 0) => {
            const d = document.createElement('div'); d.className = level === 0 ? 'toc-chapter' : 'toc-section';
            const s = document.createElement('span'); s.className = level === 0 ? 'toc-chapter-title' : '';
            s.textContent = item.title || 'Untitled'; s.style.cursor = 'pointer'; s.title = `Go to: ${item.title||'Untitled'}`;
            s.onclick = async (e) => {
                e.preventDefault(); updateStatus(`TOC Click: ${item.title}`);
                try {
                    let pageIndex = -1;
                    if (typeof item.dest === 'string') { const dA = await book.pdfDocument.getDestination(item.dest); if (dA && typeof dA[0] === 'object') pageIndex = await book.pdfDocument.getPageIndex(dA[0]); }
                    else if (Array.isArray(item.dest) && typeof item.dest[0] === 'object') pageIndex = await book.pdfDocument.getPageIndex(item.dest[0]);
                    else console.warn("Unknown TOC destination format:", item.dest);
                    if (pageIndex >= 0) { jumpToPage(pageIndex + 1); hideTableOfContents(); }
                    else throw new Error(`Could not resolve page for destination: ${item.title}`);
                } catch (navError) { console.error("TOC navigation error:", navError); alert(`Navigation failed: ${navError.message}`); }
            };
            d.appendChild(s);
            if (item.items && item.items.length > 0) {
                const sub = document.createElement('div'); if (level === 0) sub.className = 'toc-sections'; else sub.style.paddingLeft = '15px';
                item.items.forEach(subItem => { const subEl = createTocItem(subItem, level + 1); if (subEl) sub.appendChild(subEl); });
                if (sub.hasChildNodes()) d.appendChild(sub);
            } return d;
        };
        book.outline.forEach(topItem => { const tocEl = createTocItem(topItem); if (tocEl) tocList.appendChild(tocEl); });
        if (tocList.hasChildNodes()) tocButton.disabled = false; else tocList.innerHTML = '<em>Error processing TOC data.</em>';
    }

    // --- START: Updated Definition Popup Function ---
    /**
     * Improved definition popup display function
     * Takes coordinates relative to the viewport.
     */
    function showDefinitionPopup(word, definition, clickLeft, clickBottom, clickTop) { // Added clickTop
        if (!definitionPopup || !popupWord || !popupDefinition || !closePopupBtn) return;

        // Set content
        popupWord.textContent = word; // Use original case from dataset
        popupDefinition.innerHTML = definition || `<span class="error-message">Definition not available.</span>`; // Handle missing definition

        // Reset style for measurement and initial hide
        definitionPopup.style.display = 'block'; // Needs to be block for getBoundingClientRect
        definitionPopup.style.opacity = '0';
        definitionPopup.style.transform = 'scale(0.95) translateY(5px)'; // Initial animation state (below)
        definitionPopup.style.pointerEvents = 'none';
        definitionPopup.style.left = `0px`; // Position off-screen initially for measurement
        definitionPopup.style.top = `0px`;

        // Use setTimeout to allow the browser to apply display:block before measuring
        setTimeout(() => {
            const popupRect = definitionPopup.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const margin = 10; // Viewport margin

            // Calculate initial position (try below first)
            let posX = clickLeft;
            let posY = clickBottom + 8; // 8px gap below keyword
            let transformOrigin = 'translateY(5px)'; // Default animation origin

            // Check right edge
            if (posX + popupRect.width > viewportWidth - margin) {
                posX = viewportWidth - popupRect.width - margin;
            }
            // Check left edge
            if (posX < margin) {
                posX = margin;
            }

            // Check bottom edge - if it overflows, try placing above
            if (posY + popupRect.height > viewportHeight - margin) {
                posY = clickTop - popupRect.height - 8; // 8px gap above keyword
                transformOrigin = 'translateY(-5px)'; // Adjust animation origin if placed above
            }
            // Check top edge (even if placed above)
            if (posY < margin) {
                posY = margin; // Stick to top margin
            }

            // Apply final position and animation state
            definitionPopup.style.left = `${posX}px`;
            definitionPopup.style.top = `${posY}px`;
            definitionPopup.style.transform = `scale(0.95) ${transformOrigin}`; // Set correct pre-animation transform

            // Make visible and animate in using requestAnimationFrame for smoothness
            requestAnimationFrame(() => {
                definitionPopup.classList.add('visible'); // Uses CSS transition from the class
                definitionPopup.style.opacity = '1';
                definitionPopup.style.transform = 'scale(1) translateY(0)';
                definitionPopup.style.pointerEvents = 'auto';
            });
        }, 0); // Timeout 0 allows repaint/reflow cycle
    }
    // --- END: Updated Definition Popup Function ---

    function hideDefinitionPopup() {
        if (definitionPopup && definitionPopup.classList.contains('visible')) {
            definitionPopup.style.opacity = '0';
            definitionPopup.style.transform = 'scale(0.95)';
            definitionPopup.style.pointerEvents = 'none';
            // Remove visible class after transition for clean state
             setTimeout(() => {
                if (definitionPopup.style.opacity === '0') { // Ensure it wasn't re-shown quickly
                    definitionPopup.classList.remove('visible');
                }
             }, 200); // Should match CSS transition duration
        }
    }

    // --- START: Updated Event Setup (Incorporating AI suggestions) ---
    function setupEvents() {
        updateStatus("Setting up events");
        const toolbar = document.getElementById('new-toolbar');
        const mainContainer = document.querySelector('.main-container');
        const bookSpread = mainContainer?.querySelector('.book-spread');

        // Toolbar Button Clicks (Unchanged)
        toolbar?.addEventListener('click', e => {
            const btn = e.target.closest('.new-btn'); if (!btn || btn.disabled) return;
            const id = btn.id; updateStatus(`Toolbar click: ${id}`);
            switch (id) {
                case 'single-page-btn': setSinglePageView(); break;
                case 'double-page-btn': setDoublePageView(); break;
                case 'rotate-btn': setRotatedView(); break;
                case 'toc-btn': showTableOfContents(); break;
            }
            resetSliderHideTimer(); toolbarHover = false; manageToolbar(false);
        });

        // TOC Panel Close Button (Unchanged)
        document.getElementById('close-toc-btn')?.addEventListener('click', hideTableOfContents);

        // Definition Popup Close Button (Unchanged)
        closePopupBtn?.addEventListener('click', hideDefinitionPopup);

        // --- START: New Event Delegation for Keywords (using document) ---
        document.addEventListener('mouseover', e => {
            // Use optional chaining and check classList exists
            if (e.target?.classList?.contains('keyword-interactive')) {
                e.target.classList.add('keyword-hover-highlight');
            }
        });

        document.addEventListener('mouseout', e => {
            if (e.target?.classList?.contains('keyword-interactive')) {
                e.target.classList.remove('keyword-hover-highlight');
            }
        });

        document.addEventListener('click', e => {
            const targetKeyword = e.target?.closest('.keyword-interactive'); // Check target or ancestors
            if (targetKeyword) {
                e.stopPropagation(); // Prevent triggering the 'outside click' handler below
                const keyword = targetKeyword.dataset.keyword;
                const definition = targetKeyword.dataset.definition;
                if (keyword && definition !== undefined) { // Check definition exists (even if empty string)
                    const rect = targetKeyword.getBoundingClientRect();
                    // Pass coordinates relative to viewport for the updated popup function
                    showDefinitionPopup(keyword, definition, rect.left, rect.bottom, rect.top);
                } else {
                    console.warn("Clicked interactive element missing keyword/definition data", targetKeyword);
                }
            }
        });
        // --- END: New Event Delegation for Keywords ---

        // Page Turn Navigation (Edge Clicks - Unchanged)
         bookSpread?.addEventListener('click', e => {
             if (e.target.classList.contains('page-edge-nav')) {
                 const pageDiv = e.target.closest('.book-page');
                 if (!pageDiv || pageDiv.classList.contains('placeholder-page')) return;
                 if (e.target.classList.contains('page-edge-left')) { prevPage(); } else { nextPage(); }
                 showPageSlider(); manageToolbar(false);
             }
         });

        // Keyboard Navigation (Integrated Escape for Popup)
        document.addEventListener('keydown', e => {
             // Ignore if modals are open OR focus is on input/textarea
             if (document.getElementById('toc-panel')?.classList.contains('visible') ||
                 (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
                 return;
             }
             // Handle Escape specifically for the popup first
             if (e.key === 'Escape' && definitionPopup.classList.contains('visible')) {
                  hideDefinitionPopup();
                  e.preventDefault(); // Prevent other potential Escape actions (like exiting fullscreen)
                  return; // Don't process other navigation keys if we closed the popup
             }
             // Ignore other keys if popup is open or if modifier keys are pressed
             if (definitionPopup.classList.contains('visible') || e.ctrlKey || e.altKey || e.metaKey) {
                  return;
             }

             let navigationAction = false;
             switch(e.key){
                 case 'ArrowRight': case 'PageDown': nextPage(); navigationAction = true; break;
                 case 'ArrowLeft': case 'PageUp': prevPage(); navigationAction = true; break;
                 case 'Home': if(book.totalPages > 0) jumpToPage(1); navigationAction = true; break;
                 case 'End': if(book.totalPages > 0) jumpToPage(book.totalPages); navigationAction = true; break;
                 // Escape handled above for popup, could add TOC close here if needed
                 // case 'Escape': if (document.getElementById('toc-panel')?.classList.contains('visible')) { hideTableOfContents(); navigationAction = true; } break;
             }
             if(navigationAction){ e.preventDefault(); showPageSlider(); manageToolbar(false); }
        });

        // Resize Handling (Unchanged)
        window.addEventListener('resize', ()=>{
            clearTimeout(resizeTimer);
            resizeTimer=setTimeout(()=>{
                updateStatus("Resize detected."); hideDefinitionPopup();
                 if(document.body.classList.contains('rotated-mode')) { applyCurrentViewModeStyles(); updateDisplay(); }
                 else if(document.body.classList.contains('fullscreen-mode')) { applyCurrentViewModeStyles(); updateDisplay(); }
                 else { applyCurrentViewModeStyles(); updateDisplay(); }
                 manageToolbar();
            }, 250);
        });

        // Touch Swipe Navigation (Unchanged)
        let tX=0,tY=0,tS=0; const SW=50,ST=500,SV=70;
        document.body.addEventListener('touchstart',e=>{if(e.target.closest('#new-toolbar,.toolbar-trigger-area,#page-slider-container,#page-slider-trigger-zone,.toc-panel,.page-edge-nav,.new-btn,button,input,a,#definition-popup,.keyword-interactive,.annotationLayer section')){tX=0;tY=0;return}if(e.touches.length===1){tX=e.touches[0].screenX;tY=e.touches[0].screenY;tS=Date.now()}else{tX=0;tY=0}},{passive:true});
        document.body.addEventListener('touchend',e=>{if(tX===0&&tY===0)return;if(e.changedTouches.length===1){const eX=e.changedTouches[0].screenX,eY=e.changedTouches[0].screenY,tE=Date.now()-tS;if(tE<ST){const dX=eX-tX,dY=eY-tY,aX=Math.abs(dX),aY=Math.abs(dY);if(aX>SW&&aY<SV){if(dX>0){prevPage()}else{nextPage()}showPageSlider();manageToolbar(false)}}}tX=0;tY=0;tS=0});

        // Slider Trigger Zone Interaction (Unchanged)
        const stz=document.getElementById('page-slider-trigger-zone'),slc=document.getElementById('page-slider-container');if(stz&&slc){const et=()=>{if(book.pdfDocument&&book.totalPages>0){showPageSlider();clearTimeout(sliderHideTimeout)}};const lts=e=>{const rt=e.relatedTarget;if(!slc.contains(rt)&&!stz.contains(rt)){resetSliderHideTimer()}};stz.addEventListener('mouseenter',et);slc.addEventListener('mouseenter',et);stz.addEventListener('mouseleave',lts);slc.addEventListener('mouseleave',lts)}

        // --- START: Updated Outside Click for Popup Close (using document) ---
        // Use capture phase to catch click before keyword click stops it
        document.addEventListener('click', e => {
            if (definitionPopup.classList.contains('visible') &&
                !definitionPopup.contains(e.target) && // Click is outside popup
                !e.target.closest('.keyword-interactive')) // And not starting a new popup
            {
                hideDefinitionPopup();
            }
        }, true); // Capture phase is important here
        // --- END: Updated Outside Click for Popup Close ---

        updateStatus("Events setup complete");
    }
    // --- END: Updated Event Setup ---

    // --- Initialization ---
    async function init() {
        updateStatus("Initializing application...");
        try {
            try { PAGE_PADDING = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-padding')) || 15; } catch(e){ PAGE_PADDING=15; console.warn("CSS var --page-padding read failed.") }
            setupEvents(); // Setup all event listeners (including updated ones)
            setupToolbarHover();
            initPageSlider();
            hideLoading();

            const urlParams = new URLSearchParams(window.location.search);
            const pdfUrlParam = urlParams.get('pdf');

            if (pdfUrlParam) {
                updateStatus(`PDF URL parameter found: ${pdfUrlParam}`);
                await loadPdf(pdfUrlParam); // Load using the updated function
            } else {
                updateStatus("No PDF specified in URL parameter (?pdf=...).");
                const sc = document.querySelector('.main-container .book-spread');
                 if(sc) sc.innerHTML = `<div style="color: var(--text-on-dark); background: rgba(28,37,54,.8); border-radius: 8px; padding: 40px; text-align: center; max-width: 500px; margin: auto;"><h2>Interactive Reader</h2><p style="margin-top: 15px;">Add <code>?pdf=URL_TO_PDF</code> to the address bar.</p></div>`;
                 document.querySelector('.book-page.left')?.style.setProperty('visibility','hidden');
                 document.querySelector('.book-page.right')?.style.setProperty('display','none');
                 document.getElementById('page-slider-container')?.classList.remove('visible');
                 document.getElementById('new-toolbar')?.classList.remove('visible');
            }

            window.addEventListener('beforeunload', () => {
                updateStatus("Unloading - Cleanup."); pageCache.clear();
                if (book.pdfDocument) { try { book.pdfDocument.destroy(); } catch(e){} book.pdfDocument = null; }
            });
            updateStatus("Initialization complete.");
        } catch (initError) {
            console.error("Initialization failed:", initError);
            document.body.innerHTML = `<div style="color: red; background: white; padding: 20px; border: 2px solid red; font-family: monospace;"><pre>App Init Error:\n${initError.stack || initError}</pre></div>`;
        }
    }

    // --- Start the application ---
    document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
