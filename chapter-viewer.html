<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heritage History™ - Digital Book Reader</title>
    <!-- Using PDF.js v2.5.207 as base for rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.min.js"></script>
    <!-- Viewer script still used for SimpleLinkService and CSS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf_viewer.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf_viewer.css">
    <style>
:root{
    --primary:#4a90e2;
    --secondary:#50e3c2;
    --accent:#f5a623; /* Amber/Orange */
    --fiery-orange: #f97316; /* Adjusted fiery orange */
    --lab-blue:#080e1c;
    --page:#fff;
    --text-on-dark:rgba(255,255,255,.9);
    --text-on-page:#333;
    --header-h:60px;
    --page-w:650px;
    --page-h:842px;
    --page-padding:15px;
    /* Modern Font Stack */
    --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";

    /* Add these variables if not defined elsewhere, based on the time-capsule example */
    --scroll: rgba(44,62,80,.8); /* Example value, adjust if needed */
    --text-light-bg-primary: var(--text-on-dark); /* Example value */
    --gradient-time-capsule: linear-gradient(45deg, #f5a623, #f97316, #c553eb, #38bdf8); /* Example gradient */
    --radius-full: 50%; /* Define if not already defined */
    --text-dark: #fff; /* Example value for hover */
    --space-sm: 8px; /* Example value */
    --space-xs: 4px; /* Example value */

    /* NEW: Parchment color */
    --parchment: #f5e8c7;
    --parchment-overlay: rgba(245, 232, 199, 0.85); /* Parchment with some transparency */
}
*{margin:0;padding:0;box-sizing:border-box}
body{
    font-family: 'Georgia', serif; /* Keep base Georgia */
    background-color:var(--lab-blue);
    color:var(--text-on-dark);
    height:100vh; width:100vw;
    overflow:hidden; display:flex; flex-direction:column; position:fixed;
    line-height:1.6
}
body::before{content:'';position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;background-image:radial-gradient(circle at 15% 15%,rgba(249,115,22,.12) 0,transparent 45%),radial-gradient(circle at 85% 85%,rgba(197,83,235,.12) 0,transparent 45%),radial-gradient(circle at 85% 15%,rgba(56,189,248,.05) 0,transparent 40%),radial-gradient(circle at 15% 85%,rgba(251,191,36,.08) 0,transparent 40%);animation:ambient-shift 30s ease infinite alternate}
@keyframes ambient-shift{0%{background-position:0 0,0 0,0 0,0 0}100%{background-position:5% 10%,-5% -5%,10% -5%,-10% 5%}}
@media (prefers-reduced-motion:reduce){body::before{animation:none!important}}

/* --- START: Toolbar & Slider Base Positioning (Always on Right/Bottom) --- */
#new-toolbar{
    position:fixed!important;
    top:15px!important; /* Position from top */
    right:-60px!important; /* Start hidden off-screen right */
    bottom: auto!important; /* Ensure bottom is not set */
    left: auto!important; /* Ensure left is not set */
    z-index:9999!important;
    display:flex!important;
    flex-direction:column!important; /* Vertical layout */
    gap:10px!important; /* KEEPING GAP AS IS - affects all buttons */
    transition:right .3s ease!important; /* Animate right property */
    background:rgba(28,37,54,.9)!important;
    backdrop-filter:blur(5px);
    -webkit-backdrop-filter:blur(5px);
    /* Adjusted top/bottom padding by 50% for the container (affects space above first & below last) */
    padding: 2.5px 5px !important;
    border-radius:8px 0 0 8px!important; /* Rounded corners on the left */
    box-shadow:-2px 2px 10px rgba(0,0,0,.4)!important;
    width:58px; /* Fixed width */
    height: auto!important; /* Height adjusts to content */
    border:1px solid rgba(255,255,255,.1);
    border-right: none!important; /* Border only on left/top/bottom */
}
#new-toolbar::before{ /* Handle "≡" */
    content:"≡";
    position:absolute;
    left:-25px; /* Position handle to the left of the toolbar */
    top:50%;
    transform:translateY(-50%);
    background:rgba(28,37,54,.9);
    backdrop-filter:blur(5px);
    -webkit-backdrop-filter:blur(5px);
    width:25px;
    height:40px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:4px 0 0 4px;
    color:var(--text-on-dark);
    font-size:20px;
    box-shadow:-2px 2px 5px rgba(0,0,0,.3);
    transition:all .3s ease;
    border:1px solid rgba(255,255,255,.1);
    border-right:none;
    cursor:pointer;
}
.toolbar-trigger-area{ /* Trigger zone for hover */
    position:fixed;
    top:0;
    right:0; /* Always on the right edge */
    width:30px;
    height:100%;
    z-index:9998;
    transition:none!important; /* No transition needed */
}
#new-toolbar.visible{
    right:0!important; /* Slide in from the right */
    transform:none!important; /* No translation needed */
}
/* Base button style */
.new-btn{
    background:rgba(44,62,80,.8)!important;
    border:1px solid rgba(255,255,255,.15)!important;
    color:var(--text-on-dark)!important;
    width:48px!important;
    height:48px!important;
    border-radius:4px!important; /* Default rounded square */
    display:flex!important;
    align-items:center!important;
    justify-content:center!important;
    font-size:25px!important; /* Base font size for symbols */
    cursor:pointer!important;
    transition:all .2s!important;
    box-shadow:0 2px 5px rgba(0,0,0,.2)!important;
    user-select:none!important;
    flex-shrink:0;
    transform: rotate(0deg)!important; /* Ensure buttons are never rotated */
    padding: 0; /* Reset padding for icon centering */
    position: relative; /* Needed for pseudo-element positioning or stacking */
    overflow: visible; /* Allow hover effects like translate */
    /* z-index: 1; Needed by Time Capsule */
}
/* Ensure icons/text within buttons are centered */
.new-btn > *, .new-btn .icon {
    margin: 0; /* Remove default margins */
    line-height: 1; /* Helps vertical centering of text symbols */
    flex-shrink: 0; /* Prevent shrinking */
}
.new-btn .icon { /* Specific SVG icon styling */
    width: 24px; /* Default icon size */
    height: 24px;
    stroke-width: 1.5;
}

.new-btn:hover{
    background:rgba(52,73,94,.9)!important;
    border-color:rgba(255,255,255,.25)!important;
    box-shadow:0 2px 8px rgba(0,0,0,.3)!important;
    transform:translateY(-2px)!important; /* Keep vertical hover effect */
}
.new-btn:active{
    transform:translateY(1px)!important; /* Keep vertical active effect */
}
.new-btn[disabled]{opacity:.5;cursor:not-allowed;pointer-events:none}

/* Back Button Specific Styles - MODIFIED */
#back-btn {
    background: none !important;
    border: none !important;
    box-shadow: none !important;
    font-size: 20px !important; /* Decreased font size */
    color: var(--text-on-dark) !important;
    /* Decreased width/height for smaller size */
    width: 36px !important;
    height: 36px !important;
    padding: 0 !important;
    /* Add negative margin to reduce space specifically around this button */
    /* 50% reduction of container padding (5px -> 2.5px) + 50% reduction of gap (10px -> 5px) */
    margin-top: -2.5px !important; /* Adjust space above */
    margin-bottom: -5px !important; /* Adjust space below (relative to gap) */
    /* Ensure flex alignment still works */
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    transition: color 0.2s, transform 0.2s !important;
}

#back-btn:hover {
    background: none !important;
    border: none !important;
    box-shadow: none !important;
    color: var(--accent) !important; /* Change color on hover */
    transform: translateX(-3px) !important; /* Move left slightly */
}
#back-btn:active {
    transform: translateX(0px) !important; /* Reset on active */
    color: var(--secondary) !important;
}


/* Time Capsule Button (Last button) */
#time-capsule-btn {
    position: relative; /* Needed for pseudo-element */
    overflow: hidden; /* Clip pseudo-element */
    z-index: 1; /* Stacking context */
    border-radius: 50% !important; /* Make it a circle */
    padding: 0 !important; /* Ensure padding doesn't interfere */
    /* Inherits base .new-btn styles (size, flex centering, base bg/color) */
}

#time-capsule-btn::before {
    content: "";
    position: absolute;
    z-index: -1; /* Behind the button content */
    top: -3px; left: -3px; right: -3px; bottom: -3px; /* Offset for effect */
    background: var(--gradient-time-capsule); /* --- UNCHANGED: This gradient is used for initial state --- */
    background-size: 300% 300%;
    border-radius: 50%; /* Match button shape */
    filter: blur(3px); /* Initial blur */
    opacity: 0.35; /* Initial opacity */
    transition: opacity 0.4s ease-out, filter 0.4s ease-out;
    animation: hazyGradientAnimation 6s linear infinite; /* --- UNCHANGED: Button animation speed --- */
    pointer-events: none; /* Don't interfere with clicks */
}

/* Hover effects specific to Time Capsule button */
#time-capsule-btn:hover {
    /* Use standard .new-btn hover styles for consistency */
    background: rgba(52,73,94,.9) !important;
    border-color: rgba(255,255,255,.25) !important;
    box-shadow: 0 2px 8px rgba(0,0,0,.3) !important;
    transform: translateY(-2px) !important;
    color: var(--text-on-dark) !important; /* Keep icon color */
}

#time-capsule-btn:hover::before {
    opacity: 0.8; /* Increased opacity on hover */
    filter: blur(5px); /* Increased blur on hover */
}

/* Ensure icon/content inside Time Capsule button remains visible */
#time-capsule-btn .icon { /* Target the SVG icon */
    position: relative;
    z-index: 2; /* Above the ::before pseudo-element */
    margin: 0; /* Ensure no extra margin */
    /* Size and stroke-width inherited from .new-btn .icon */
    color: var(--text-on-dark) !important; /* Ensure correct color */
}

#time-capsule-btn:hover .icon {
    color: var(--text-on-dark) !important; /* Keep color on hover */
}


@keyframes hazyGradientAnimation { /* Ensure animation is defined */
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}


.page-slider-container{
    position:fixed;
    bottom:-80px; /* Start hidden below */
    left:50%!important; /* Center horizontally */
    transform:translateX(-50%)!important; /* Precise horizontal centering */
    top: auto!important; /* Ensure top is not set */
    right: auto!important; /* Ensure right is not set */
    width:90%;
    max-width:700px;
    height: auto!important; /* Height adjusts */
    padding:14px 20px;
    background:rgba(28,37,54,.9);
    backdrop-filter:blur(5px);
    -webkit-backdrop-filter:blur(5px);
    border:1px solid rgba(255,255,255,.1);
    border-bottom:none;
    box-shadow:0 -4px 20px rgba(0,0,0,.4);
    display:flex;
    flex-direction:column!important; /* Content flows vertically */
    align-items:center;
    z-index:9998;
    transition:bottom .35s cubic-bezier(.2,.9,.3,1)!important; /* Animate bottom property */
    border-radius:16px 16px 0 0; /* Rounded top corners */
}
.page-slider-container.visible{
    bottom:0!important; /* Slide up from bottom */
}
.page-slider-track{width:100%;margin-bottom:8px;padding:0 10px}
.page-slider{
    width:100%!important; /* Full width */
    height:6px!important; /* Base height */
    -webkit-appearance:none!important;
    appearance:none!important;
    background:rgba(255,255,255,.1)!important; /* Base track color */
    outline:none;
    border-radius:3px!important;
    overflow:visible;
    cursor:pointer;
    transition:height .2s;
    writing-mode: horizontal-tb !important; /* Ensure horizontal */
}
.page-slider:hover{height:8px}
.page-slider::-webkit-slider-thumb{
    -webkit-appearance:none!important;
    appearance:none!important;
    width:20px!important;height:20px!important; /* Thumb size */
    border-radius:50%!important;
    background:var(--accent)!important; /* Keep thumb the accent color for now */
    cursor:pointer;
    border:3px solid rgba(28,37,54,.9)!important;
    box-shadow:0 1px 6px rgba(0,0,0,.4)!important;
    transition:all .2s ease;
    margin-top:-7px!important; /* Vertical centering for horizontal slider */
    margin-left: 0 !important; /* No horizontal margin adjustment */
}
.page-slider:hover::-webkit-slider-thumb{width:24px!important;height:24px!important;margin-top:-8px!important}

/* --- START: MODIFIED SLIDER TRACK COLORS --- */
.page-slider::-webkit-slider-runnable-track {
    width: 100% !important;
    height: 100% !important;
    /* Use multiple backgrounds for WebKit:
       1. The desired gradient for the filled portion, sized by --slider-percent.
       2. The standard empty track color underneath. */
    background-image: linear-gradient(to right, var(--fiery-orange), var(--accent)), /* Filled part gradient */
                      linear-gradient(to right, rgba(255, 255, 255, .1), rgba(255, 255, 255, .1)); /* Empty part color */
    background-size: var(--slider-percent, 0%) 100%, 100% 100%; /* Size gradient based on percent */
    background-repeat: no-repeat;
    border-radius: 3px !important;
    /* Explicitly set background color to transparent to avoid clash with background-image */
    background-color: transparent !important;
}

/* Firefox specific styles */
.page-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--accent); /* Keep thumb the accent color */
    cursor: pointer;
    border: 3px solid rgba(28, 37, 54, .9);
    box-shadow: 0 1px 6px rgba(0, 0, 0, .4);
}
.page-slider:hover::-moz-range-thumb {width: 24px; height: 24px;}
.page-slider::-moz-range-progress {
    /* Apply the desired gradient to the progress bar */
    background: linear-gradient(to right, var(--fiery-orange), var(--accent)) !important;
    height: 100%;
    border-radius: 3px;
}
.page-slider::-moz-range-track {
    /* Ensure the empty part of the track is the standard light color */
    background-color: rgba(255, 255, 255, .1) !important;
    height: 100%;
    border-radius: 3px;
}
/* --- END: MODIFIED SLIDER TRACK COLORS --- */

.page-slider-info{
    font-size:12px;
    color:var(--text-on-dark);
    font-weight:500;
    letter-spacing:.3px;
    opacity:.8;
    transform: rotate(0deg)!important; /* Ensure info text is never rotated */
    white-space: normal!important; /* Allow wrapping if needed */
    margin-bottom: 0 !important; /* Reset margin */
    padding-top: 0 !important; /* Reset padding */
}
#page-slider-trigger-zone { /* Trigger zone for slider */
    position: fixed;
    bottom: 0; /* At the bottom edge */
    left: 0;
    width: 100%;
    height: 30px;
    z-index: 9997;
    pointer-events: auto;
}
/* --- END: Toolbar & Slider Base Positioning --- */

/* --- START: Left Toolbar for Timelock --- */
#left-toolbar {
    position: fixed !important;
    top: 15px !important; /* Align with right toolbar */
    left: -60px !important; /* Start hidden off-screen left */
    bottom: auto !important; /* Ensure bottom is not set */
    right: auto !important; /* Ensure right is not set */
    z-index: 9999 !important;
    display: flex !important;
    flex-direction: column !important; /* Vertical layout */
    gap: 10px !important; /* Standard gap */
    transition: left .3s ease !important; /* Animate left property */
    background: rgba(28, 37, 54, .9) !important;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    padding: 2.5px 5px !important; /* Consistent padding */
    border-radius: 0 8px 8px 0 !important; /* Rounded corners on the right */
    box-shadow: 2px 2px 10px rgba(0, 0, 0, .4) !important;
    width: 58px; /* Fixed width */
    height: auto !important; /* Height adjusts to content */
    border: 1px solid rgba(255, 255, 255, .1);
    border-left: none !important; /* Border only on right/top/bottom */
}

#left-toolbar::before { /* Handle "≡" */
    content: "≡";
    position: absolute;
    right: -25px; /* Position handle to the right of the toolbar */
    left: auto; /* Ensure left is not set */
    top: 50%;
    transform: translateY(-50%);
    background: rgba(28, 37, 54, .9);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    width: 25px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0 4px 4px 0;
    color: var(--text-on-dark);
    font-size: 20px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);
    transition: all .3s ease;
    border: 1px solid rgba(255, 255, 255, .1);
    border-left: none;
    cursor: pointer;
}

.left-toolbar-trigger-area { /* Trigger zone for hover */
    position: fixed;
    top: 0;
    left: 0; /* Always on the left edge */
    width: 30px;
    height: 100%;
    z-index: 9998;
    transition: none !important; /* No transition needed */
}

#left-toolbar.visible {
    left: 0 !important; /* Slide in from the left */
    transform: none !important; /* No translation needed */
}

/* Specific styling for the timelock button */
#timelock-toggle-btn {
    /* Inherits .new-btn styles */
}
#timelock-toggle-btn.timelock-on .icon-clock-on {
    display: block; /* Show the 'on' icon */
    stroke: var(--secondary); /* Greenish tint for 'on' */
}
#timelock-toggle-btn.timelock-on .icon-clock-off {
    display: none; /* Hide the 'off' icon */
}

#timelock-toggle-btn.timelock-off .icon-clock-on {
    display: none; /* Hide the 'on' icon */
}
#timelock-toggle-btn.timelock-off .icon-clock-off {
    display: block; /* Show the 'off' icon */
    stroke: var(--accent); /* Orange tint for 'off' */
}

/* --- END: Left Toolbar for Timelock --- */


/* --- REMOVED/COMMENTED OUT: Original .rotated-mode UI repositioning --- */
/* ... (unchanged) ... */

/* Reader container */
.main-container{
    flex:1;display:flex;justify-content:center!important;align-items:center!important;padding:0;height:100%;width:100%;overflow:hidden;position:relative;background:transparent;
    /* Initially hidden when game is active */
    visibility: hidden;
    opacity: 0;
    transition: visibility 0s linear 0.3s, opacity 0.3s ease-in-out;
}
body:not(.loading-game-active) .main-container {
    visibility: visible;
    opacity: 1;
    transition-delay: 0s;
}


.book-spread{display:flex;box-shadow:0 10px 35px rgba(0,0,0,.5);position:fixed!important;top:50%!important;left:50%!important;transform-origin:center center;width:auto!important;height:auto!important;transition:transform .3s ease; transform: translate(-50%, -50%)}
.book-page{width:var(--page-w);height:var(--page-h);background-color:var(--page);position:relative;overflow:hidden; flex-shrink:0;display:flex;justify-content:center;align-items:center;border:1px solid rgba(255,255,255,.08);padding:0;}
.book-page.left{border-right:1px solid rgba(255,255,255,.15);border-radius:3px 0 0 3px}
.book-page.right{border-left:1px solid rgba(255,255,255,.15);border-radius:0 3px 3px 0}
.canvas-container {
    position: relative; /* Important for positioning layers */
    width: calc(100% - 2 * var(--page-padding));
    height: calc(100% - 2 * var(--page-padding));
    margin: var(--page-padding);
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden; /* Clip layers */
}
.pdf-canvas{max-width:100%;max-height:100%;display:block;object-fit:contain;box-shadow: none; position: absolute; top: 0; left: 0; z-index: 1; } /* Canvas layer */
.page-number{display:none}
.page-loading-overlay{position:absolute;inset:var(--page-padding);background:rgba(255,255,255,.6);z-index:50;display:none;justify-content:center;align-items:center;border-radius:3px}
.page-loading-spinner{width:32px;height:32px;border-radius:50%;border:3px solid rgba(0,0,0,.1);border-top-color:var(--primary);animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.page-edge-nav{position:absolute;top:0;height:100%;width:50px;cursor:pointer;z-index:10;transition:background-color .2s;-webkit-tap-highlight-color:transparent}
.page-edge-nav:hover{background-color:rgba(0,0,0,.03)}
.page-edge-left{left:0;border-radius:3px 0 0 3px}
.page-edge-right{right:0;border-radius:0 3px 3px 0}
.page-edge-left:hover::after,.page-edge-right:hover::after{content:"";position:absolute;top:50%;width:12px;height:12px;border-style:solid;border-color:rgba(0,0,0,.6);border-width:2px 2px 0 0;opacity:.8}
.page-edge-left:hover::after{left:18px;transform:translateY(-50%) rotate(-135deg)}
.page-edge-right:hover::after{right:18px;transform:translateY(-50%) rotate(45deg)}

/* --- START: Single Page Mode Styles Adjustment --- */
.fullscreen-mode .book-page.right {
    display: none !important;
}
.fullscreen-mode .book-page.left { /* Ensure border/radius looks ok in single page */
    border-right: 1px solid rgba(255, 255, 255, .08) !important;
    border-radius: 3px !important; /* Apply radius to all corners? Or just keep 3px 0 0 3px? Adjust if needed */
}
.fullscreen-mode .canvas-container {
    margin: var(--page-padding);
}
.fullscreen-mode .pdf-canvas {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    position: absolute;
    z-index: 1;
}
/* --- END: Single Page Mode Styles Adjustment --- */

/* --- START: Content Rotated Mode Styles --- */
/* Apply rotation transform in JS via applyCurrentViewModeStyles */
.content-rotated-mode .book-page.left{
    width:var(--page-w)!important; /* Use base dimensions for rotation calc */
    height:var(--page-h)!important;
    border-radius: 3px !important; /* Optional: Apply consistent radius */
    border: 1px solid rgba(255, 255, 255, .08) !important; /* Consistent border */
    padding:0 !important;
    background-color:var(--page);
    display:flex!important; /* Ensure it's displayed */
    justify-content:center;align-items:center;
}
.content-rotated-mode .canvas-container {
    margin: 10px !important; /* Use consistent padding/margin */
    width: calc(100% - 20px);
    height: calc(100% - 20px);
}
.content-rotated-mode .book-page.right{
    display:none!important; /* Always hide right page when content is rotated */
}
.content-rotated-mode .pdf-canvas{
    box-shadow:none;
    max-width:100%;
    max-height:100%;
    object-fit:contain;
    position: relative;
    z-index: 1;
}
/* --- END: Content Rotated Mode Styles --- */


body:not(.fullscreen-mode):not(.content-rotated-mode) .book-page{width:var(--page-w);height:var(--page-h)} /* Default page size */
.book-page.right.placeholder-page{background-color:var(--page)!important;border-left:1px solid rgba(0,0,0,.1);position:relative;display:flex!important;justify-content:center;align-items:center}
.book-page.right.placeholder-page::after{content:"End of document";font-size:14px;font-style:italic;color:rgba(0,0,0,.5)}
.book-page.right.placeholder-page .canvas-container,.book-page.right.placeholder-page .page-edge-nav,.book-page.right.placeholder-page .page-loading-overlay{display:none}

/* Gutter shadow effect only in double page view */
/* EXISTING inner gutter shadows (applied to canvas container inside page) */
body:not(.fullscreen-mode):not(.content-rotated-mode) .book-page.left .canvas-container::after { content: ''; position: absolute; top: 0; right: calc(0px - var(--page-padding)); width: 15px; height: 100%; background: linear-gradient(to left, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0)); pointer-events: none; z-index: 5; border-radius: 0 2px 2px 0; }
body:not(.fullscreen-mode):not(.content-rotated-mode) .book-page.right:not(.placeholder-page) .canvas-container::before { content: ''; position: absolute; top: 0; left: calc(0px - var(--page-padding)); width: 15px; height: 100%; background: linear-gradient(to right, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0)); pointer-events: none; z-index: 5; border-radius: 2px 0 0 2px; }
body:not(.fullscreen-mode):not(.content-rotated-mode) .book-page.right.placeholder-page { border-left: 1px solid rgba(0,0,0,.1) !important; }

/* --- START: REALISTIC VERTICAL CREASE EFFECT --- */
body:not(.fullscreen-mode):not(.content-rotated-mode) .book-spread::before {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%; /* Center horizontally */
    width: 30px; /* Width of the crease effect */
    transform: translateX(-50%); /* Precise centering */
    /* Gradient: Darkest in center, fading smoothly to transparent edges */
    background: linear-gradient(to right,
        rgba(0, 0, 0, 0.0) 0%,     /* Start transparent */
        rgba(0, 0, 0, 0.12) 35%,   /* Fade in to subtle shadow */
        rgba(0, 0, 0, 0.18) 50%,   /* Darkest point at the exact center */
        rgba(0, 0, 0, 0.12) 65%,   /* Fade out */
        rgba(0, 0, 0, 0.0) 100%    /* End transparent */
    );
    pointer-events: none; /* Doesn't interfere with mouse */
    z-index: 6; /* Position above page background, below other interactive elements */
    opacity: 1; /* Keep opacity at 1, control darkness via RGBA alpha values */
}
/* --- END: REALISTIC VERTICAL CREASE EFFECT --- */


/* --- TOC, Loading, Text/Annotation Layers, Keywords --- */
/* Note: TOC Panel styling remains, but the button won't open it */
.toc-panel{position:fixed;z-index:10000;display:none;color:var(--text-on-page); left:50%;top:50%;transform:translate(-50%,-50%);width:90%;max-width:500px;height:80vh;background:#f0f4f8;border-radius:8px;box-shadow:0 5px 25px rgba(0,0,0,.5);flex-direction:column;overflow:hidden; font-family: var(--font-sans);}
/* .toc-panel.visible,.loading-overlay.visible{display:flex!important} */ /* Original loading overlay no longer used this way */
.toc-panel.visible{display:flex!important} /* TOC can still be shown programmatically */
.toc-header{padding:15px 20px;background:var(--primary);color:#fff;font-weight:700;display:flex;justify-content:space-between;align-items:center;flex-shrink:0}
.toc-header .notes-close{background:none;border:none;color:#fff;font-size:24px;cursor:pointer;padding:0 5px;line-height:1}
.toc-content{flex:1;padding:10px 20px;overflow-y:auto}
.toc-chapter{padding:8px 0;border-bottom:1px solid #d8dfe6}
.toc-chapter-title{font-weight:700;color:var(--primary);cursor:pointer;padding:5px 0}
.toc-chapter-title:hover,.toc-section:hover{color:var(--accent)}
.toc-sections{padding-left:20px;margin-top:5px}
.toc-section{padding:4px 0;cursor:pointer;color:#4a5568;font-size:.95em}
/* Original Loading Overlay - Keep structure but hide by default unless needed */
.loading-overlay{position:fixed;inset:0;background:rgba(8,14,28,.85);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);z-index:10001;display:none;justify-content:center;align-items:center;flex-direction:column}
.loading-spinner{width:50px;height:50px;border-radius:50%;border:4px solid rgba(255,255,255,.2);border-top-color:var(--accent);animation:spin 1s linear infinite;margin-bottom:15px}
.loading-message{font-size:16px;color:var(--text-on-dark)}
#status-indicator{display:none}
/* --- Base Text Layer (Hidden) & Annotation Layer Styles --- */
.textLayer { position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; opacity: 1; line-height: 1.0; color: transparent !important; user-select: none; -webkit-user-select: none; pointer-events: none !important; z-index: 2; }
.textLayer > div { position: absolute; white-space: pre; cursor: default; transform-origin: 0% 0%; pointer-events: none !important; border-radius: 2px; }
.annotationLayer { position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; pointer-events: none; z-index: 3; }
.annotationLayer section { position: absolute; pointer-events: auto; }
.annotationLayer .linkAnnotation > a { position: absolute; font-size: 1em; top: 0; left: 0; width: 100%; height: 100%; border: 1px solid transparent; transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out; }
.annotationLayer .linkAnnotation > a:hover { cursor: pointer; background-color: rgba(255, 255, 0, 0.2); border: 1px solid rgba(255, 255, 0, 0.5); box-shadow: 0px 0px 2px rgba(255, 255, 0, 0.5); }
/* --- START: Custom Keyword Overlay & Popup Styles --- */
.keyword-overlay-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 4; overflow: hidden; }
.keyword-highlight { position: absolute; background: transparent; transition: background 0.2s ease-out, box-shadow 0.2s ease-out; pointer-events: auto; cursor: pointer; z-index: 5; box-sizing: border-box; border-radius: 3px; }
/* Hover effect still applies to ALL keyword highlights (when not in rotated mode) */
.keyword-highlight:hover { background: linear-gradient(to right, rgba(249, 115, 22, 0.25), rgba(251, 191, 36, 0.25)); box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }

/* --- START: MODIFIED UNDERLINE RULE --- */
/* Underline now ONLY applies if the 'first-keyword-instance' class is present */
.keyword-highlight.first-keyword-instance::after {
    content: '';
    position: absolute;
    left: 0;
    bottom: -2px; /* Position 2px below the highlight box */
    width: 100%; /* Takes the width of the correctly sized highlight box */
    height: 1.5px;  /* Make it slightly thicker but still subtle */
    background: linear-gradient(to right, var(--fiery-orange), var(--accent)); /* This is the target gradient */
    pointer-events: none; /* Prevent interaction with the line itself */
    border-radius: 1px; /* Slightly rounded ends */
    opacity: 0.54; /* UPDATED: Was 0.9, now 60% of that (0.9 * 0.6) */
    transition: opacity 0.2s ease-out; /* Allow transition if needed */
}
/* --- END: MODIFIED UNDERLINE RULE --- */

/* --- START: Disable Keyword Effects in Rotated Mode --- */
body.content-rotated-mode .keyword-highlight {
    pointer-events: none !important; /* Disable click and hover interactions */
    cursor: default; /* Remove pointer cursor */
    /* Hover effects are implicitly disabled by pointer-events: none */
}

body.content-rotated-mode .keyword-highlight.first-keyword-instance::after {
    display: none; /* Hide the underline */
    opacity: 0; /* Optionally transition out */
}
/* --- END: Disable Keyword Effects in Rotated Mode --- */

#definition-popup { position: fixed; background: #ffffff; border-radius: 8px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15), 0 2px 5px rgba(0, 0, 0, 0.1); padding: 14px 18px; max-width: 320px; min-width: 180px; font-family: var(--font-sans); color: #2d3748; z-index: 10002; transform-origin: top center; transform: translateY(6px) scale(0.98); opacity: 0; visibility: hidden; transition: transform 0.18s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.18s cubic-bezier(0.4, 0, 0.2, 1), visibility 0s linear 0.18s; pointer-events: none; }
#definition-popup.visible { transform: translateY(0) scale(1); opacity: 1; visibility: visible; transition: transform 0.18s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.18s cubic-bezier(0.4, 0, 0.2, 1), visibility 0s linear 0s; pointer-events: auto; }
#popup-word { font-weight: 600; font-size: 15px; margin: 0 0 10px 0; color: var(--primary); border-bottom: 1px solid #e2e8f0; padding: 0 0 8px 0; }
#popup-definition { font-size: 14px; line-height: 1.6; max-height: 180px; overflow-y: auto; color: #4a5568; padding-right: 5px; margin-right: -5px; }
#popup-definition::-webkit-scrollbar { width: 5px; }
#popup-definition::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px;}
#popup-definition::-webkit-scrollbar-thumb { background: #cbd5e0; border-radius: 3px;}
#popup-definition::-webkit-scrollbar-thumb:hover { background: #a0aec0; }
#close-popup-btn { position: absolute; top: 6px; right: 6px; cursor: pointer; font-size: 20px; font-weight: 300; color: #a0aec0; transition: color 0.2s, background-color 0.2s; background: none; border: none; padding: 0; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; line-height: 1; }
#close-popup-btn:hover { color: #4a5568; background-color: #edf2f7; }
/* --- END: Custom Keyword Overlay & Popup Styles --- */

/* --- START: Loading Game Styles --- */
#loading-game-container {
    position: fixed;
    inset: 0;
    z-index: 10000; /* High z-index to cover everything initially */
    background-color: var(--lab-blue); /* Match body background */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
    opacity: 1;
    visibility: visible;
}
body.loading-game-active #loading-game-container {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}
body:not(.loading-game-active) #loading-game-container {
    opacity: 0;
    visibility: hidden;
    pointer-events: none; /* Prevent interaction when hidden */
}

#game-iframe {
    width: 90%;
    max-width: 900px; /* Adjust as needed */
    height: 70vh;
    max-height: 400px; /* Adjust as needed */
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    background-color: var(--primary-bg); /* Use game's dark bg as placeholder */
}

#iframe-loading-text {
    color: var(--text-on-dark);
    margin-top: 15px;
}

#go-to-chapter-btn {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) scale(0.8);
    z-index: 10001; /* Above game iframe */
    padding: 12px 25px;
    font-size: 1.1rem;
    font-weight: bold;
    color: white;
    background: linear-gradient(135deg, var(--fiery-orange), var(--accent));
    border: none;
    border-radius: 25px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(255, 255, 255, 0.2) inset;
    transition: all 0.3s ease;
    opacity: 0;
    visibility: hidden;
}

#go-to-chapter-btn.visible {
    opacity: 1;
    visibility: visible;
    transform: translateX(-50%) scale(1);
}

#go-to-chapter-btn:hover {
    background: linear-gradient(135deg, var(--accent), var(--fiery-orange));
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 1px 4px rgba(255, 255, 255, 0.25) inset;
    transform: translateX(-50%) scale(1.05);
}
#go-to-chapter-btn:active {
    transform: translateX(-50%) scale(0.98);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.15) inset;
}

/* *** SUREFIRE WAY TO HIDE BUTTON WHEN READER IS ACTIVE *** */
body:not(.loading-game-active) #go-to-chapter-btn {
    display: none !important; /* Ensure it's completely removed from layout */
    opacity: 0;
    visibility: hidden;
}

/* Initially hide reader elements when game is active */
body.loading-game-active #new-toolbar,
body.loading-game-active .toolbar-trigger-area,
body.loading-game-active #left-toolbar, /* Hide left toolbar too */
body.loading-game-active .left-toolbar-trigger-area, /* Hide left trigger too */
body.loading-game-active #page-slider-container,
body.loading-game-active #page-slider-trigger-zone,
body.loading-game-active #definition-popup,
body.loading-game-active #iframe-popup-backdrop, /* Hide iframe popup too */
body.loading-game-active #iframe-popup-modal,   /* Hide iframe popup too */
body.loading-game-active #notes-popup-backdrop, /* Hide notes popup too */
body.loading-game-active #notes-popup-container /* Hide notes popup too */
{
    display: none;
    visibility: hidden;
}
/* --- END: Loading Game Styles --- */

/* --- START: Reading Time Alert --- */
@keyframes funWiggle { /* Wiggle Animation */
    0%, 100% { transform: translateX(-50%) rotate(0); }
    25% { transform: translateX(calc(-50% - 3px)) rotate(-1.5deg); }
    50% { transform: translateX(calc(-50% + 3px)) rotate(1.5deg); }
    75% { transform: translateX(calc(-50% - 2px)) rotate(-1deg); }
}

#reading-time-alert {
    position: fixed;
    bottom: 80px; /* Adjust as needed, above slider */
    left: 50%;
    transform: translateX(-50%); /* Start centered */
    background: rgba(249, 115, 22, 0.9); /* Fiery orange, slightly transparent */
    color: white;
    padding: 10px 20px;
    border-radius: 6px;
    z-index: 10005; /* Above most elements but potentially below modals */
    font-family: var(--font-sans);
    font-size: 14px;
    font-weight: 500;
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
    opacity: 0;
    transition: opacity 0.3s ease-in-out; /* Fade in/out */
    pointer-events: none; /* Prevent interaction */
    white-space: nowrap;
}
#reading-time-alert.visible { /* Class added by JS for fade-in and wiggle */
    opacity: 1;
    animation: funWiggle 0.4s ease-in-out 1; /* Play wiggle animation once */
}
/* --- END: Reading Time Alert --- */

/* --- START: Iframe Popup Styles --- */
#iframe-popup-backdrop {
    position: fixed;
    inset: 0;
    background-color: rgba(8, 14, 28, 0.7); /* Base semi-transparent dark blue */
    backdrop-filter: blur(3.15px); /* MODIFIED: Blur effect 5% stronger */
    -webkit-backdrop-filter: blur(3.15px); /* MODIFIED: Blur effect 5% stronger */
    z-index: 10003; /* Above definition popup, below modal */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.25s ease-out, visibility 0s linear 0.25s; /* UNCHANGED: Blur appears simultaneously with opacity transition */
    cursor: pointer; /* Indicate clicking backdrop closes it */
    overflow: hidden; /* Contain the pseudo-element */
}

/* Gradient overlay using ::before */
#iframe-popup-backdrop::before {
    content: "";
    position: absolute;
    inset: 0; /* Cover the entire backdrop */
    background: var(--gradient-time-capsule); /* UNCHANGED: Apply the specified flowing gradient (matches button initial state) */
    background-size: 300% 300%; /* Match button animation size */
    opacity: 0.35; /* Match button initial opacity for the overlay */
    animation: hazyGradientAnimation 30s linear infinite; /* MODIFIED: Apply the animation, 5x slower (30s vs 6s) */
    pointer-events: none; /* Don't interfere with clicks */
    z-index: -1; /* Place behind potential backdrop content, but above page content */
}

#iframe-popup-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    width: 80%;
    height: 80%;
    max-width: 1000px;
    max-height: 700px;
    background-color: var(--page); /* White page background */
    border-radius: 8px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    z-index: 10004; /* Above backdrop */
    opacity: 0;
    visibility: hidden;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s ease-out, visibility 0s linear 0.25s;
}
#iframe-popup-backdrop.visible,
#iframe-popup-modal.visible {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}
#iframe-popup-modal.visible {
    transform: translate(-50%, -50%) scale(1);
}
#popup-iframe {
    flex-grow: 1; /* Take remaining space */
    border: none;
    width: 100%;
    height: 100%; /* Fill the container */
}
#close-iframe-popup-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 32px;
    height: 32px;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    line-height: 1;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, transform 0.2s;
    z-index: 10005; /* Above iframe content */
}
#close-iframe-popup-btn:hover {
    background-color: rgba(0, 0, 0, 0.7);
    transform: scale(1.1);
}
/* --- END: Iframe Popup Styles --- */

/* --- START: Notes Popup Styles --- */
#notes-popup-backdrop {
    position: fixed;
    inset: 0;
    background-color: var(--parchment-overlay); /* Parchment/papyrus overlay */
    backdrop-filter: blur(2px); /* Optional subtle blur */
    -webkit-backdrop-filter: blur(2px);
    z-index: 10010; /* Higher than iframe popup */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
    cursor: pointer; /* Click backdrop to close */
}

#notes-popup-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    width: 90vw; /* Responsive width */
    height: 90vh; /* Responsive height */
    max-width: 700px; /* Limit max width */
    max-height: 900px; /* Limit max height */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10011; /* Above backdrop */
    opacity: 0;
    visibility: hidden;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out, visibility 0s linear 0.3s;
    pointer-events: none; /* Allow clicks through container to backdrop by default */
}

#notes-popup-backdrop.visible,
#notes-popup-container.visible {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}
#notes-popup-container.visible {
    transform: translate(-50%, -50%) scale(1);
    pointer-events: auto; /* Enable interaction with content when visible */
}

#notes-pdf-canvas-container {
    width: 100%; /* Fit container width */
    height: calc(100% - 60px); /* Adjust height to leave space for instruction */
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative; /* For button positioning */
    margin-bottom: 10px;
    pointer-events: auto; /* Canvas area can be interacted with (e.g., text selection if enabled) */
}

#notes-pdf-canvas {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    display: block;
    background-color: var(--page); /* White background for PDF page */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); /* Subtle shadow */
    border: 1px solid rgba(0,0,0,0.1); /* Faint border */
    /* No window aesthetic */
}

.notes-nav-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 44px;
    height: 44px;
    border-radius: 50%; /* Circular */
    background-color: rgba(44, 62, 80, 0.7); /* Semi-transparent dark */
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    font-size: 28px; /* Adjusted size for new symbols */
    font-weight: bold;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
    z-index: 10012; /* Above canvas */
    pointer-events: auto; /* Ensure buttons are clickable */
    user-select: none;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    padding: 0; /* Ensure padding doesn't interfere with centering */
}
.notes-nav-btn:hover {
    background-color: rgba(52, 73, 94, 0.9);
    transform: translateY(-50%) scale(1.1);
}
.notes-nav-btn:active {
    transform: translateY(-50%) scale(1);
}
.notes-nav-btn[disabled] {
    opacity: 0.4;
    cursor: not-allowed;
    pointer-events: none;
}
#notes-prev-btn {
    left: -65px; 
}
#notes-next-btn {
    right: -65px; 
}

#notes-instruction {
    background-color: rgba(44, 62, 80, 0.9); /* Dark pill background */
    color: var(--text-on-dark);
    padding: 8px 18px;
    border-radius: 20px; /* Pill shape */
    font-family: var(--font-sans);
    font-size: 13px;
    font-weight: 500;
    text-align: center;
    z-index: 10012;
    pointer-events: auto; /* Allow text selection if needed */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.15);
    margin-top: auto; /* Push to bottom of flex container */
}
/* --- END: Notes Popup Styles --- */

</style>

</head>
<body class="loading-game-active">

    <div id="loading-game-container">
        <iframe id="game-iframe" src="/chapter2-loading-game.html" title="Loading Game"></iframe>
        <p id="iframe-loading-text">Loading game...</p>
    </div>
    <button id="go-to-chapter-btn">Go to Chapter</button>


    <!-- Left Toolbar (Timelock) -->
    <div id="left-toolbar"></div>
    <div class="left-toolbar-trigger-area" id="left-toolbar-trigger-area"></div>

    <!-- Right Toolbar (Existing) -->
    <div id="new-toolbar"></div>
    <div class="toolbar-trigger-area" id="toolbar-trigger-area"></div>

    <div id="status-indicator">Status: Initializing...</div>

    <div class="main-container">
        <div class="book-spread">
            <div class="book-page left">
                <div class="canvas-container">
                    <canvas id="left-page-canvas" class="pdf-canvas"></canvas>
                    <div class="textLayer" id="left-text-layer"></div>
                    <div class="annotationLayer" id="left-annotation-layer"></div>
                    <div class="keyword-overlay-container" id="left-keyword-overlay"></div>
                </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="left-page-number"></div>
                <div class="page-loading-overlay"><div class="page-loading-spinner"></div></div>
            </div>
            <div class="book-page right placeholder-page">
                 <div class="canvas-container">
                    <canvas id="right-page-canvas" class="pdf-canvas"></canvas>
                     <div class="textLayer" id="right-text-layer"></div>
                     <div class="annotationLayer" id="right-annotation-layer"></div>
                     <div class="keyword-overlay-container" id="right-keyword-overlay"></div>
                 </div>
                <div class="page-edge-nav page-edge-left"></div>
                <div class="page-edge-nav page-edge-right"></div>
                <div class="page-number" id="right-page-number"></div>
                <div class="page-loading-overlay"><div class="page-loading-spinner"></div></div>
            </div>
        </div>
    </div>

    <div class="toc-panel" id="toc-panel"></div>
    <div class="loading-overlay" id="loading-overlay"></div>
    <div class="page-slider-container" id="page-slider-container"></div>
    <div id="page-slider-trigger-zone"></div>

    <div class="definition-popup" id="definition-popup">
        <button class="definition-popup-close" id="close-popup-btn" title="Close (Esc)">×</button>
        <div class="definition-popup-title" id="popup-word">Keyword</div>
        <div class="definition-popup-content" id="popup-definition">Loading definition...</div>
    </div>

    <!-- Alert Div (populated by JS, styled by CSS) -->
    <div id="reading-time-alert"></div>

    <!-- START: Iframe Popup HTML -->
    <div id="iframe-popup-backdrop"></div>
    <div id="iframe-popup-modal">
        <button id="close-iframe-popup-btn" title="Close (Esc)">×</button>
        <iframe id="popup-iframe" src="about:blank" title="Embedded Content"></iframe>
    </div>
    <!-- END: Iframe Popup HTML -->

    <!-- START: Notes Popup HTML -->
    <div id="notes-popup-backdrop"></div>
    <div id="notes-popup-container">
        <div id="notes-pdf-canvas-container">
            <canvas id="notes-pdf-canvas"></canvas>
            <!-- *** UPDATED BUTTON SYMBOLS *** -->
            <button id="notes-prev-btn" class="notes-nav-btn" title="Previous Notes Page">ᐸ</button>
            <button id="notes-next-btn" class="notes-nav-btn" title="Next Notes Page">ᐳ</button>
        </div>
         <!-- *** UPDATED INSTRUCTION TEXT *** -->
        <div id="notes-instruction"><em>Copy these notes into your Pyr Notebook before continuing</em></div>
    </div>
    <!-- END: Notes Popup HTML -->


<script>
    // --- START: HTML Population ---
    const boxIconSVG = `<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`;
    // Timelock Icons
    const clockOnIconSVG = `<svg class="icon icon-clock-on" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`;
    const clockOffIconSVG = `<svg class="icon icon-clock-off" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>`;

    document.getElementById('new-toolbar').innerHTML = `
        <button class="new-btn" id="back-btn" title="Go Back">↤</button>
        <button class="new-btn" id="single-page-btn" title="Single Page View" style="font-size: 28px; line-height: 1;">▯</button>
        <button class="new-btn" id="double-page-btn" title="Double Page View">◫</button>
        <button class="new-btn" id="rotate-btn" title="Rotate Content">↷</button>
        <button class="new-btn" id="time-capsule-btn" title="Time Capsule (TOC Disabled)">${boxIconSVG}</button>
    `;
    document.getElementById('left-toolbar').innerHTML = `
        <button class="new-btn" id="timelock-toggle-btn" title="Toggle Reading Time Lock (On)">
            ${clockOnIconSVG}
            ${clockOffIconSVG}
        </button>
    `;
    document.getElementById('toc-panel').innerHTML = `<div class="toc-header"><span>Table of Contents</span><button class="notes-close" id="close-toc-btn">×</button></div><div class="toc-content"><div id="toc-list">Loading...</div></div>`;
    document.getElementById('loading-overlay').innerHTML = `<div class="loading-spinner"></div><div class="loading-message">Processing...</div>`; // Kept structure
    document.getElementById('page-slider-container').innerHTML = `<div class="page-slider-track"><input type="range" id="page-slider" class="page-slider" min="1" max="1" value="1" style="--slider-percent: 0%"></div><div class="page-slider-info"><span id="current-page-display">Page 1</span> of <span id="total-pages-display">1</span></div>`;
</script>

<script>
    // --- UI Elements ---
    const definitionPopup = document.getElementById('definition-popup');
    const popupWord = document.getElementById('popup-word');
    const popupDefinition = document.getElementById('popup-definition');
    const closePopupBtn = document.getElementById('close-popup-btn');
    const statusIndicator = document.getElementById('status-indicator');
    // --- NEW UI Elements ---
    const gameIframe = document.getElementById('game-iframe');
    const goToChapterBtn = document.getElementById('go-to-chapter-btn');
    const iframeLoadingText = document.getElementById('iframe-loading-text');
    // --- Timelock UI Elements ---
    const timelockToggleButton = document.getElementById('timelock-toggle-btn');
    // --- NEW: Iframe Popup Elements ---
    const iframePopupBackdrop = document.getElementById('iframe-popup-backdrop');
    const iframePopupModal = document.getElementById('iframe-popup-modal');
    const popupIframe = document.getElementById('popup-iframe');
    const closeIframePopupBtn = document.getElementById('close-iframe-popup-btn');
    // --- NEW: Notes Popup Elements ---
    const notesPopupBackdrop = document.getElementById('notes-popup-backdrop');
    const notesPopupContainer = document.getElementById('notes-popup-container');
    const notesPdfCanvas = document.getElementById('notes-pdf-canvas');
    const notesPrevBtn = document.getElementById('notes-prev-btn');
    const notesNextBtn = document.getElementById('notes-next-btn');
    const notesInstruction = document.getElementById('notes-instruction');

    // --- State Variables ---
    let keywordDefinitions = {};
    let pageKeywords = {};
    let currentViewports = {};
    let globalFirstInstanceLocation = {};
    // --- NEW State Variables ---
    let isReaderReady = false; // Flag to track if the main PDF content is loaded
    let gameOverTimeoutId = null; // To store the timeout ID for the game over transition
    let iframeMappings = {}; // Stores { pageNum: iframeUrl }
    // --- NEW: Notes Popup State ---
    const notesMapping = { // Embedded from chapter2-notes.json
      "15": { "pdf": "chapters/ancient-history/chapter2-notes-1.pdf", "page": 1 },
      "21": { "pdf": "chapters/ancient-history/chapter2-notes-2.pdf", "page": 1 },
      "29": { "pdf": "chapters/ancient-history/chapter2-notes-3.pdf", "page": 1 },
      "35": { "pdf": "chapters/ancient-history/chapter2-notes-4.pdf", "page": 1 },
      "49": { "pdf": "chapters/ancient-history/chapter2-notes-5.pdf", "page": 1 },
      "55": { "pdf": "chapters/ancient-history/chapter2-notes-6.pdf", "page": 1 }
    };
    let currentNotesPdfDoc = null; // Holds the loaded notes PDF document
    let currentNotesPageNum = 1;   // Current page number *within* the notes PDF
    let totalNotesPages = 0;       // Total pages in the currently loaded notes PDF
    let notesPdfLoadingTask = null; // To manage notes PDF loading

    // --- Reading Time Lock State ---
    let isTimelockGloballyEnabled = true; // *** NEW: Master switch for timelock ***
    let currentPageLockStartTime = 0; // Renamed: Start time for the current lock
    let requiredReadingTime = 0; // Stores required time for current lock (pair or single even page)
    let isTimeLockActive = false; // Tracks if ANY lock is currently active
    // Stores page number where lock was completed:
    // - Double View: Stores the ODD starting page of the PAIR.
    // - Single View: Stores the EVEN page number itself.
    let completedTimeLockPages = new Set();
    let alertTimeout = null; // For the alert message


    // --- PDF.js Setup (Unchanged) ---
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    const pdfjsViewer = window['pdfjs-dist/web/pdf_viewer'];
    pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.worker.min.js';

    // Default to double page unless overridden later
    const book={title:"No Document",totalPages:0,currentPage:1,isDoublePageView:true, pdfDocument:null,outline:[]};
    const user={readingProgress:{furthestPage:1}};

    let toolbarTimer=null;
    let toolbarHover=!1;
    let leftToolbarTimer=null; // Timer for left toolbar
    let leftToolbarHover=!1;  // Hover state for left toolbar
    const pageCache=new Map();
    const MAX_CACHE_SIZE=20;
    let PAGE_PADDING=15;
    let resizeTimer;
    let sliderHideTimeout=null;

    const linkService = new pdfjsViewer.SimpleLinkService();
    const eventBus = new pdfjsViewer.EventBus();

    const updateStatus=m=>console.log(`[Viewer Status] ${m}`);
    // const updateStatus = () => {}; // Production

    // --- Toolbar Logic ---
    function manageToolbar(s=null){const t=document.getElementById('new-toolbar');if(!t || document.body.classList.contains('loading-game-active'))return;clearTimeout(toolbarTimer);const show=s??toolbarHover;if(show){t.classList.add('visible')}else{toolbarTimer=setTimeout(()=>{if(!toolbarHover)t.classList.remove('visible')},500)}}
    function setupToolbarHover(){const t=document.getElementById('new-toolbar'),a=document.getElementById('toolbar-trigger-area'),h=t;if(!t||!a){console.error("Right Toolbar/trigger missing");return}const enter=()=>{if(document.body.classList.contains('loading-game-active')) return; toolbarHover=true;manageToolbar(true)};const leave=()=>{toolbarHover=false;manageToolbar(false)};a.addEventListener('mouseenter',enter);t.addEventListener('mouseenter',enter);a.addEventListener('mouseleave',leave);t.addEventListener('mouseleave',leave);h.addEventListener('click',e=>{if(document.body.classList.contains('loading-game-active')) return; if(e.target.closest('.new-btn'))return;const r=h.getBoundingClientRect();let c=false;const w=25;/* Removed rotated check as handle is always vertical now */ if(e.clientY>=r.top&&e.clientY<=r.bottom&&e.clientX<r.left&&e.clientX>=r.left-w)c=true; if(c){toolbarHover=!t.classList.contains('visible');manageToolbar()}});updateStatus("Right Toolbar setup.")}

    // --- NEW: Left Toolbar Logic ---
    function manageLeftToolbar(s=null){const t=document.getElementById('left-toolbar');if(!t || document.body.classList.contains('loading-game-active'))return;clearTimeout(leftToolbarTimer);const show=s??leftToolbarHover;if(show){t.classList.add('visible')}else{leftToolbarTimer=setTimeout(()=>{if(!leftToolbarHover)t.classList.remove('visible')},500)}}
    function setupLeftToolbarHover(){const t=document.getElementById('left-toolbar'),a=document.getElementById('left-toolbar-trigger-area'),h=t;if(!t||!a){console.error("Left Toolbar/trigger missing");return}const enter=()=>{if(document.body.classList.contains('loading-game-active')) return; leftToolbarHover=true;manageLeftToolbar(true)};const leave=()=>{leftToolbarHover=false;manageLeftToolbar(false)};a.addEventListener('mouseenter',enter);t.addEventListener('mouseenter',enter);a.addEventListener('mouseleave',leave);t.addEventListener('mouseleave',leave);h.addEventListener('click',e=>{if(document.body.classList.contains('loading-game-active')) return; if(e.target.closest('.new-btn'))return;const r=h.getBoundingClientRect();let c=false;const w=25;if(e.clientY>=r.top&&e.clientY<=r.bottom&&e.clientX>r.right&&e.clientX<=r.right+w)c=true; if(c){leftToolbarHover=!t.classList.contains('visible');manageLeftToolbar()}});updateStatus("Left Toolbar setup.")}
    // --- END: Left Toolbar Logic ---

    // --- Caching & Page Loading (Unchanged) ---
    function trimCache(){while(pageCache.size>MAX_CACHE_SIZE){pageCache.delete(pageCache.keys().next().value);}}
    function showPageLoading(canvasId){const o=document.getElementById(canvasId)?.closest('.book-page')?.querySelector('.page-loading-overlay');if(o)o.style.display='flex';}
    function hidePageLoading(canvasId){const o=document.getElementById(canvasId)?.closest('.book-page')?.querySelector('.page-loading-overlay');if(o)o.style.display='none';}


    // --- createKeywordOverlays FUNCTION (Unchanged - Click logic remains, but CSS will disable it in rotated mode) ---
    async function createKeywordOverlays(pageNum, pageElement, viewport) {
        const overlayContainerId = pageElement.classList.contains('left') ? 'left-keyword-overlay' : 'right-keyword-overlay';
        const overlayContainer = document.getElementById(overlayContainerId);
        const canvasContainer = pageElement.querySelector('.canvas-container');

        if (!book.pdfDocument || !overlayContainer || !canvasContainer) {
            console.warn(`Skipping keyword overlay for page ${pageNum}: Missing elements.`); return;
        }
        overlayContainer.innerHTML = ''; // Clear previous highlights

        const keywordsForPage = pageKeywords[pageNum.toString()] || [];
        if (keywordsForPage.length === 0) {
             return; // No keywords for this page
        }

        const lowerCaseKeywords = keywordsForPage.map(k => k.toLowerCase());
        const lowerCaseDefs = {};
        for (const key in keywordDefinitions) { lowerCaseDefs[key.toLowerCase()] = keywordDefinitions[key]; }

        try {
            const page = await book.pdfDocument.getPage(pageNum);
            const textContent = await page.getTextContent({ normalizeWhitespace: true });
            let foundKeywordOnPage = false;

            const items = textContent.items;
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const item = items[itemIndex];
                const itemText = item.str;
                const itemTextLength = itemText.length;
                if (!itemText || itemText.trim().length === 0 || itemTextLength === 0 || item.width === 0) continue;

                keywordsForPage.forEach((originalKeyword, keywordIndex) => {
                    const keywordLower = lowerCaseKeywords[keywordIndex];
                    const definition = lowerCaseDefs[keywordLower];
                    if (!definition) return;

                    const escapedKeyword = originalKeyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    const regex = new RegExp(`\\b(${escapedKeyword})\\b`, 'gi');
                    let match;

                    while ((match = regex.exec(itemText)) !== null) {
                        const matchedString = match[1];
                        const matchIndex = match.index;
                        const matchLength = matchedString.length;

                        if (matchLength === 0) {
                            regex.lastIndex++; continue;
                        }

                        const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                        const itemWidth = item.width;
                        const itemHeight = item.height;
                        const itemLeft = tx[4];
                        const itemTop = tx[5] - itemHeight; // Adjust based on baseline

                        const highlightOffsetX = (matchIndex / itemTextLength) * itemWidth;
                        const highlightWidth = (matchLength / itemTextLength) * itemWidth;

                        const finalLeft = Math.max(0, itemLeft + highlightOffsetX);
                        const finalTop = Math.max(0, itemTop);
                        const finalWidth = Math.max(1, highlightWidth);
                        // Height calculation needs care, use item.height or font size if available
                        const finalHeight = itemHeight > 0 ? itemHeight : parseFloat(getComputedStyle(overlayContainer).fontSize) || 12;


                        const highlightDiv = document.createElement('div');
                        highlightDiv.className = 'keyword-highlight';
                        highlightDiv.style.left = `${finalLeft}px`;
                        highlightDiv.style.top = `${finalTop}px`;
                        highlightDiv.style.width = `${finalWidth}px`;
                        highlightDiv.style.height = `${finalHeight}px`;
                        highlightDiv.dataset.keyword = originalKeyword;
                        highlightDiv.dataset.definition = definition;
                        highlightDiv.title = `Definition: ${originalKeyword}`;

                        const firstLoc = globalFirstInstanceLocation[keywordLower];
                        let isTheFirstInstance = false;
                        if (firstLoc &&
                            firstLoc.pageNum === pageNum &&
                            firstLoc.itemIndex === itemIndex &&
                            firstLoc.matchIndex === matchIndex) {
                            isTheFirstInstance = true;
                        }

                        if (isTheFirstInstance) {
                            highlightDiv.classList.add('first-keyword-instance');
                        }

                        // Click listener is still added, but CSS will prevent interaction in rotated mode
                        highlightDiv.addEventListener('click', (e) => {
                            // Note: This event might not fire in rotated mode due to CSS pointer-events: none
                            e.stopPropagation();
                            const currentHighlight = e.currentTarget;
                            const word = currentHighlight.dataset.keyword;
                            const def = currentHighlight.dataset.definition;
                            const rect = currentHighlight.getBoundingClientRect();
                            showDefinitionPopup(word, def, rect);
                        });
                        overlayContainer.appendChild(highlightDiv);
                        foundKeywordOnPage = true;
                    }
                });
            }
        } catch (error) {
            console.error(`Error processing text content for keyword overlays on page ${pageNum}:`, error);
            overlayContainer.innerHTML = '';
        }
    }
    // --- END: createKeywordOverlays FUNCTION ---


    // --- Simplified Base Text Layer Rendering (Unchanged) ---
    async function renderAndEnhanceTextLayer(page, container, viewport) {
      if (!page || !container || !viewport) return;
      container.innerHTML = '';
      container.style.pointerEvents = 'none'; container.style.color = 'transparent';
      try {
        const textContent = await page.getTextContent({normalizeWhitespace: true});
        const renderTask = pdfjsLib.renderTextLayer({ textContent, container, viewport });
        await renderTask.promise;
      } catch (error) {
        console.error(`Error rendering base text layer for page ${page.pageNumber}:`, error);
        container.innerHTML = '';
      }
    }

    // --- Annotation Layer Rendering (Unchanged) ---
    async function renderAnnotationLayer(page, container, viewport) {
        if (!page || !container || !viewport) { console.warn("Skipping annotation layer: params missing."); return }
        container.innerHTML = '';
        try {
            const annotations = await page.getAnnotations();
            if (annotations.length === 0) return;
            pdfjsLib.AnnotationLayer.render({
                viewport: viewport.clone({ dontFlip: true }), div: container,
                annotations: annotations, page: page, linkService: linkService
            });
        } catch (error) {
            console.error(`Error rendering annotation layer for page ${page.pageNumber}:`, error);
            container.innerHTML = '';
        }
    }

    // --- renderPage function (Unchanged) ---
    async function renderPage(pageNum, canvasId) {
        const canvas = document.getElementById(canvasId); const ctx = canvas?.getContext('2d');
        const canvasContainer = canvas?.closest('.canvas-container');
        const textLayerContainer = canvasContainer?.querySelector('.textLayer');
        const annotationLayerContainer = canvasContainer?.querySelector('.annotationLayer');
        const keywordOverlayContainer = canvasContainer?.querySelector('.keyword-overlay-container');
        const pageElement = canvas?.closest('.book-page');

        delete currentViewports[canvasId];
        if (textLayerContainer) textLayerContainer.innerHTML = '';
        if (annotationLayerContainer) annotationLayerContainer.innerHTML = '';
        if (keywordOverlayContainer) keywordOverlayContainer.innerHTML = '';

        if (!book.pdfDocument || !canvas || !ctx || !canvasContainer || !textLayerContainer || !annotationLayerContainer || !keywordOverlayContainer || !pageElement || pageNum < 1 || pageNum > book.totalPages) {
            if (canvas && ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (pageElement) pageElement.classList.add('placeholder-page');
            hidePageLoading(canvasId); return;
        }

        showPageLoading(canvasId); pageElement.classList.remove('placeholder-page');
        let page; let viewport;

        try {
            if (pageCache.has(pageNum)) {
                const cachedData = pageCache.get(pageNum);
                canvas.width = cachedData.width; canvas.height = cachedData.height;
                canvas.style.width = `${cachedData.styleWidth}px`; canvas.style.height = `${cachedData.styleHeight}px`;
                ctx.putImageData(cachedData.imageData, 0, 0);
                page = await book.pdfDocument.getPage(pageNum);
                viewport = cachedData.viewport;
                currentViewports[canvasId] = viewport; pageCache.delete(pageNum); pageCache.set(pageNum, cachedData);
                hidePageLoading(canvasId);
            } else {
                page = await book.pdfDocument.getPage(pageNum);
                const containerStyle = getComputedStyle(canvasContainer);
                const availableWidth = parseFloat(containerStyle.width);
                const availableHeight = parseFloat(containerStyle.height);
                if (availableWidth <= 0 || availableHeight <= 0) {
                    console.warn(`Canvas container ${canvasId} has zero dimensions during renderPage call for page ${pageNum}. Skipping render.`);
                    hidePageLoading(canvasId);
                    return;
                }

                const defaultViewport = page.getViewport({ scale: 1 });
                const scale = Math.min(availableWidth / defaultViewport.width, availableHeight / defaultViewport.height);
                viewport = page.getViewport({ scale: scale });
                currentViewports[canvasId] = viewport;

                const outputScale = window.devicePixelRatio || 1;
                canvas.width = Math.floor(viewport.width * outputScale);
                canvas.height = Math.floor(viewport.height * outputScale);
                canvas.style.width = `${Math.floor(viewport.width)}px`;
                canvas.style.height = `${Math.floor(viewport.height)}px`;

                const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
                await page.render({ canvasContext: ctx, transform, viewport }).promise;

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                pageCache.set(pageNum, { imageData, width: canvas.width, height: canvas.height, styleWidth: Math.floor(viewport.width), styleHeight: Math.floor(viewport.height), viewport });
                trimCache();
                hidePageLoading(canvasId);
            }

            // Render layers after canvas is ready
            await renderAndEnhanceTextLayer(page, textLayerContainer, viewport);
            await renderAnnotationLayer(page, annotationLayerContainer, viewport);
            await createKeywordOverlays(pageNum, pageElement, viewport); // Ensure this uses the final viewport

        } catch (error) {
            console.error(`Error rendering page ${pageNum} on ${canvasId}:`, error);
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
            hidePageLoading(canvasId);
            pageElement?.classList.add('placeholder-page');
        }
    }

    // --- Reading Time Calculation (Unchanged) ---
    async function calculatePageReadingTime(pageNum, viewport) {
        if (!book.pdfDocument || !viewport || pageNum < 1 || pageNum > book.totalPages) {
            return 0;
        }
        try {
            const page = await book.pdfDocument.getPage(pageNum);
            // Fetch text content and annotations concurrently
            const [textContent, annotations] = await Promise.all([
                page.getTextContent({ normalizeWhitespace: true }),
                page.getAnnotations()
            ]);

            const linkAnnotations = annotations.filter(annot => annot.subtype === 'Link' && annot.rect);
            // Convert annotation rects (PDF points) to viewport rects (CSS pixels)
            const linkRectsInViewport = linkAnnotations.map(annot => viewport.convertToViewportRectangle(annot.rect));
            // convertToViewportRectangle returns [x1, y1, x2, y2] in CSS pixels, y increases downwards

            let wordCount = 0;
            for (const item of textContent.items) {
                const itemText = item.str;
                if (!itemText || itemText.trim().length === 0 || item.width === 0) continue;

                // Calculate item's bounding box in CSS pixels using its transform and the viewport transform
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                // item.transform gives [scaleX, skewY, skewX, scaleY, translateX, translateY]
                // origin is usually bottom-left in PDF space? Viewport transform converts to CSS space.
                const itemWidth = item.width;
                 // item.height is often ascent+descent, use it if available, otherwise estimate
                const itemHeight = item.height > 0 ? item.height : 12; // Default guess if height invalid
                const itemLeft = tx[4];
                const itemTop = tx[5] - itemHeight; // Approximate top edge in CSS space (y increases down)
                // CSS Bbox: [left, top, right, bottom]
                const itemRect = [itemLeft, itemTop, itemLeft + itemWidth, itemTop + itemHeight];

                let isInsideLink = false;
                for (const linkRect of linkRectsInViewport) {
                    // linkRect is [x1, y1, x2, y2] in CSS pixels (from convertToViewportRectangle)
                    // Check if the center of the item falls within the link rectangle
                    const itemCenterX = itemRect[0] + (itemRect[2] - itemRect[0]) / 2;
                    const itemCenterY = itemRect[1] + (itemRect[3] - itemRect[1]) / 2;

                    if (itemCenterX >= linkRect[0] && itemCenterX <= linkRect[2] &&
                        itemCenterY >= linkRect[1] && itemCenterY <= linkRect[3]) {
                        isInsideLink = true;
                        break; // Found overlap, no need to check other links for this item
                    }
                    // Note: This 'center point' method might miss text items that are partially
                    // inside a link but whose center is outside. A full overlap check is more complex.
                    // For simplicity and performance, we use the center point check.
                }

                if (!isInsideLink) {
                    // Count words by splitting on whitespace
                    wordCount += itemText.trim().split(/\s+/).filter(Boolean).length;
                }
            }
            const readingTimeSeconds = Math.ceil(wordCount / 5); // 1 second per 5 words
             // console.log(`Page ${pageNum} word count (non-link): ${wordCount}, Time: ${readingTimeSeconds}s`);
            return readingTimeSeconds;

        } catch (error) {
            console.error(`Error calculating reading time for page ${pageNum}:`, error);
            return 0; // Default to 0 time on error
        }
    }

    // --- Update Display (MODIFIED - Checks for iframe AND notes popups) ---
    async function updateDisplay() {
        if (!book.pdfDocument) { updateStatus("UpdateDisplay skipped: No PDF loaded."); return; }
        const leftPageNum = book.currentPage;
        // Determine right page number based on *intended* double page view, may not be displayed
        const potentialRightPageNum = book.isDoublePageView ? book.currentPage + 1 : 0;

        updateStatus(`Updating display for page(s): Start=${leftPageNum}${potentialRightPageNum > 0 ? ' (Intended Double View)' : ''}`);

        const leftPageDiv = document.querySelector('.book-page.left');
        const rightPageDiv = document.querySelector('.book-page.right');
        const leftPageNumDisplay = document.getElementById('left-page-number');
        const rightPageNumDisplay = document.getElementById('right-page-number');
        if (!leftPageDiv || !rightPageDiv || !leftPageNumDisplay || !rightPageNumDisplay) {
            console.error("Critical page elements missing!"); return;
        }

        // *** Determine effective view mode ***
        const isFullscreen = document.body.classList.contains('fullscreen-mode');
        const isContentRotated = document.body.classList.contains('content-rotated-mode');
        const isEffectiveDoublePageView = book.isDoublePageView && !isFullscreen && !isContentRotated;
        updateStatus(`Effective View Mode: ${isEffectiveDoublePageView ? 'Double' : 'Single'}`);

        let renderPromises = [];

        // *** Reset current lock state before evaluation ***
        isTimeLockActive = false;
        currentPageLockStartTime = 0; // Use renamed variable
        requiredReadingTime = 0;
        // *** END Reset time lock state ***

        // --- Render Pages ---
        // Render Left Page (Always attempt if in range)
        if (leftPageNum >= 1 && leftPageNum <= book.totalPages) {
            leftPageNumDisplay.textContent = String(leftPageNum);
            renderPromises.push(renderPage(leftPageNum, 'left-page-canvas'));
        } else {
            // Clear left page if out of bounds
            leftPageNumDisplay.textContent = ''; const lCanvas = document.getElementById('left-page-canvas'), lCtx = lCanvas?.getContext('2d'); if (lCtx) lCtx.clearRect(0, 0, lCanvas.width, lCanvas.height); const lTextLayer = document.getElementById('left-text-layer'), lAnnLayer = document.getElementById('left-annotation-layer'), lKeywordOverlay = document.getElementById('left-keyword-overlay'); if(lTextLayer) lTextLayer.innerHTML = ''; if(lAnnLayer) lAnnLayer.innerHTML = ''; if(lKeywordOverlay) lKeywordOverlay.innerHTML = ''; leftPageDiv.classList.add('placeholder-page'); delete currentViewports['left-page-canvas'];
        }

        // Prepare Right Page (Clear and hide initially)
        rightPageDiv.style.display = 'none'; rightPageDiv.classList.remove('placeholder-page'); const rCanvas = document.getElementById('right-page-canvas'), rCtx = rCanvas?.getContext('2d'); if (rCtx) rCtx.clearRect(0, 0, rCanvas.width, rCanvas.height); const rTextLayer = document.getElementById('right-text-layer'), rAnnLayer = document.getElementById('right-annotation-layer'), rKeywordOverlay = document.getElementById('right-keyword-overlay'); if(rTextLayer) rTextLayer.innerHTML = ''; if(rAnnLayer) rAnnLayer.innerHTML = ''; if(rKeywordOverlay) rKeywordOverlay.innerHTML = ''; rightPageNumDisplay.textContent = ''; delete currentViewports['right-page-canvas'];

        // Determine if right page should be shown and rendered
        let actualRightPageNum = 0;
        if (isEffectiveDoublePageView) {
            actualRightPageNum = potentialRightPageNum; // Use the potential right page number
            if (actualRightPageNum >= 1 && actualRightPageNum <= book.totalPages) {
                // Valid right page number exists
                rightPageNumDisplay.textContent = String(actualRightPageNum);
                rightPageDiv.style.display = 'flex'; // Show the div
                renderPromises.push(renderPage(actualRightPageNum, 'right-page-canvas'));
            } else if (leftPageNum >= 1 && leftPageNum <= book.totalPages) {
                // Left page is valid, but right page is out of bounds (end of book)
                rightPageDiv.style.display = 'flex'; // Show the div
                rightPageDiv.classList.add('placeholder-page'); // Mark as placeholder
                rightPageNumDisplay.textContent = '';
                actualRightPageNum = 0; // Treat as no actual right page for time calc
            }
        }

        // Wait for pages to render
        await Promise.all(renderPromises);
        // --- END Render Pages ---

        // --- Manage Edge Navigation Button Visibility (Based on effective view) ---
        const leftEdgeNavLeft = leftPageDiv?.querySelector('.page-edge-left');
        const leftEdgeNavRight = leftPageDiv?.querySelector('.page-edge-right');
        const rightEdgeNavLeft = rightPageDiv?.querySelector('.page-edge-left');
        const rightEdgeNavRight = rightPageDiv?.querySelector('.page-edge-right');

        if (leftEdgeNavLeft) leftEdgeNavLeft.style.display = ''; // Always show outer left
        if (rightEdgeNavRight) rightEdgeNavRight.style.display = 'none'; // Assume hidden initially
        if (leftEdgeNavRight) leftEdgeNavRight.style.display = 'none';
        if (rightEdgeNavLeft) rightEdgeNavLeft.style.display = 'none';

        if (isEffectiveDoublePageView) {
             if (rightEdgeNavRight) rightEdgeNavRight.style.display = ''; // Show outer right
            // Hide inner buttons
            if (leftEdgeNavRight) leftEdgeNavRight.style.display = 'none';
            if (rightEdgeNavLeft) rightEdgeNavLeft.style.display = 'none';
            // Hide right buttons if it's a placeholder
            if (rightPageDiv?.classList.contains('placeholder-page')) {
                if (rightEdgeNavLeft) rightEdgeNavLeft.style.display = 'none';
                if (rightEdgeNavRight) rightEdgeNavRight.style.display = 'none';
            }
        } else { // Effective Single Page View
            if (leftEdgeNavRight) leftEdgeNavRight.style.display = ''; // Show right button on the single page
            // Ensure outer right and all right page buttons are hidden
            if (rightEdgeNavLeft) rightEdgeNavLeft.style.display = 'none';
            if (rightEdgeNavRight) rightEdgeNavRight.style.display = 'none';
        }
        // --- END Manage Edge Navigation Button Visibility ---


        // *** Calculate and set reading time lock based on EFFECTIVE view mode ***
        // *** ONLY if timelock is globally enabled ***
        if (isTimelockGloballyEnabled) {
            if (isEffectiveDoublePageView) {
                // --- Double Page View Lock Logic ---
                const leftViewport = currentViewports['left-page-canvas'];
                const rightViewport = currentViewports['right-page-canvas']; // Will be null if right page isn't rendered

                let timeLeft = 0;
                if (leftPageNum >= 1 && leftPageNum <= book.totalPages && leftViewport) {
                    timeLeft = await calculatePageReadingTime(leftPageNum, leftViewport);
                }
                let timeRight = 0;
                // Only add right page time if it was actually rendered (not placeholder)
                if (actualRightPageNum > 0 && rightViewport) {
                    timeRight = await calculatePageReadingTime(actualRightPageNum, rightViewport);
                }

                const timeForPair = timeLeft + timeRight;
                const firstPageOfCurrentPair = leftPageNum; // Lock associated with the ODD starting page

                if (completedTimeLockPages.has(firstPageOfCurrentPair)) {
                    updateStatus(`Time lock previously completed for pair starting ${firstPageOfCurrentPair}. Skipping set.`);
                    // isTimeLockActive remains false
                } else if (timeForPair > 0) {
                    requiredReadingTime = timeForPair; // Set required time for the pair
                    currentPageLockStartTime = Date.now();
                    isTimeLockActive = true; // Activate lock for the PAIR
                    updateStatus(`Time lock SET (Double View - Pair) for pair starting ${firstPageOfCurrentPair}. Time: ${requiredReadingTime}s`);
                } else {
                    updateStatus(`Time lock NOT SET for pair starting ${firstPageOfCurrentPair} (time=0 or already completed).`);
                    // isTimeLockActive remains false
                }
                // --- End Double Page View Lock Logic ---

            } else {
                // --- Single Page / Rotated View Lock Logic ---
                const currentPageNum = leftPageNum; // The single page being displayed
                const isEvenPage = currentPageNum > 0 && currentPageNum % 2 === 0;

                if (isEvenPage) {
                    // Only potentially lock if the *current* page is EVEN
                    if (completedTimeLockPages.has(currentPageNum)) {
                        updateStatus(`Time lock previously completed for single page ${currentPageNum}. Skipping set.`);
                        // isTimeLockActive remains false
                    } else {
                        const singlePageViewPort = currentViewports['left-page-canvas'];
                        let timeSingle = 0;
                        if (currentPageNum >= 1 && currentPageNum <= book.totalPages && singlePageViewPort) {
                            timeSingle = await calculatePageReadingTime(currentPageNum, singlePageViewPort);
                        }

                        if (timeSingle > 0) {
                            requiredReadingTime = timeSingle; // Store single EVEN page time
                            currentPageLockStartTime = Date.now();
                            isTimeLockActive = true; // Activate lock for this EVEN page
                            updateStatus(`Time lock SET (Single View - Even Page) for page ${currentPageNum}. Time: ${requiredReadingTime}s`);
                        } else {
                            updateStatus(`Time lock NOT SET for single page ${currentPageNum} (time=0 or already completed).`);
                            // isTimeLockActive remains false
                        }
                    }
                } else {
                    // Current page is odd or invalid, no lock needed when viewing it in single view
                    updateStatus(`Time lock NOT APPLICABLE (Single View - Odd/Invalid Page) for page ${currentPageNum}.`);
                    // isTimeLockActive remains false
                }
                // --- End Single Page / Rotated View Lock Logic ---
            }
        } else {
            // Timelock is globally disabled, ensure no lock is set
            isTimeLockActive = false;
            requiredReadingTime = 0;
            currentPageLockStartTime = 0;
            updateStatus("Time lock globally DISABLED. Skipping lock calculation/set.");
        }
        // --- End Reading Time Logic ---

        updateSliderPosition(); // Update slider based on new state
        preloadAdjacentPages(book.currentPage); // Preload based on start page
        applyCurrentViewModeStyles(); // Ensure scaling/rotation is correct

        // --- *** NEW: Check for Iframe OR Notes Popup *** ---
        // Prioritize Notes Popup if applicable for the current page
        let shouldShowNotesPopup = false;
        if (leftPageNum >= 1 && leftPageNum <= book.totalPages) {
            const notesInfo = notesMapping[leftPageNum.toString()];
            if (notesInfo) {
                updateStatus(`Notes Popup found for page ${leftPageNum}. Showing.`);
                showNotesPopup(notesInfo.pdf, notesInfo.page);
                shouldShowNotesPopup = true;
            } else {
                hideNotesPopupIfNeeded(); // Hide notes if navigating away from a notes page
            }
        } else {
             hideNotesPopupIfNeeded(); // Hide notes if current page is invalid
        }

        // Show Iframe Popup ONLY IF Notes Popup is NOT shown for the current page
        if (!shouldShowNotesPopup && leftPageNum >= 1 && leftPageNum <= book.totalPages) {
            const iframeUrl = iframeMappings[leftPageNum.toString()];
            if (iframeUrl) {
                updateStatus(`Iframe Popup found for page ${leftPageNum}. Showing.`);
                showIframePopup(iframeUrl);
            } else {
                hideIframePopupIfNeeded(); // Hide iframe if navigating away
            }
        } else if (shouldShowNotesPopup) {
            // Ensure iframe popup is hidden if notes popup is being shown
             hideIframePopupIfNeeded();
        } else {
             hideIframePopupIfNeeded(); // Hide iframe if current page is invalid
        }
        // --- *** END: Check for Popups *** ---


        updateStatus("Display update complete.");
    }


    // --- Preloading (Unchanged) ---
     function preloadAdjacentPages(currentPage) {
        if (!book.pdfDocument) return;
        // Determine lookahead based on *intended* view mode for efficiency
        const lookahead = book.isDoublePageView ? 2 : 1;
        const pagesToPreload = [];
        for (let i = 1; i <= lookahead; i++) { const nextPage = currentPage + (book.isDoublePageView ? i * 2 : i); if (nextPage <= book.totalPages) { pagesToPreload.push(nextPage); if (book.isDoublePageView && nextPage + 1 <= book.totalPages) pagesToPreload.push(nextPage + 1); } }
        for (let i = 1; i <= lookahead; i++) { const prevPage = currentPage - (book.isDoublePageView ? i * 2 : i); if (prevPage >= 1) { pagesToPreload.push(prevPage); if (book.isDoublePageView && prevPage + 1 <= book.totalPages && prevPage + 1 < currentPage) pagesToPreload.push(prevPage + 1); } }
        const uniquePages = [...new Set(pagesToPreload)].filter(p => p > 0 && p <= book.totalPages && !pageCache.has(p)); if (uniquePages.length === 0) return;
        uniquePages.forEach(pageNum => {
            book.pdfDocument.getPage(pageNum).then(page => {
                const defaultViewport = page.getViewport({ scale: 1 }); const simWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w')) - (2 * PAGE_PADDING); const simHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h')) - (2 * PAGE_PADDING); const scale = Math.min(simWidth / defaultViewport.width, simHeight / defaultViewport.height, 1); const viewport = page.getViewport({ scale: scale }); const tempCanvas = document.createElement('canvas'), tempCtx = tempCanvas.getContext('2d'); const outputScale = window.devicePixelRatio || 1; tempCanvas.width = Math.floor(viewport.width * outputScale); tempCanvas.height = Math.floor(viewport.height * outputScale); const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
                page.render({ canvasContext: tempCtx, transform: transform, viewport: viewport }).promise.then(() => { if (!pageCache.has(pageNum)) { const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height); pageCache.set(pageNum, { imageData, width: tempCanvas.width, height: tempCanvas.height, styleWidth: Math.floor(viewport.width), styleHeight: Math.floor(viewport.height), viewport }); trimCache(); } }).catch(err => console.warn(`Preloading page ${pageNum} failed: ${err.message}`));
            }).catch(err => console.warn(`Failed to get page ${pageNum} for preloading: ${err.message}`));
        });
    }

    // --- Reading Time Alert (MODIFIED: Checks global enabled state) ---
    function showReadingTimeAlert() {
        // Only show alert if timelock is globally enabled and blocking
        if (!isTimelockGloballyEnabled) return;

        clearTimeout(alertTimeout);
        let alertDiv = document.getElementById('reading-time-alert');
        if (!alertDiv) { return; } // Should exist after init

        alertDiv.textContent = 'Please read the text!';
        alertDiv.classList.add('visible'); // Add class to trigger fade-in and wiggle animation via CSS

        alertTimeout = setTimeout(() => {
            alertDiv.classList.remove('visible'); // Remove class to trigger fade-out
        }, 2500); // Show for 2.5 seconds
    }

    // --- Reading Time Lock Check (MODIFIED: Checks global enabled state first) ---
    function checkReadingTimeLock() {
        // Called by jumpToPage only when moving forward.

        // *** FIRST: Check if timelock is globally enabled ***
        if (!isTimelockGloballyEnabled) {
            updateStatus(`Time lock check: Globally DISABLED. Allowing navigation.`);
            return false; // Not blocking
        }

        if (!isTimeLockActive) {
            // No lock is currently active (either pair or single even page), so allow navigation.
            updateStatus(`Time lock check: Lock is INACTIVE. Allowing navigation.`);
            return false; // Not blocking
        }

        // A lock IS active.
        const elapsedSeconds = (Date.now() - currentPageLockStartTime) / 1000;
        // 'book.currentPage' holds the page number the active lock is associated with
        // (odd start for pair lock, even page num for single lock) as set by updateDisplay.
        const lockAssociatedPage = book.currentPage;

        if (elapsedSeconds < requiredReadingTime) {
            // Time is NOT up. Block navigation.
            updateStatus(`Time lock ACTIVE (Page/Pair ${lockAssociatedPage}): ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Blocking forward nav.`);
            showReadingTimeAlert(); // Alert will only show if globally enabled due to its own check
            return true; // Indicate lock IS preventing navigation
        } else {
            // Time IS up. Allow navigation and handle completion.
            updateStatus(`Time lock FINISHED (Page/Pair ${lockAssociatedPage}): ${elapsedSeconds.toFixed(1)}s / ${requiredReadingTime}s. Allowing forward nav.`);

            // Mark completion for this page/pair permanently in the Set using the associated page number.
            if (!completedTimeLockPages.has(lockAssociatedPage)) {
                completedTimeLockPages.add(lockAssociatedPage);
                updateStatus(`Page/Pair ${lockAssociatedPage} added to completed time lock set.`);
            }

            // Important: Deactivate lock for this *specific check*.
            // updateDisplay will reset isTimeLockActive anyway before potentially setting a new one for the *next* page view.
            isTimeLockActive = false; // Lock is passed/completed *for this navigation attempt*.
            requiredReadingTime = 0; // Reset required time as well
            currentPageLockStartTime = 0;
            return false; // Indicate lock is NOT preventing navigation for this attempt
        }
    }


    // --- Navigation (Uses modified checkReadingTimeLock) ---
    function nextPage() {
        // Determine increment based on *effective* view mode at the moment of click/keypress
        const isFullscreen = document.body.classList.contains('fullscreen-mode');
        const isContentRotated = document.body.classList.contains('content-rotated-mode');
        const isEffectiveDoublePageView = book.isDoublePageView && !isFullscreen && !isContentRotated;

        const currentActualPage = book.currentPage; // The currently displayed start page
        const jumpIncrement = isEffectiveDoublePageView ? 2 : 1;
        const targetPageForJump = currentActualPage + jumpIncrement;

        // Ensure the calculated target is within bounds before attempting jump
        if (targetPageForJump <= book.totalPages) {
            jumpToPage(targetPageForJump); // Let jumpToPage handle the final lock check and adjustments
        } else if (currentActualPage < book.totalPages && !isEffectiveDoublePageView) {
             // If in single view and calculated jump goes too far, try jumping to the very last page
             jumpToPage(book.totalPages);
        } else if (currentActualPage < book.totalPages && isEffectiveDoublePageView && targetPageForJump > book.totalPages && currentActualPage % 2 !== 0) {
            // If in double view, current page is odd, and adding 2 goes past the end,
            // try jumping to the last page (which will display as a single page on the left)
            jumpToPage(book.totalPages);
        }
        // In other cases (e.g., double view, current page is already last or second-to-last), we just don't navigate.
    }


    function prevPage(){
        // No time lock for going backwards
        const isFullscreen = document.body.classList.contains('fullscreen-mode');
        const isContentRotated = document.body.classList.contains('content-rotated-mode');
        // Use *effective* view mode to determine decrement
        const isEffectiveDoublePageView = book.isDoublePageView && !isFullscreen && !isContentRotated;

        const dec = isEffectiveDoublePageView ? 2 : 1;
        const targetPage = book.currentPage - dec;
        if(targetPage >= 1) jumpToPage(targetPage);
        else if (book.currentPage > 1) jumpToPage(1); // Go to first page if decrement goes below 1
    }

    // MODIFIED jumpToPage to hide ALL popups before jump
    function jumpToPage(pageNum){
        if (!book.pdfDocument || pageNum < 1 || pageNum > book.totalPages){
            console.warn(`Jump to page ${pageNum} out of bounds (1-${book.totalPages})`);
            return;
        }

        // Determine the target *starting page* for the view, adjusting for double page view INTENTION
        // This ensures that jumping to an even page in intended double view correctly targets the previous odd page.
        let targetStartPage = pageNum;
        if (book.isDoublePageView && targetStartPage > 1 && targetStartPage % 2 === 0) {
            targetStartPage--;
        }

        const currentStartPage = book.currentPage; // The start page of the *current* view
        if (targetStartPage === currentStartPage) {
             updateStatus(`Jump target (${targetStartPage}) is same as current (${currentStartPage}). No action.`);
             // Reset slider visually if it was the source of the no-op jump
             if (document.activeElement === document.getElementById('page-slider')) {
                 updateSliderPosition(); // Reset slider to current page display
             }
             return;
        }

        // --- Refined Lock Check Logic ---
        const isMovingForward = targetStartPage > currentStartPage;

        // Check lock ONLY if moving forward. checkReadingTimeLock handles global enable state and view mode specifics internally.
        if (isMovingForward) {
            updateStatus(`Moving forward from ${currentStartPage} to ${targetStartPage}. Checking time lock...`);
            if (checkReadingTimeLock()) {
                // Lock is active and time is not up, block navigation
                updateStatus(`Navigation blocked by time lock.`);
                // Reset slider if needed (e.g., user tried to slide past lock)
                const slider = document.getElementById('page-slider');
                if (slider && document.activeElement === slider) {
                    updateSliderPosition(); // Reset slider to show the current locked page
                }
                return; // Stop navigation
            }
            // If checkReadingTimeLock() returned false, the lock is passed OR was completed OR is globally disabled.
            updateStatus(`Time lock passed/completed/disabled. Proceeding with jump.`);
        } else {
            updateStatus(`Moving backward from ${currentStartPage} to ${targetStartPage}. Skipping time lock check.`);
            // Clear any active lock if moving backward, as it's no longer relevant
            if (isTimeLockActive) {
                 updateStatus("Clearing active time lock due to backward navigation.");
                 isTimeLockActive = false;
                 requiredReadingTime = 0;
                 currentPageLockStartTime = 0;
            }
        }
        // --- End Lock Check ---

        // --- Proceed with Navigation ---
        updateStatus(`Jumping to page ${targetStartPage} (requested ${pageNum})`);
        book.currentPage = targetStartPage; // Set the new *starting* page for the view

        if (isMovingForward && targetStartPage > user.readingProgress.furthestPage) {
            user.readingProgress.furthestPage = targetStartPage;
            // Optionally save progress here if needed
        }

        // --- Hide ALL popups before updating display ---
        hideDefinitionPopup();
        hideIframePopup();
        hideNotesPopup(); // Also hide notes popup
        // ---

        updateDisplay(); // Fetches, renders, and SETS THE NEXT lock state based on the new view/page(s) and global setting. Also handles showing popups if needed.
        showPageSlider(); // Show slider briefly after navigation
        manageToolbar(false); // Hide right toolbar after navigation
        manageLeftToolbar(false); // Hide left toolbar after navigation
    }


    // --- View Modes (MODIFIED to hide ALL popups) ---
    function applyCurrentViewModeStyles() {
        if (document.body.classList.contains('loading-game-active')) return;
        const isContentRotated = document.body.classList.contains('content-rotated-mode');
        const isFullscreen = document.body.classList.contains('fullscreen-mode');
        const spread = document.querySelector('.book-spread');
        if (!spread) return;

        // Determine the effective mode for scaling
        const isEffectiveSinglePage = isFullscreen || isContentRotated || !book.isDoublePageView;

        // CSS classes handle hiding the right page, this focuses on scaling/rotation
        if (isContentRotated) {
            // Rotation logic (unchanged)
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const bookWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w'));
            const bookHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h'));
            const scaleX = viewportWidth / bookHeight; // Swapped for rotation
            const scaleY = viewportHeight / bookWidth; // Swapped for rotation
            const scale = Math.min(scaleX, scaleY) * 0.98;
            spread.style.transformOrigin = 'center center';
            spread.style.transform = `translate(-50%, -50%) rotate(90deg) scale(${scale})`;
        } else {
             // Standard or Fullscreen scaling
             const viewportWidth = window.innerWidth;
             const viewportHeight = window.innerHeight;
             const bookWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-w'));
             const bookHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-h'));
             // Use effective mode to determine total width for scaling
             const totalWidth = isEffectiveSinglePage ? bookWidth : bookWidth * 2;
             const scaleX = viewportWidth / totalWidth;
             const scaleY = viewportHeight / bookHeight;
             const scale = Math.min(scaleX, scaleY) * 0.98;
             spread.style.transformOrigin = 'center center';
             spread.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }
    }

    async function setSinglePageView(){
        // Check if already effectively in single page, non-rotated mode
        const isFullscreen = document.body.classList.contains('fullscreen-mode');
        const isContentRotated = document.body.classList.contains('content-rotated-mode');
        if (!book.isDoublePageView && isFullscreen && !isContentRotated) return;

        updateStatus("Setting Single Page View (Fullscreen Mode)");
        book.isDoublePageView = false; // Set INTENDED mode
        document.body.classList.remove('content-rotated-mode'); // Ensure rotate is off
        document.body.classList.add('fullscreen-mode'); // Add fullscreen class

        hideDefinitionPopup();
        hideIframePopup();
        hideNotesPopup(); // Hide notes popup when changing view mode
        // updateDisplay will calculate lock based on the new effective single-page mode
        await updateDisplay();
        manageToolbar(false); // Hide right toolbar after action
        manageLeftToolbar(false); // Hide left toolbar after action
        updateSliderTotalPages(); // Update max pages (doesn't change, but good practice)
        updateSliderPosition(); // Update slider value and text based on new effective mode
    }

    async function setDoublePageView(){
        // Check if already effectively in double page, non-rotated mode
        const isFullscreen = document.body.classList.contains('fullscreen-mode');
        const isContentRotated = document.body.classList.contains('content-rotated-mode');
        if (book.isDoublePageView && !isFullscreen && !isContentRotated) return;

        updateStatus("Setting Double Page View");
        book.isDoublePageView = true; // Set INTENDED mode
        document.body.classList.remove('content-rotated-mode', 'fullscreen-mode'); // Remove overrides

        // Adjust current page to be odd if needed for double view start
        if (book.currentPage > 1 && book.currentPage % 2 === 0) {
            updateStatus(`Adjusting current page from ${book.currentPage} to ${book.currentPage - 1} for double view.`);
            book.currentPage--;
        }

        hideDefinitionPopup();
        hideIframePopup();
        hideNotesPopup(); // Hide notes popup when changing view mode
         // updateDisplay will calculate lock based on the new effective double-page mode
        await updateDisplay();
        manageToolbar(false); // Hide right toolbar after action
        manageLeftToolbar(false); // Hide left toolbar after action
        updateSliderTotalPages();
        updateSliderPosition(); // Update slider value and text
    }

    async function setRotatedView() {
        if (document.body.classList.contains('content-rotated-mode')) return; // Already rotated

        updateStatus("Setting Content Rotated View");
        // Intention doesn't matter as much here, but treat as single page effectively
        // book.isDoublePageView = false; // Optional: align intention with effect
        document.body.classList.remove('fullscreen-mode'); // Ensure fullscreen is off
        document.body.classList.add('content-rotated-mode'); // Add rotate class

        hideDefinitionPopup();
        hideIframePopup();
        hideNotesPopup(); // Hide notes popup when changing view mode
        // updateDisplay will calculate lock based on the new effective single-page (rotated) mode
        await updateDisplay();
        manageToolbar(false); // Hide right toolbar after action
        manageLeftToolbar(false); // Hide left toolbar after action
        updateSliderTotalPages();
        updateSliderPosition(); // Update slider value and text
    }

    // --- UI Toggles (Unchanged) ---
    function toggleElement(id,show){const el = document.getElementById(id); if(el) el.classList.toggle('visible',show)}
    function hideTableOfContents(){toggleElement('toc-panel',false)}
    function showLoading(msg='Processing...'){ const lo=document.getElementById('loading-overlay'),lm=lo?.querySelector('.loading-message');if(lo&&lm){lm.textContent=msg;lo.classList.add('visible')}}
    function hideLoading(){toggleElement('loading-overlay',false)}

    // --- Slider Logic (Unchanged - uses modified jumpToPage) ---
    function showPageSlider(){
        if (document.body.classList.contains('loading-game-active')) return;
        const s=document.getElementById('page-slider-container');if(s&&book.totalPages>0){s.classList.add('visible');resetSliderHideTimer()}
    }
    function hidePageSlider(){document.getElementById('page-slider-container')?.classList.remove('visible')}
    function resetSliderHideTimer(){
        clearTimeout(sliderHideTimeout);
        sliderHideTimeout = setTimeout(hidePageSlider, 1750); // Increased slightly
    }
    function initPageSlider(){
        const slider=document.getElementById('page-slider');
        const sliderContainer=document.getElementById('page-slider-container');
        if(!slider||!sliderContainer) return;

        let isDragging = false; // Track dragging state

        slider.addEventListener('input', () => { // Update display text ONLY while dragging
            if (!isDragging) return; // Only update text if actively dragging

            const targetPageValue = parseInt(slider.value, 10);
            const displayElem = document.getElementById('current-page-display');
            const totalPagesElem = document.getElementById('total-pages-display');

            if (displayElem && totalPagesElem) {
                // Determine potential display based on *intended* view mode (slider controls page numbers)
                let displayPageStart = targetPageValue;
                if (book.isDoublePageView && displayPageStart > 1 && displayPageStart % 2 === 0) {
                     displayPageStart--; // Show the pair start if intending double view
                }

                let pageText;
                 // Show pair ONLY if intending double view AND the second page exists
                if (book.isDoublePageView && displayPageStart + 1 <= book.totalPages) {
                    pageText = `Page ${displayPageStart}-${displayPageStart + 1}`;
                } else {
                    pageText = `Page ${targetPageValue}`; // Show single number otherwise
                }
                displayElem.textContent = pageText;
            }
            updateSliderStyle(slider, targetPageValue);
            resetSliderHideTimer(); // Keep slider visible while interacting
        });

        // Use pointer events for better drag handling
        slider.addEventListener('pointerdown', () => {
             if(document.body.classList.contains('loading-game-active')) return;
             isDragging = true;
             clearTimeout(sliderHideTimeout); // Prevent hiding while dragging
         });
        slider.addEventListener('pointerup', () => {
             if (!isDragging) return; // Avoid triggering jump if not dragging
             isDragging = false;
             const targetPageValue = parseInt(slider.value, 10);
             updateStatus(`Slider released at value: ${targetPageValue}`);
             jumpToPage(targetPageValue); // Final jump on release
             resetSliderHideTimer(); // Start timer to hide slider after jump attempt
         });
        slider.addEventListener('lostpointercapture', () => {
            // Handle cases like focus moving away during drag
            if (isDragging) {
                isDragging = false;
                 const targetPageValue = parseInt(slider.value, 10);
                 updateStatus(`Slider lost capture at value: ${targetPageValue}`);
                 jumpToPage(targetPageValue); // Attempt jump even if capture lost
                 resetSliderHideTimer();
            }
        });
        slider.addEventListener('change', () => {
             // This might fire for keyboard changes or sometimes after pointerup.
             // Ensure we don't double-trigger jumpToPage if pointerup already handled it.
            if (!isDragging) { // Only handle if not currently being dragged (e.g., keyboard nav on slider)
                 const targetPageValue = parseInt(slider.value, 10);
                 updateStatus(`Slider changed (not dragging) to value: ${targetPageValue}`);
                 jumpToPage(targetPageValue);
                 resetSliderHideTimer();
             }
        });


        sliderContainer.addEventListener('mouseenter',()=>{if(document.body.classList.contains('loading-game-active')) return; clearTimeout(sliderHideTimeout)});
        sliderContainer.addEventListener('mouseleave',()=>{if(document.body.classList.contains('loading-game-active')) return; resetSliderHideTimer()});
        updateSliderTotalPages();
        updateSliderPosition(); // Set initial position
    }
    function updateSliderTotalPages(){const s=document.getElementById('page-slider'),d=document.getElementById('total-pages-display');if(s&&d){const t=book.totalPages>0?book.totalPages:1;s.max=t;d.textContent=t;updateSliderStyle(s,s.value)}}

    // MODIFIED: updateSliderPosition updates text based on EFFECTIVE view
    function updateSliderPosition(){
        const slider = document.getElementById('page-slider');
        const displayElem = document.getElementById('current-page-display');
        const totalPagesElem = document.getElementById('total-pages-display'); // Needed for max check

        if(slider && displayElem && totalPagesElem){
            const currentPage = book.currentPage > 0 ? book.currentPage : 1;
            const totalPages = book.totalPages > 0 ? book.totalPages : 1;

            // Set slider value to the current *starting* page number
            slider.value = currentPage;

            // Determine display text based on *current effective* view mode
            const isFullscreenCurrent = document.body.classList.contains('fullscreen-mode');
            const isContentRotatedCurrent = document.body.classList.contains('content-rotated-mode');
            const isCurrentlyEffectiveDoubleView = book.isDoublePageView && !isFullscreenCurrent && !isContentRotatedCurrent;

            let pageText;
            // Show pair text only if effectively double view AND the next page exists
            if(isCurrentlyEffectiveDoubleView && currentPage + 1 <= totalPages) {
                pageText = `Page ${currentPage}-${currentPage + 1}`;
            } else {
                 pageText = `Page ${currentPage}`; // Show single page number otherwise
            }
            displayElem.textContent = pageText;

            // Update the visual fill percentage of the slider track
            updateSliderStyle(slider, currentPage);
        }
    }
    function updateSliderStyle(s,v){if(!s)return;const i=parseInt(s.min||1),a=parseInt(s.max||1),r=a>i?a-i:1,p=(parseInt(v)-i)/r*100;s.style.setProperty('--slider-percent',`${Math.max(0,Math.min(100,p))}%`)}

    // --- Overlay Data Loading (Unchanged) ---
    async function loadOverlayData(pdfUrl) {
        const overlayUrl = pdfUrl.replace(/\.pdf$/i, '.overlay.json'); updateStatus(`Attempting to load overlay from: ${overlayUrl}`);
        try {
            const response = await fetch(overlayUrl); if (!response.ok) { console.warn(`Overlay fetch failed: HTTP error ${response.status} for ${overlayUrl}`); keywordDefinitions = {}; pageKeywords = {}; return false; }
            const data = await response.json(); if (!data || typeof data.keywords !== 'object' || typeof data.pages !== 'object') { console.warn("Invalid overlay structure in JSON file."); keywordDefinitions = {}; pageKeywords = {}; return false; }
            const processedKeywords = {}; for (const [key, value] of Object.entries(data.keywords)) { if (key && typeof value === 'string') { processedKeywords[key.toLowerCase()] = value; } else { console.warn(`Invalid keyword entry skipped: Key='${key}'`) } } keywordDefinitions = processedKeywords;
            const processedPages = {}; for (const [pageNum, pageWords] of Object.entries(data.pages)) { if (pageNum && !isNaN(parseInt(pageNum)) && Array.isArray(pageWords) && pageWords.every(w => typeof w === 'string')) { processedPages[pageNum.toString()] = pageWords; } else { console.warn(`Invalid page entry skipped: Page='${pageNum}'`); } } pageKeywords = processedPages;
            updateStatus(`Overlay loaded successfully: ${Object.keys(keywordDefinitions).length} keywords, ${Object.keys(pageKeywords).length} pages defined.`); return true;
        } catch (error) { console.warn(`Overlay fetch/parse error for ${overlayUrl}: ${error.message}. Interactive keywords disabled.`); keywordDefinitions = {}; pageKeywords = {}; return false; }
     }

    // --- NEW: Load Iframe Data ---
    async function loadIframeData(pdfUrl) {
        const iframeDataUrl = pdfUrl.replace(/\.pdf$/i, '-iframes.json');
        updateStatus(`Attempting to load iframe data from: ${iframeDataUrl}`);
        iframeMappings = {}; // Reset before loading
        try {
            const response = await fetch(iframeDataUrl);
            if (!response.ok) {
                if (response.status === 404) {
                    updateStatus(`Iframe data file not found at ${iframeDataUrl}. No iframe popups will be shown.`);
                } else {
                    console.warn(`Iframe data fetch failed: HTTP error ${response.status} for ${iframeDataUrl}`);
                }
                return false; // Indicate failure or non-existence
            }
            const data = await response.json();
            if (!data || typeof data !== 'object' || Array.isArray(data)) {
                 console.warn("Invalid iframe data structure in JSON file. Expected an object { pageNum: urlString }.");
                 return false;
            }
            // Validate and store mappings
            const validMappings = {};
            let count = 0;
            for (const [key, value] of Object.entries(data)) {
                const pageNum = parseInt(key, 10);
                if (!isNaN(pageNum) && pageNum > 0 && typeof value === 'string' && value.trim() !== '') {
                    validMappings[key] = value.trim(); // Store page number as string key
                    count++;
                } else {
                    console.warn(`Invalid iframe mapping skipped: Key='${key}', Value='${value}'`);
                }
            }
            iframeMappings = validMappings;
            updateStatus(`Iframe data loaded successfully: ${count} mappings found.`);
            return true;
        } catch (error) {
            console.warn(`Iframe data fetch/parse error for ${iframeDataUrl}: ${error.message}. No iframe popups will be shown.`);
            iframeMappings = {};
            return false;
        }
    }

    // --- Pre-scan Function (Unchanged) ---
    async function findFirstKeywordInstances() {
        updateStatus("Starting pre-scan for first keyword instances...");
        globalFirstInstanceLocation = {};
        const keywordsToFind = new Set(Object.keys(keywordDefinitions));
        if (keywordsToFind.size === 0) {
            updateStatus("Pre-scan skipped: No keywords defined.");
            return;
        }
        const totalPages = book.pdfDocument.numPages;
        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
            if (keywordsToFind.size === 0) {
                updateStatus("Pre-scan finished early: All first instances found.");
                break;
            }
            try {
                const page = await book.pdfDocument.getPage(pageNum);
                const textContent = await page.getTextContent({ normalizeWhitespace: true });
                const items = textContent.items;
                for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                    const item = items[itemIndex];
                    const itemText = item.str;
                    if (!itemText || itemText.trim().length === 0) continue;
                    const keywordsToCheckInItem = Array.from(keywordsToFind);
                    for (const keywordLower of keywordsToCheckInItem) {
                        let originalKeywordForRegex = keywordLower;
                        const pageKwList = pageKeywords[pageNum.toString()] || [];
                        const foundOriginal = pageKwList.find(kw => kw.toLowerCase() === keywordLower);
                        if (foundOriginal) {
                            originalKeywordForRegex = foundOriginal;
                        }
                        const escapedKeyword = originalKeywordForRegex.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                        const regex = new RegExp(`\\b(${escapedKeyword})\\b`, 'gi');
                        const match = regex.exec(itemText);
                        if (match !== null) {
                            const matchIndex = match.index;
                            globalFirstInstanceLocation[keywordLower] = { pageNum, itemIndex, matchIndex };
                            keywordsToFind.delete(keywordLower);
                            if (keywordsToFind.size === 0) break;
                        }
                    }
                     if (keywordsToFind.size === 0) break;
                }
            } catch (error) {
                console.warn(`Error processing page ${pageNum} during keyword pre-scan:`, error);
            }
        }
        updateStatus(`Pre-scan complete. Found first instances for ${Object.keys(globalFirstInstanceLocation).length} keywords.`);
    }
    // --- END: Pre-scan Function ---


    // --- PDF Loading (MODIFIED to load iframe data and reset ALL popup states) ---
    async function loadPdf(pdfUrl) {
        updateStatus(`loadPdf started for: ${pdfUrl}`);
        pageCache.clear(); currentViewports={}; keywordDefinitions={}; pageKeywords={};
        globalFirstInstanceLocation = {}; iframeMappings = {}; // Reset iframe mappings
        // Note: notesMapping is hardcoded, no need to reset unless loaded dynamically

        // *** Reset time lock state completely on new PDF load ***
        updateStatus("Resetting time lock state for new PDF.");
        isTimelockGloballyEnabled = true; // *** Reset global toggle to ON ***
        updateTimelockButtonVisuals(); // Ensure button reflects the default ON state
        isTimeLockActive = false;
        completedTimeLockPages.clear(); // Clear the set of completed pages/pairs
        currentPageLockStartTime = 0;   // Reset timer start
        requiredReadingTime = 0;      // Reset required time
        // *** END Reset time lock state ***

        if(book.pdfDocument){try{book.pdfDocument.destroy()}catch(e){console.warn("Error destroying previous PDF doc:", e)}} book.pdfDocument=null; book.totalPages=0; book.currentPage=1; book.title="No Document"; book.outline=[]; book.isDoublePageView = true; // Reset to default intended view
        hideDefinitionPopup(); hideIframePopup(); hideNotesPopup(); // Hide ALL popups
        document.title = "Heritage History™ Reader";

        let filename = "Document"; try { filename = decodeURIComponent(pdfUrl.split('/').pop() || filename).replace(/\.pdf$/i, ''); } catch(e){} book.title = filename;
        try {
            updateStatus("Starting background PDF document loading...");
            console.log("Internal Status: Loading PDF document...");
            const loadingTask = pdfjsLib.getDocument(pdfUrl);
            // --- Start loading overlay and iframe data concurrently ---
            const overlayPromise = loadOverlayData(pdfUrl);
            const iframeDataPromise = loadIframeData(pdfUrl);
            // Note: Notes mapping is already embedded
            // ---

            book.pdfDocument = await loadingTask.promise;
            book.totalPages = book.pdfDocument.numPages;
            book.currentPage = 1; // Start at page 1
            user.readingProgress.furthestPage = 1; // Reset furthest progress
            updateStatus(`PDF loaded: ${book.title}, Pages: ${book.totalPages}`);
            document.title = `${book.title} - Heritage History™ Reader`;
            updateSliderTotalPages(); // Update slider max based on loaded pages

            console.log("Internal Status: Processing metadata...");
            updateStatus("Fetching outline...");
            try { book.outline = await book.pdfDocument.getOutline(); populateTOC(); } catch (outlineError) { console.warn("Could not get PDF outline:", outlineError); book.outline = []; populateTOC(); }

            // --- Wait for overlay and iframe data loading to finish ---
            const [overlayLoaded, iframeDataLoaded] = await Promise.all([overlayPromise, iframeDataPromise]);
            updateStatus(`Overlay data loaded: ${overlayLoaded}`);
            updateStatus(`Iframe data loaded: ${iframeDataLoaded}`);
            // ---

            if (overlayLoaded && book.pdfDocument) {
                console.log("Internal Status: Scanning for keywords...");
                await findFirstKeywordInstances(); // Perform pre-scan after overlay is loaded
            }

            // Set initial INTENDED view mode based on window width
            // Actual display/lock logic depends on effective mode checked in updateDisplay
            if (window.innerWidth < 1000) {
                updateStatus("Initial setup: Small screen detected, setting intended view to Single Page (Fullscreen).")
                book.isDoublePageView = false; // Intend single view
                document.body.classList.remove('content-rotated-mode');
                document.body.classList.add('fullscreen-mode'); // Apply fullscreen override class
            } else {
                 updateStatus("Initial setup: Large screen detected, setting intended view to Double Page.")
                book.isDoublePageView = true; // Intend double view
                document.body.classList.remove('content-rotated-mode', 'fullscreen-mode'); // Remove override classes
                 book.currentPage = 1; // Ensure starting page is 1 for double view initial load
            }

            // Update slider position *after* setting initial currentPage and view mode intention
            updateSliderPosition(); // Set slider to current page (page 1) and update text

            // Wait for potential style changes from classes to apply before the first render
            await new Promise(resolve => requestAnimationFrame(resolve));

            // Perform the initial display render and calculate/set the first time lock (if applicable and enabled)
            // This will also check for an iframe or notes popup on page 1.
            await updateDisplay();

            // --- *** READER IS READY *** ---
            isReaderReady = true;
            updateStatus("Reader is ready!");
            goToChapterBtn.classList.add('visible'); // Show the button to proceed from game

            // --- *** FIX: Immediately disable restart in game *** ---
            if (gameIframe && gameIframe.contentWindow) {
                try {
                    // Use specific origin in production if possible
                    gameIframe.contentWindow.postMessage({ type: 'disableRestart' }, '*');
                    updateStatus("Sent disableRestart message to game iframe because reader is ready.");
                } catch (e) {
                    console.error("Error posting disableRestart message to iframe:", e);
                }
            } else {
                 console.warn("Cannot send disableRestart message: iframe or contentWindow not accessible when reader became ready.");
            }
            // --- *** END FIX *** ---

        } catch (error) {
            console.error("FATAL: Error loading PDF document:", error);
            isReaderReady = false;
            // Reset state on error
            book.pdfDocument=null; book.totalPages=0; book.currentPage=1; book.title="Error Loading"; book.outline=[]; keywordDefinitions={}; pageKeywords={}; globalFirstInstanceLocation = {}; iframeMappings = {}; completedTimeLockPages.clear(); isTimeLockActive = false; requiredReadingTime = 0; currentPageLockStartTime = 0; isTimelockGloballyEnabled = true; updateTimelockButtonVisuals();
            currentNotesPdfDoc = null; currentNotesPageNum = 1; totalNotesPages = 0; // Reset notes state
            document.title="Heritage History™ Reader - Error"; updateSliderTotalPages(); updateSliderPosition(); populateTOC(); // Update UI to reflect error state
            const spreadContainer = document.querySelector('.main-container .book-spread');
            if (spreadContainer) {
                spreadContainer.innerHTML = `<div style="color: red; background: white; padding: 30px; text-align: center; width: 100%; border: 1px solid red; border-radius: 5px;">Failed to load document: ${error.message}</div>`;
            }
            updateStatus("loadPdf failed. Reader will not be available.");
        } finally {
             updateStatus("loadPdf finished (background process).");
        }
    }


    // --- TOC population (MODIFIED - Hides ALL popups on jump) ---
    function populateTOC() {
        const tocList = document.getElementById('toc-list');
        if (!tocList) return; tocList.innerHTML = '';
        if (!book.outline || book.outline.length === 0) { tocList.innerHTML = '<em>No table of contents found.</em>'; return; }
        const createTocItem = (item, level = 0) => {
            const d = document.createElement('div'); d.className = level === 0 ? 'toc-chapter' : 'toc-section'; const s = document.createElement('span'); s.className = level === 0 ? 'toc-chapter-title' : ''; s.textContent = item.title || 'Untitled'; s.style.cursor = 'pointer'; s.title = `Go to: ${item.title||'Untitled'}`;
            s.onclick = async (e) => {
                e.preventDefault(); try {
                    let pageIndex = -1;
                    if (typeof item.dest === 'string') { // Named destination
                        const destArray = await book.pdfDocument.getDestination(item.dest);
                        if (destArray && destArray[0]) { pageIndex = await book.pdfDocument.getPageIndex(destArray[0]); }
                    } else if (Array.isArray(item.dest) && item.dest[0]) { // Direct page reference object
                         pageIndex = await book.pdfDocument.getPageIndex(item.dest[0]);
                    } else { console.warn("Unknown TOC destination format:", item.dest); }

                    if (pageIndex >= 0) {
                        const targetPage = pageIndex + 1;
                        updateStatus(`Jumping via TOC to page ${targetPage}`);

                        // --- TOC Navigation Bypasses Time Lock ---
                        // Determine the correct starting page based on INTENDED view mode for the target page
                        let targetStartPage = targetPage;
                         if (book.isDoublePageView && targetStartPage > 1 && targetStartPage % 2 === 0) {
                             targetStartPage--;
                         }

                        // Clear any currently active lock since we are jumping potentially far
                        // (This is independent of the global setting, as it's clearing a *potential* current lock)
                        if (isTimeLockActive) {
                            updateStatus("Clearing active time lock due to TOC navigation.");
                            isTimeLockActive = false;
                            requiredReadingTime = 0;
                            currentPageLockStartTime = 0;
                        }

                        book.currentPage = targetStartPage; // Set the determined start page

                        // Update furthest page if necessary
                        if(book.currentPage > user.readingProgress.furthestPage) user.readingProgress.furthestPage = book.currentPage;

                        // --- Hide ALL popups before TOC jump ---
                        hideDefinitionPopup();
                        hideIframePopup();
                        hideNotesPopup();
                        hideTableOfContents();
                        // ---

                        // Update display: This will apply the global timelock setting when determining if a *new* lock should be set
                        // It will also check for popups on the target page.
                        await updateDisplay();
                        showPageSlider();
                        manageToolbar(false); // Hide right toolbar
                        manageLeftToolbar(false); // Hide left toolbar
                    }
                    else { throw new Error(`Could not resolve page for destination: ${item.title}`); }
                } catch (navError) { console.error("TOC navigation error:", navError); alert(`Navigation failed: ${navError.message}`); }
            };
            d.appendChild(s); if (item.items && item.items.length > 0) { const sub = document.createElement('div'); if (level === 0) sub.className = 'toc-sections'; else sub.style.paddingLeft = '15px'; item.items.forEach(subItem => { const subEl = createTocItem(subItem, level + 1); if (subEl) sub.appendChild(subEl); }); if (sub.hasChildNodes()) d.appendChild(sub); } return d;
        };
        book.outline.forEach(topItem => { const tocEl = createTocItem(topItem); if (tocEl) tocList.appendChild(tocEl); });
        if (!tocList.hasChildNodes()) tocList.innerHTML = '<em>Error processing TOC data.</em>';
     }


    // --- Popup Handling Functions (MODIFIED to hide other popups) ---
    function showDefinitionPopup(word, definition, rect) {
        if (!definitionPopup || !popupWord || !popupDefinition || !closePopupBtn || !rect) { console.error("Cannot show popup: Missing element or rect."); return; }
        // Added check: Don't show if in rotated mode
        if (document.body.classList.contains('content-rotated-mode')) {
             updateStatus("Popup suppressed in rotated mode.");
             return;
        }
        // --- Hide other popups ---
        hideIframePopupIfNeeded();
        hideNotesPopupIfNeeded();
        // ---
        popupWord.textContent = word || "Keyword";
        popupDefinition.innerHTML = definition || `<span style="color: #e74c3c;">Definition not available.</span>`;
        popupDefinition.scrollTop = 0;
        const popupStyle = window.getComputedStyle(definitionPopup);
        const popupMaxWidth = parseFloat(popupStyle.maxWidth) || 320;
        const estPopupHeight = 250;
        const margin = 10; const verticalOffset = 10;
        const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight;
        const highlightCenterX = rect.left + rect.width / 2;
        let targetLeft = highlightCenterX - (popupMaxWidth / 2);
        let targetTop = rect.top - estPopupHeight - verticalOffset;
        let transformOrigin = 'bottom center';
        if (targetTop < margin) { targetTop = rect.bottom + verticalOffset; transformOrigin = 'top center'; }
        if (targetLeft < margin) { targetLeft = margin; } else if (targetLeft + popupMaxWidth > viewportWidth - margin) { targetLeft = viewportWidth - popupMaxWidth - margin; }
        const effectivePopupHeight = Math.min(estPopupHeight, popupDefinition.scrollHeight + 60);
        if (targetTop < margin) { targetTop = margin; }
        else if (targetTop + effectivePopupHeight > viewportHeight - margin) {
             targetTop = viewportHeight - effectivePopupHeight - margin;
             if (transformOrigin === 'bottom center') transformOrigin = 'top center';
         }
        definitionPopup.style.left = `${Math.round(targetLeft)}px`;
        definitionPopup.style.top = `${Math.round(targetTop)}px`;
        definitionPopup.style.transformOrigin = transformOrigin;
        definitionPopup.classList.add('visible');
    }
    function hideDefinitionPopup() {
        if (definitionPopup) { definitionPopup.classList.remove('visible'); }
    }

    // --- NEW: Iframe Popup Handling Functions (MODIFIED to hide other popups) ---
    function showIframePopup(url) {
        if (!iframePopupBackdrop || !iframePopupModal || !popupIframe || !closeIframePopupBtn || !url) {
            console.error("Cannot show iframe popup: Missing element or URL.");
            return;
        }
         // --- Hide other popups ---
        hideDefinitionPopup();
        hideNotesPopupIfNeeded();
        // ---

        // Check if already visible with the same URL to prevent unnecessary reloads
        if (iframePopupModal.classList.contains('visible') && popupIframe.src === url) {
            updateStatus("Iframe popup already visible with the same URL.");
            return;
        }

        updateStatus(`Showing iframe popup for URL: ${url}`);
        popupIframe.src = url; // Set the source
        iframePopupBackdrop.classList.add('visible');
        iframePopupModal.classList.add('visible');
    }

    function hideIframePopup() {
        if (!iframePopupBackdrop || !iframePopupModal || !popupIframe) return;
        if (iframePopupModal.classList.contains('visible')) {
             updateStatus("Hiding iframe popup.");
             iframePopupBackdrop.classList.remove('visible');
             iframePopupModal.classList.remove('visible');
             // Reset src to prevent background activity and potential audio issues
             popupIframe.src = 'about:blank';
        }
    }

    // Helper to hide iframe popup only if it's currently visible
    function hideIframePopupIfNeeded() {
         if (iframePopupModal?.classList.contains('visible')) {
             hideIframePopup();
         }
    }
    // --- END: Iframe Popup Handling Functions ---

    // --- START: Notes Popup Handling Functions ---
    async function showNotesPopup(pdfUrl, pageNum = 1) {
        if (!notesPopupBackdrop || !notesPopupContainer || !notesPdfCanvas) {
            console.error("Cannot show notes popup: Missing elements.");
            return;
        }
        // --- Hide other popups ---
        hideDefinitionPopup();
        hideIframePopupIfNeeded();
        // ---

        updateStatus(`Showing notes popup for PDF: ${pdfUrl}, page: ${pageNum}`);
        notesPopupBackdrop.classList.add('visible');
        notesPopupContainer.classList.add('visible');

        // Clear previous notes content
        const ctx = notesPdfCanvas.getContext('2d');
        ctx.clearRect(0, 0, notesPdfCanvas.width, notesPdfCanvas.height);
        notesPrevBtn.disabled = true;
        notesNextBtn.disabled = true;

        // Abort previous loading task if any
        if (notesPdfLoadingTask && notesPdfLoadingTask.destroy) {
            notesPdfLoadingTask.destroy();
        }
        if (currentNotesPdfDoc && currentNotesPdfDoc.destroy) {
             try { currentNotesPdfDoc.destroy(); } catch (e) {}
             currentNotesPdfDoc = null;
        }

        try {
            showLoading('Loading notes...'); // Show loading indicator
            notesPdfLoadingTask = pdfjsLib.getDocument(pdfUrl);
            currentNotesPdfDoc = await notesPdfLoadingTask.promise;
            totalNotesPages = currentNotesPdfDoc.numPages;
            currentNotesPageNum = Math.max(1, Math.min(pageNum, totalNotesPages)); // Clamp initial page number

            updateStatus(`Notes PDF loaded: ${totalNotesPages} pages. Displaying page ${currentNotesPageNum}.`);
            await renderNotesPage(currentNotesPageNum);
            hideLoading();

        } catch (error) {
            console.error(`Error loading or rendering notes PDF ${pdfUrl}:`, error);
            ctx.fillStyle = 'red';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Error loading notes.', notesPdfCanvas.width / 2, notesPdfCanvas.height / 2);
            hideLoading();
            // Keep popup open to show error? Or hide? Hiding for now.
            hideNotesPopup();
        } finally {
            notesPdfLoadingTask = null;
        }
    }

    function hideNotesPopup() {
        if (!notesPopupBackdrop || !notesPopupContainer || !notesPdfCanvas) return;

        if (notesPopupContainer.classList.contains('visible')) {
            updateStatus("Hiding notes popup.");
            notesPopupBackdrop.classList.remove('visible');
            notesPopupContainer.classList.remove('visible');

            // Clear canvas
            const ctx = notesPdfCanvas.getContext('2d');
            ctx.clearRect(0, 0, notesPdfCanvas.width, notesPdfCanvas.height);

            // Destroy the PDF document object to free memory
            if (notesPdfLoadingTask && notesPdfLoadingTask.destroy) {
                notesPdfLoadingTask.destroy();
                notesPdfLoadingTask = null;
            }
            if (currentNotesPdfDoc && currentNotesPdfDoc.destroy) {
                try {
                    currentNotesPdfDoc.destroy();
                    updateStatus("Destroyed notes PDF document object.");
                } catch (e) {
                    console.warn("Error destroying notes PDF doc:", e);
                }
            }
            currentNotesPdfDoc = null;
            currentNotesPageNum = 1;
            totalNotesPages = 0;
        }
    }

    // Helper to hide notes popup only if it's currently visible
    function hideNotesPopupIfNeeded() {
        if (notesPopupContainer?.classList.contains('visible')) {
            hideNotesPopup();
        }
    }

    async function renderNotesPage(pageNum) {
        if (!currentNotesPdfDoc || pageNum < 1 || pageNum > totalNotesPages || !notesPdfCanvas) {
            console.warn(`Cannot render notes page ${pageNum}. Invalid state.`);
            return;
        }
        updateStatus(`Rendering notes page ${pageNum} of ${totalNotesPages}`);
        const canvas = notesPdfCanvas;
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('notes-pdf-canvas-container');

        try {
            const page = await currentNotesPdfDoc.getPage(pageNum);
            const containerStyle = getComputedStyle(container);
            const availableWidth = parseFloat(containerStyle.width);
            const availableHeight = parseFloat(containerStyle.height);

            if (availableWidth <= 0 || availableHeight <= 0) {
                console.warn("Notes canvas container has zero dimensions. Cannot render.");
                return;
            }

            const defaultViewport = page.getViewport({ scale: 1 });
            const scale = Math.min(availableWidth / defaultViewport.width, availableHeight / defaultViewport.height);
            const viewport = page.getViewport({ scale: scale });

            const outputScale = window.devicePixelRatio || 1;
            canvas.width = Math.floor(viewport.width * outputScale);
            canvas.height = Math.floor(viewport.height * outputScale);
            canvas.style.width = `${Math.floor(viewport.width)}px`;
            canvas.style.height = `${Math.floor(viewport.height)}px`;

            const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
            const renderContext = {
                canvasContext: ctx,
                transform: transform,
                viewport: viewport
            };

            await page.render(renderContext).promise;
            currentNotesPageNum = pageNum; // Update current page state only on successful render

            // Update button states
            notesPrevBtn.disabled = (currentNotesPageNum <= 1);
            notesNextBtn.disabled = (currentNotesPageNum >= totalNotesPages);
            updateStatus(`Notes page ${pageNum} rendered successfully.`);

        } catch (error) {
            console.error(`Error rendering notes page ${pageNum}:`, error);
            ctx.fillStyle = 'red';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Error rendering page ${pageNum}.`, canvas.width / 2, canvas.height / 2);
            // Disable buttons on error
            notesPrevBtn.disabled = true;
            notesNextBtn.disabled = true;
        }
    }

    function notesPrevPage() {
        if (currentNotesPageNum > 1) {
            renderNotesPage(currentNotesPageNum - 1);
        }
    }

    function notesNextPage() {
        if (currentNotesPageNum < totalNotesPages) {
            renderNotesPage(currentNotesPageNum + 1);
        }
    }
    // --- END: Notes Popup Handling Functions ---


    // --- Game Transition Logic (Unchanged) ---
    function transitionToChapter() {
        updateStatus("Transitioning to chapter...");
        clearTimeout(gameOverTimeoutId); // Clear any pending game over transition

        document.body.classList.remove('loading-game-active');
        // JS already removes '.visible' from goToChapterBtn, and CSS rule ensures it's hidden

         window.focus(); // Move focus back to main window

        // Short delay to allow CSS transition for game overlay fade-out
        setTimeout(() => {
            applyCurrentViewModeStyles(); // Ensure correct scale/rotation
            // Trigger resize logic which includes updateDisplay if needed
             window.dispatchEvent(new Event('resize'));
             updateStatus("Reader should be visible and scaled.");
        }, 50); // Small delay matches transition duration
    }
    // --- Handle Game Over Message (Unchanged) ---
    function handleGameOverFromGame(score) {
        updateStatus(`Game over message received. Score: ${score}`);
        if (isReaderReady) {
            updateStatus("Reader is ready, handling automatic transition after game over.");
            if (gameIframe && gameIframe.contentWindow) {
                try { gameIframe.contentWindow.postMessage({ type: 'disableRestart' }, '*'); }
                 catch (e) { console.error("Error posting safeguard disableRestart message:", e); }
            }
            clearTimeout(gameOverTimeoutId);
            gameOverTimeoutId = setTimeout(() => {
                updateStatus("Game over timeout finished, transitioning now.");
                transitionToChapter();
            }, 3000); // 3-second delay after game over
        } else {
            updateStatus("Game over occurred, but reader is not ready yet. No automatic transition.");
            // If reader isn't ready, we might still want to enable the button
             goToChapterBtn.classList.add('visible'); // Allow manual transition if reader loads later
        }
    }
    // --- END: Game Transition Logic ---

    // --- NEW: Update Timelock Button Visuals ---
    function updateTimelockButtonVisuals() {
        if (!timelockToggleButton) return;
        if (isTimelockGloballyEnabled) {
            timelockToggleButton.classList.remove('timelock-off');
            timelockToggleButton.classList.add('timelock-on');
            timelockToggleButton.title = "Toggle Reading Time Lock (On)";
        } else {
            timelockToggleButton.classList.remove('timelock-on');
            timelockToggleButton.classList.add('timelock-off');
            timelockToggleButton.title = "Toggle Reading Time Lock (Off)";
        }
    }

    // --- NEW: Toggle Timelock Functionality ---
    function toggleTimelock() {
        isTimelockGloballyEnabled = !isTimelockGloballyEnabled;
        updateStatus(`Timelock globally ${isTimelockGloballyEnabled ? 'ENABLED' : 'DISABLED'}`);
        updateTimelockButtonVisuals();

        // If turning the timelock OFF, immediately deactivate any *current* lock.
        if (!isTimelockGloballyEnabled && isTimeLockActive) {
            updateStatus("Timelock globally disabled, clearing current active lock.");
            isTimeLockActive = false;
            requiredReadingTime = 0;
            currentPageLockStartTime = 0;
            clearTimeout(alertTimeout); // Hide any active alert
            const alertDiv = document.getElementById('reading-time-alert');
            if (alertDiv) alertDiv.classList.remove('visible');
        } else if (isTimelockGloballyEnabled) {
            // If turning the timelock ON, re-evaluate the lock state for the current view immediately.
            // This might set a new lock if one is applicable and wasn't active before.
            updateStatus("Timelock globally enabled, re-evaluating lock state for current view.");
            updateDisplay(); // Re-run updateDisplay to potentially set a lock based on current page/view
        }
        manageLeftToolbar(false); // Hide toolbar after action
    }

    // --- Event Setup (MODIFIED - Adds listeners for notes popup, updates Esc key) ---
    function setupEvents() {
        updateStatus("Setting up events");
        const toolbar = document.getElementById('new-toolbar');
        const leftToolbar = document.getElementById('left-toolbar'); // Get left toolbar
        const mainContainer = document.querySelector('.main-container');
        const bookSpread = mainContainer?.querySelector('.book-spread');

        // Right Toolbar Clicks (Calls updated view functions)
        toolbar?.addEventListener('click', e => {
             const btn = e.target.closest('.new-btn');
             if (!btn) return;
             switch (btn.id) {
                 case 'back-btn': window.history.back(); break;
                 case 'single-page-btn': setSinglePageView(); break; // Calls updateDisplay internally
                 case 'double-page-btn': setDoublePageView(); break; // Calls updateDisplay internally
                 case 'rotate-btn': setRotatedView(); break;     // Calls updateDisplay internally
                 case 'time-capsule-btn': console.log("Time Capsule button clicked (feature disabled)."); break;
             }
             // Toolbar hiding is handled within the view change functions
        });

        // *** NEW: Left Toolbar Click (Timelock Toggle) ***
        leftToolbar?.addEventListener('click', e => {
            const btn = e.target.closest('.new-btn');
            if (!btn || btn.id !== 'timelock-toggle-btn') return;
            toggleTimelock();
        });

        // TOC Close (No change)
        document.getElementById('close-toc-btn')?.addEventListener('click', hideTableOfContents);
        // Popup Close (No change)
        closePopupBtn?.addEventListener('click', hideDefinitionPopup);
        // --- NEW: Iframe Popup Close ---
        closeIframePopupBtn?.addEventListener('click', hideIframePopup);
        iframePopupBackdrop?.addEventListener('click', hideIframePopup); // Click backdrop to close
        // --- NEW: Notes Popup Close ---
        notesPopupBackdrop?.addEventListener('click', hideNotesPopup); // Click backdrop to close
        notesPrevBtn?.addEventListener('click', notesPrevPage);
        notesNextBtn?.addEventListener('click', notesNextPage);


        // Page Edge Clicks (Uses updated nextPage/prevPage)
        bookSpread?.addEventListener('click', e => {
            if (document.body.classList.contains('loading-game-active')) return;
            if (e.target.classList.contains('page-edge-nav')) {
                const pageDiv = e.target.closest('.book-page');
                if (!pageDiv || pageDiv.classList.contains('placeholder-page')) return;

                // Check if the clicked button is actually visible (based on updateDisplay logic)
                if (e.target.style.display === 'none') {
                    updateStatus("Clicked hidden edge nav button. Ignoring.");
                    return; // Don't navigate if the button is hidden
                }

                if (e.target.classList.contains('page-edge-left')) {
                    prevPage(); // Calls jumpToPage (no lock check needed for prev)
                } else { // page-edge-right
                    nextPage(); // Calls jumpToPage (handles lock check internally if needed)
                }
                // showPageSlider and manageToolbar are called within jumpToPage if navigation occurs
            }
        });

        // Keyboard Navigation (MODIFIED Esc key behavior for ALL popups)
        document.addEventListener('keydown', e => {
            if (document.body.classList.contains('loading-game-active')) return;

            // --- Check for popup closes first (priority: notes > iframe > definition) ---
            if (e.key === 'Escape') {
                if (notesPopupContainer?.classList.contains('visible')) {
                    hideNotesPopup();
                    e.preventDefault();
                    return; // Stop further processing
                } else if (iframePopupModal?.classList.contains('visible')) {
                    hideIframePopup();
                    e.preventDefault();
                    return; // Stop further processing
                } else if (definitionPopup.classList.contains('visible')) {
                    hideDefinitionPopup();
                    e.preventDefault();
                    return; // Stop further processing
                }
                // If no popups are open, Esc does nothing else here
            }
            // ---

            // Ignore if focus is in an input, TOC is open, or any popup is still open
            if (document.getElementById('toc-panel')?.classList.contains('visible') ||
                notesPopupContainer?.classList.contains('visible') ||
                iframePopupModal?.classList.contains('visible') ||
                definitionPopup.classList.contains('visible') ||
               (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;

            // Ignore modifier keys
            if (e.ctrlKey || e.altKey || e.metaKey) return;

            let navAction = false;
            switch(e.key){
                case 'ArrowRight': case 'PageDown':
                     nextPage(); // Handles lock check internally via jumpToPage
                     navAction = true; break;
                case 'ArrowLeft': case 'PageUp':
                     prevPage(); // No lock check needed
                     navAction = true; break;
                case 'Home':
                     if(book.totalPages > 0) jumpToPage(1); // Handles lock check internally (only if moving forward from non-1)
                     navAction = true; break;
                case 'End':
                     if(book.totalPages > 0) jumpToPage(book.totalPages); // Handles lock check internally
                     navAction = true; break;
            }
            if(navAction){ e.preventDefault(); /* Slider/Toolbars managed by jumpToPage/showPageSlider */ }
        });

        // Resize Handling (MODIFIED to hide ALL popups)
        window.addEventListener('resize', ()=>{
            clearTimeout(resizeTimer);
            resizeTimer=setTimeout(()=>{
                updateStatus("Resize detected.");
                hideDefinitionPopup();
                hideIframePopup();
                hideNotesPopup(); // Hide notes popup on resize
                applyCurrentViewModeStyles(); // Recalculate scale/rotation first
                if (!document.body.classList.contains('loading-game-active') && book.pdfDocument) {
                    // Re-render and re-evaluate locks based on potentially new effective view mode
                    // Also re-checks for popups on the *current* page after resize
                    updateDisplay();
                }
                 manageToolbar(); // Adjust right toolbar visibility if needed
                 manageLeftToolbar(); // Adjust left toolbar visibility if needed
             }, 250);
        });

        // Touch Swipes (MODIFIED to ignore swipes on popups)
        let tX=0,tY=0,tS=0; const SW=50,ST=500,SV=70;
        document.body.addEventListener('touchstart',e=>{
            if(document.body.classList.contains('loading-game-active')) return;
            // Ignore swipes starting on interactive elements OR ANY POPUP
            if(e.target.closest('#new-toolbar,.toolbar-trigger-area,#left-toolbar,.left-toolbar-trigger-area,#page-slider-container,#page-slider-trigger-zone,.toc-panel,.page-edge-nav,.new-btn,button,input,a,#definition-popup,.keyword-highlight,.annotationLayer section,#iframe-popup-modal,#iframe-popup-backdrop,#notes-popup-container,#notes-popup-backdrop')){
                tX=0;tY=0;return;
            }
            if(e.touches.length===1){
                tX=e.touches[0].screenX;tY=e.touches[0].screenY;tS=Date.now();
            } else {
                tX=0;tY=0;
            }
        },{passive:true});
        document.body.addEventListener('touchend',e=>{
             if(document.body.classList.contains('loading-game-active') || (tX===0&&tY===0))return;
             if(e.changedTouches.length===1){
                 const eX=e.changedTouches[0].screenX,eY=e.changedTouches[0].screenY,tE=Date.now()-tS;
                 if(tE<ST){
                     const dX=eX-tX,dY=eY-tY,aX=Math.abs(dX),aY=Math.abs(dY);
                     if(aX>SW&&aY<SV){ // Horizontal swipe detected
                         e.preventDefault(); // Prevent default scroll on successful swipe
                         if(dX>0){ // Swipe Right (Previous Page)
                             prevPage();
                         } else { // Swipe Left (Next Page)
                             nextPage(); // Handles lock check internally
                         }
                         // Slider/Toolbars managed by jumpToPage/showPageSlider
                     }
                 }
             }
             tX=0;tY=0;tS=0;
        });

        // Slider Trigger Zone (No change)
        const stz=document.getElementById('page-slider-trigger-zone'),slc=document.getElementById('page-slider-container');if(stz&&slc){const et=()=>{if(document.body.classList.contains('loading-game-active')) return; if(book.pdfDocument&&book.totalPages>0){showPageSlider();clearTimeout(sliderHideTimeout)}};const lts=e=>{if(document.body.classList.contains('loading-game-active')) return; const rt=e.relatedTarget;if(!slc.contains(rt)&&!stz.contains(rt)){resetSliderHideTimer()}};stz.addEventListener('mouseenter',et);slc.addEventListener('mouseenter',et);stz.addEventListener('mouseleave',lts);slc.addEventListener('mouseleave',lts)}

        // Global Click Listener for Popup Dismissal (Definition Popup Only - Others use backdrop click)
        document.addEventListener('click', e => {
             if (definitionPopup.classList.contains('visible')
                 && !definitionPopup.contains(e.target)
                 // Check if the click originated on a keyword highlight *that is interactive*
                 // (CSS pointer-events: none will prevent clicks in rotated mode anyway)
                 && !e.target.closest('.keyword-highlight[style*="pointer-events: auto"], .keyword-highlight:not([style*="pointer-events"])'))
             { hideDefinitionPopup(); }
        }, true);

        // --- Game Event Listeners (No change) ---
        goToChapterBtn.addEventListener('click', transitionToChapter);
        window.addEventListener('message', (event) => {
            // IMPORTANT: Check origin in production!
            // if (event.origin !== 'expected-game-origin') return;
            if (event.source !== gameIframe.contentWindow) {
                // console.warn("Ignoring message not from game iframe contentWindow.");
                 return;
            }
            if (event.data && event.data.type === 'gameOver') { handleGameOverFromGame(event.data.score); }
            if (event.data && event.data.type === 'gameLoaded') {
                 if(iframeLoadingText) iframeLoadingText.style.display = 'none';
                 updateStatus("Game iframe reported *itself* loaded.");
                 try { if (gameIframe && gameIframe.contentWindow) { gameIframe.contentWindow.focus(); updateStatus("Attempted to focus game iframe."); } }
                 catch (focusError) { console.warn("Could not focus game iframe:", focusError.message); }
            }
        });
        gameIframe.addEventListener('load', () => {
            if(iframeLoadingText) iframeLoadingText.style.display = 'none';
            updateStatus("Game iframe document structure loaded (waiting for gameLoaded message).");
        });

        updateStatus("Events setup complete");
    }

    // --- Initialization (MODIFIED - Sets up left toolbar hover) ---
    async function init() {
        updateStatus("Initializing application...");
        document.body.classList.add('loading-game-active');

        try {
            try { PAGE_PADDING = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--page-padding')) || 15; } catch(e){ PAGE_PADDING=15; console.warn("CSS var --page-padding read failed.") }

            setupEvents();
            setupToolbarHover(); // Setup right toolbar
            setupLeftToolbarHover(); // *** Setup left toolbar ***
            updateTimelockButtonVisuals(); // Set initial button state
            initPageSlider();

            // Validate notes mapping structure (optional, good practice)
            for (const key in notesMapping) {
                if (typeof notesMapping[key] !== 'object' || !notesMapping[key].pdf || typeof notesMapping[key].pdf !== 'string' || !notesMapping[key].page || typeof notesMapping[key].page !== 'number') {
                    console.warn(`Invalid entry in notesMapping for key ${key}. Skipping.`);
                    delete notesMapping[key];
                }
            }
            updateStatus(`Notes mapping loaded: ${Object.keys(notesMapping).length} entries.`);

            const urlParams = new URLSearchParams(window.location.search);
            const pdfUrlParam = urlParams.get('pdf');

            if (pdfUrlParam) {
                updateStatus(`PDF URL parameter found: ${pdfUrlParam}. Starting background load...`);
                loadPdf(pdfUrlParam); // Run in background, awaits are internal
            } else {
                updateStatus("No PDF specified in URL parameter (?pdf=...). Reader content will not load.");
                 isReaderReady = false; // Ensure reader isn't considered ready
                 goToChapterBtn.classList.remove('visible'); // Hide button
                 document.body.classList.remove('loading-game-active'); // Allow UI to show message
                const sc = document.querySelector('.main-container');
                if(sc) {
                    sc.style.visibility = 'visible'; sc.style.opacity = '1'; // Make container visible
                    sc.innerHTML = `<div style="color: var(--text-on-dark); background: rgba(28,37,54,.8); border-radius: 8px; padding: 40px; text-align: center; max-width: 500px; margin: auto; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"><h2>Interactive Reader</h2><p style="margin-top: 15px;">Add <code>?pdf=URL_TO_PDF</code> to the address bar.</p></div>`;
                }
                // Hide game elements if no PDF
                 const gameContainer = document.getElementById('loading-game-container');
                 if (gameContainer) gameContainer.style.display = 'none';
            }

            window.addEventListener('beforeunload', () => { updateStatus("Unloading - Cleanup."); clearTimeout(gameOverTimeoutId); clearTimeout(alertTimeout); pageCache.clear(); if (book.pdfDocument) { try { book.pdfDocument.destroy(); } catch(e){} book.pdfDocument = null; } hideNotesPopup(); /* Ensure notes PDF is destroyed */ });
            updateStatus("Initialization complete. Background loading may be in progress.");

        } catch (initError) {
            console.error("Initialization failed:", initError);
            document.body.innerHTML = `<div style="color: red; background: white; padding: 20px; border: 2px solid red; font-family: monospace; position: fixed; top: 10px; left: 10px; z-index: 11000;"><pre>App Init Error:\n${initError.stack || initError}</pre></div>`;
            document.body.classList.add('loading-game-active'); // Keep game hidden on fatal init error
            goToChapterBtn.classList.remove('visible');
        }
    }

// --- Start the application ---
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
