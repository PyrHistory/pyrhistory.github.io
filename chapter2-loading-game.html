<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prehistoric Runner Optimized</title>
    <script>
    // Pre-register spacebar handler at the highest level possible
    window.addEventListener('keydown', function(e) {
        if (e.code === 'Space' || e.key === ' ' || e.keyCode === 32) {
            e.preventDefault(); // Prevent default space behavior (scrolling)
            // Pass event to the game through a custom event
            window.dispatchEvent(new CustomEvent('game-jump-intent'));
        }
    }, {capture: true, passive: false}); // Explicitly not passive for preventDefault
    </script>
    <style>:root{--primary-bg:#3A2618;--game-bg:#87CEEB;--accent-color:#FF8C42;--button-color:#4CAF50;--button-hover:#45a049;--text-light:#FFF;--text-shadow:0 2px 4px rgba(0,0,0,.5);--modal-bg:rgba(34,34,34,.9);--modal-border:rgba(255,255,255,.1);--modal-shadow:0 8px 32px rgba(0,0,0,.3)}*{margin:0;padding:0;box-sizing:border-box}body{display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:100vh;background:var(--primary-bg);font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;overflow:hidden;padding:1rem}#game-container{position:relative;width:100%;max-width:800px;height:60vh;max-height:300px;background-color:var(--game-bg);overflow:hidden;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.4)}#game-canvas{position:absolute;top:0;left:0;z-index:1;width:100%;height:100%; image-rendering: -moz-crisp-edges; image-rendering: -webkit-crisp-edges; image-rendering: pixelated; image-rendering: crisp-edges;}#score{position:absolute;top:1rem;right:1rem;font-size:1.25rem;font-weight:600;color:var(--text-light);z-index:2;text-shadow:var(--text-shadow);background-color:rgba(0,0,0,.3);padding:.4rem .8rem;border-radius:20px;letter-spacing:.5px}#game-over{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background-color:var(--modal-bg);color:var(--text-light);padding:1.5rem;border-radius:12px;text-align:center;z-index:3;display:none;width:80%;max-width:300px;box-shadow:var(--modal-shadow);border:1px solid var(--modal-border);backdrop-filter:blur(4px)}#game-over h2{margin-bottom:.8rem;font-size:1.75rem;letter-spacing:1px;color:var(--accent-color)}#game-over p{margin-bottom:1.2rem;font-size:1.1rem}#game-over button{padding:.75rem 1.5rem;background:linear-gradient(to bottom,#FF8C42,#FF5E00);border:none;color:#fff;cursor:pointer;border-radius:6px;font-size:1rem;font-weight:600;transition:all .2s ease;width:80%;box-shadow:0 4px 8px rgba(0,0,0,.2)}#game-over button:hover{background:linear-gradient(to bottom,#FFA557,#FF7E29);transform:translateY(-2px);box-shadow:0 6px 12px rgba(0,0,0,.2)}#game-over button:active{transform:translateY(0);box-shadow:0 2px 4px rgba(0,0,0,.2)}#instructions{color:var(--text-light);font-size:.9rem;text-shadow:var(--text-shadow);background-color:rgba(0,0,0,.3);padding:.4rem .8rem;border-radius:20px;text-align:center;white-space:nowrap;margin-top:1rem;display:block;width:auto}@media (max-width:480px){#game-container{height:50vh}#score{font-size:1rem;padding:.3rem .6rem}#instructions{font-size:.8rem;padding:.3rem .6rem;margin-top:.8rem}#game-over h2{font-size:1.5rem}#game-over p{font-size:1rem}#game-over button{font-size:.9rem;padding:.6rem 1.2rem}}@media (min-width:1200px){#game-container{max-height:380px}}</style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="game-over">
            <h2>GAME OVER!</h2>
            <p>Your score: <span id="final-score">0</span></p>
            <button id="restart">Play Again</button>
        </div>
    </div>
    <div id="instructions">Press SPACE or tap to jump</div>

    <script>
(function(){
    'use strict'; // Enable strict mode

    // --- Cache DOM elements ---
    const container = document.getElementById('game-container');
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const gameOverElement = document.getElementById('game-over');
    const finalScoreElement = document.getElementById('final-score');
    const restartButton = document.getElementById('restart');
    const instructionsElement = document.getElementById('instructions'); // Cache instructions

    // --- Canvas/Game Dimensions ---
    let canvasWidth, canvasHeight, groundY;

    // --- Game State Variables ---
    let score = 0;
    let currentScoreDisplay = 0; // To optimize DOM updates
    let gameSpeed = 250; // Pixels per second
    let baseGameSpeed = 250;
    const gravity = 900; // Pixels per second squared
    let playing = false; // Start paused
    let obstacleInterval = 1.5; // Seconds
    let difficultyFactor = 1.0;
    let restartDisabled = false;
    let animationFrameId = null;
    let lastTime = 0;
    let obstacleTimer = 0;
    let cloudTimer = 0;
    let backgroundTimer = 0;
    let multiObstacleChance = 0.0;
    let timeAccumulator = 0; // Accumulator for score/difficulty increases

    // --- Constants and Cached Values ---
    const PI2 = Math.PI * 2;
    const GROUND_HEIGHT = 30;
    const PLAYER_INITIAL_X = 50;
    const OBSTACLE_POOL_SIZE = 10;
    const CLOUD_POOL_SIZE = 10;
    const BACKGROUND_POOL_SIZE = 5;
    const JUMP_VELOCITY = -450; // Pixels per second
    const DOUBLE_JUMP_VELOCITY = -250; // Pixels per second
    const TARGET_FPS = 60;
    const TIME_STEP = 1 / TARGET_FPS; // Fixed time step for physics

    // --- Object Pools ---
    const obstaclePool = [];
    const cloudPool = [];
    const backgroundElementPool = [];
    const activeObstacles = [];
    const activeClouds = [];
    const activeBackgroundElements = [];

    // --- Cached Gradient ---
    const skyGradient = {
        gradient: null,
        colors: ['#87CEEB', '#E0F7FF'],
        create: function() {
            if (!ctx || groundY <= 0) return 'skyblue'; // Fallback
            this.gradient = ctx.createLinearGradient(0, 0, 0, groundY);
            this.gradient.addColorStop(0, this.colors[0]);
            this.gradient.addColorStop(1, this.colors[1]);
            return this.gradient;
        },
        get: function() {
            return this.gradient || this.create();
        }
    };

    // --- Ground Object ---
    const ground = {
        y: 0,
        color: '#8B4513',
        grassColor: '#32CD32',
        grassHeight: 5,
        draw: function() {
            ctx.fillStyle = this.color;
            ctx.fillRect(0, this.y, canvasWidth, canvasHeight - this.y);
            ctx.fillStyle = this.grassColor;
            ctx.fillRect(0, this.y, canvasWidth, this.grassHeight);
        }
    };

    // --- Player Object ---
    const player = {
        x: PLAYER_INITIAL_X,
        y: 0,
        width: 30,
        height: 40,
        velocityY: 0,
        jumpCount: 0,
        maxJumps: 2,
        colorBody: '#8B5A2B',
        colorEyes: 'white',
        colorPupils: 'black',
        colorMouth: '#A52A2A',
        colorSpearWood: '#8B4513',
        colorSpearHead: '#A9A9A9',

        maxJumpDistance: function() {
            // Approximate calculation: time to apex * horizontal speed * 2
            const timeToApex = -JUMP_VELOCITY / gravity;
            return gameSpeed * (2 * timeToApex);
        },

        update: function(dt) {
            // Apply gravity
            this.velocityY += gravity * dt;
            this.y += this.velocityY * dt;

            // Ground collision
            if (this.y + this.height >= groundY) {
                this.y = groundY - this.height;
                this.velocityY = 0;
                if (this.jumpCount > 0) { // Only reset if actually airborne before
                    this.jumpCount = 0;
                }
            }
        },

        jump: function() {
            if (this.jumpCount < this.maxJumps) {
                this.velocityY = (this.jumpCount === 0) ? JUMP_VELOCITY : DOUBLE_JUMP_VELOCITY;
                this.jumpCount++;
            }
        },

        isOnGround: function() {
            // Use a small epsilon for floating point comparison
            return this.y + this.height >= groundY - 0.1;
        },

        draw: function() {
            const headRadius = 6;
            const centerX = this.x + this.width / 2;
            const onGround = this.isOnGround();
            const jumping = !onGround;

            // --- Batch drawing by color ---

            // Body Color
            ctx.fillStyle = this.colorBody;
            ctx.strokeStyle = this.colorBody;
            ctx.lineWidth = 2;

            // Head
            ctx.beginPath();
            ctx.arc(centerX, this.y + headRadius, headRadius, 0, PI2);
            ctx.fill();

            // Body
            ctx.beginPath();
            ctx.moveTo(centerX, this.y + headRadius * 2);
            ctx.lineTo(centerX, this.y + headRadius * 2 + 20); // Torso line
            ctx.stroke();

            // Arms
            ctx.beginPath();
            ctx.moveTo(centerX, this.y + headRadius * 2 + 5); // Shoulder point
            if (jumping) {
                ctx.lineTo(centerX - 8, this.y + headRadius * 2); // Left arm up
                ctx.moveTo(centerX, this.y + headRadius * 2 + 5);
                ctx.lineTo(centerX + 8, this.y + headRadius * 2); // Right arm up
            } else {
                // Running arms (simplified cycle for performance)
                const armPhase = Math.floor(Date.now() / 150) % 2;
                if (armPhase === 0) {
                    ctx.lineTo(centerX - 12, this.y + headRadius * 2 + 8); // Left arm back
                    ctx.moveTo(centerX, this.y + headRadius * 2 + 5);
                    ctx.lineTo(centerX + 12, this.y + headRadius * 2 + 1); // Right arm forward (holding spear)
                } else {
                    ctx.lineTo(centerX - 10, this.y + headRadius * 2 + 1); // Left arm forward
                    ctx.moveTo(centerX, this.y + headRadius * 2 + 5);
                    ctx.lineTo(centerX + 10, this.y + headRadius * 2 + 8); // Right arm back
                }
            }
            ctx.stroke();

            // Legs
             ctx.beginPath();
             ctx.moveTo(centerX, this.y + headRadius * 2 + 20); // Hip point
            if (jumping) {
                ctx.lineTo(centerX - 10, this.y + this.height); // Left leg jump
                ctx.moveTo(centerX, this.y + headRadius * 2 + 20);
                ctx.lineTo(centerX + 10, this.y + this.height); // Right leg jump
            } else {
                 const runCycle = Math.floor(Date.now() / 100) % 2; // Original cycle
                 if (runCycle === 0) {
                    ctx.lineTo(centerX - 10, this.y + this.height); // Left leg back
                    ctx.moveTo(centerX, this.y + headRadius * 2 + 20);
                    ctx.lineTo(centerX + 8, this.y + this.height - 5); // Right leg front
                 } else {
                    ctx.lineTo(centerX - 8, this.y + this.height - 5); // Left leg front
                    ctx.moveTo(centerX, this.y + headRadius * 2 + 20);
                    ctx.lineTo(centerX + 10, this.y + this.height); // Right leg back
                 }
            }
             ctx.stroke();

            // Eyes (White)
            ctx.fillStyle = this.colorEyes;
            ctx.beginPath();
            ctx.arc(centerX - 2, this.y + headRadius - 1, 1.5, 0, PI2); // Left eye
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 2, this.y + headRadius - 1, 1.5, 0, PI2); // Right eye
            ctx.fill();

            // Pupils (Black)
            ctx.fillStyle = this.colorPupils;
            ctx.beginPath();
            ctx.arc(centerX - 2, this.y + headRadius - 1, 0.8, 0, PI2); // Left pupil
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 2, this.y + headRadius - 1, 0.8, 0, PI2); // Right pupil
            ctx.fill();

            // Mouth
            if (jumping) {
                ctx.fillStyle = this.colorMouth;
                ctx.beginPath();
                ctx.arc(centerX, this.y + headRadius + 2, 1.5, 0, PI2); // Open mouth
                ctx.fill();
            } else {
                ctx.strokeStyle = this.colorMouth;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX - 2, this.y + headRadius + 2);
                ctx.lineTo(centerX + 2, this.y + headRadius + 2); // Closed mouth line
                ctx.stroke();

                // Spear (only when running)
                const spearHandX = centerX + 12;
                const spearHandY = this.y + headRadius * 2 + 1;
                const spearTipX = spearHandX + 18;
                const spearTipY = spearHandY - 3;

                ctx.strokeStyle = this.colorSpearWood;
                ctx.lineWidth = 2; // Keep consistent
                ctx.beginPath();
                ctx.moveTo(spearHandX, spearHandY);
                ctx.lineTo(spearTipX, spearTipY);
                ctx.stroke();

                ctx.fillStyle = this.colorSpearHead;
                ctx.beginPath();
                ctx.moveTo(spearTipX, spearTipY);
                ctx.lineTo(spearTipX + 7, spearTipY - 2); // Spear point
                ctx.lineTo(spearTipX + 2, spearTipY + 7); // Spear barb
                ctx.closePath();
                ctx.fill();
            }
        },
        // AABB collision check
        checkCollision: function(obstacle) {
            return (
                this.x < obstacle.x + obstacle.width &&
                this.x + this.width > obstacle.x &&
                this.y < obstacle.y + obstacle.height &&
                this.y + this.height > obstacle.y
            );
        }
    };

    // --- Obstacle Definitions ---
    // Store drawing functions directly to avoid switch/if-else inside draw loop
    const obstacleDrawFunctions = {
        fossil: function(obs) { /* ... fossil drawing logic ... */ ctx.fillStyle = '#D2B48C'; ctx.fillRect(obs.x, obs.y, obs.width, obs.height); ctx.fillStyle='white'; ctx.fillRect(obs.x+5, obs.y+5, obs.width-10, obs.height-10); },
        boulder: function(obs) { /* ... boulder drawing logic ... */ ctx.fillStyle = '#696969'; ctx.beginPath(); ctx.arc(obs.x + obs.width/2, obs.y + obs.height/2, obs.width/2, 0, PI2); ctx.fill(); },
        tarpit: function(obs) { /* ... tarpit drawing logic ... */ ctx.fillStyle = '#1A1A1A'; ctx.beginPath(); ctx.ellipse(obs.x + obs.width/2, obs.y + obs.height, obs.width/2, obs.height/2, 0, 0, PI2); ctx.fill(); },
        lava: function(obs) { /* ... lava drawing logic ... */ ctx.fillStyle = '#FF4500'; ctx.beginPath(); ctx.ellipse(obs.x + obs.width/2, obs.y + obs.height, obs.width/2, obs.height/2, 0, 0, PI2); ctx.fill(); },
        sabertooth: function(obs) { /* ... sabertooth drawing logic ... */ ctx.fillStyle = '#C87533'; ctx.fillRect(obs.x, obs.y, obs.width, obs.height); },
        mammoth: function(obs) { /* ... mammoth drawing logic ... */ ctx.fillStyle = '#654321'; ctx.fillRect(obs.x, obs.y, obs.width, obs.height); }
        // NOTE: Keep the detailed drawing logic from your original code here.
        // For brevity, I've put placeholders. Make sure to copy the actual drawing code.
    };

    const obstacleTypes = [
        { name: 'fossil', width: 40, height: 20, isAnimal: false },
        { name: 'boulder', width: 35, height: 35, isAnimal: false },
        { name: 'tarpit', width: 50, height: 15, isAnimal: false },
        { name: 'lava', width: 45, height: 20, isAnimal: false },
        { name: 'sabertooth', width: 50, height: 40, isAnimal: true, speedMultiplier: 1.3 }, // Moves faster
        { name: 'mammoth', width: 60, height: 50, isAnimal: true, speedMultiplier: 0.7 }  // Moves slower
    ];


    // --- Obstacle Factory & Management ---
    function createObstacleInstance(type) {
        return {
            x: 0, y: 0, width: 0, height: 0,
            type: type.name,
            passed: false,
            isAnimal: type.isAnimal,
            speedMultiplier: type.speedMultiplier || 1.0, // Default to 1 if not specified
            drawFunc: obstacleDrawFunctions[type.name], // Cache draw function
            update: function(dt, currentSpeed) {
                if (this.isAnimal) {
                    // Animal specific movement (adjust based on dt)
                    this.x -= currentSpeed * this.speedMultiplier * dt;
                } else {
                    // Standard obstacle movement
                    this.x -= currentSpeed * dt;
                }
            },
            draw: function() {
                this.drawFunc(this);
            },
            reset: function(selectedType) { // Method to reset pooled object
                 this.x = canvasWidth;
                 this.y = groundY - selectedType.height;
                 this.width = selectedType.width;
                 this.height = selectedType.height;
                 this.type = selectedType.name;
                 this.passed = false;
                 this.isAnimal = selectedType.isAnimal;
                 this.speedMultiplier = selectedType.speedMultiplier || 1.0;
                 this.drawFunc = obstacleDrawFunctions[selectedType.name];
            }
        };
    }

    function initPools() {
        for (let i = 0; i < OBSTACLE_POOL_SIZE; i++) {
            obstaclePool.push(createObstacleInstance(obstacleTypes[0])); // Initial type doesn't matter much
        }
        // TODO: Initialize cloud and background element pools similarly
    }

    function getObstacle() {
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        let obstacle;
        if (obstaclePool.length > 0) {
            obstacle = obstaclePool.pop();
            obstacle.reset(type); // Reset the state of the pooled object
        } else {
            // Pool empty, create a new one (should happen rarely with proper pool size)
            console.warn("Obstacle pool empty, creating new instance.");
            obstacle = createObstacleInstance(type);
            obstacle.reset(type); // Set initial state
        }
        return obstacle;
    }

    function returnObstacle(obstacle) {
        if (obstaclePool.length < OBSTACLE_POOL_SIZE) {
            obstaclePool.push(obstacle);
        } // else discard, pool is full (optional)
    }

    // --- Background Elements & Clouds (Simplified for brevity, apply pooling like obstacles) ---
     function createCloudInstance() {
         // ... similar to createObstacleInstance
         return { x: 0, y: 0, width: 0, height: 0, speed: 0, draw: function(){/*...*/}, reset: function(){/*...*/} };
     }
     function getCloud() {
         // ... use cloudPool ...
         let cloud = createCloudInstance(); // Placeholder
         cloud.x = canvasWidth;
         cloud.y = Math.random() * (groundY * 0.5);
         cloud.width = 40 + Math.random() * 60;
         cloud.height = 20 + Math.random() * 30;
         cloud.speed = gameSpeed * (0.1 + Math.random() * 0.15); // Adjust speed relative to gameSpeed
         cloud.draw = function() {
             ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
             // Simple rects for performance, or use original arc code
             ctx.fillRect(this.x, this.y, this.width, this.height);
            // Original arc code:
            // ctx.beginPath();
            // ctx.arc(this.x + this.width / 4, this.y + this.height / 2, this.height / 2, 0, PI2);
            // ctx.arc(this.x + this.width / 2, this.y + this.height / 1.5, 0, PI2);
            // ctx.arc(this.x + (this.width / 4) * 3, this.y + this.height / 2, this.height / 2, 0, PI2);
            // ctx.fill();
         };
         return cloud;
     }
     function returnCloud(cloud) { /* ... push to cloudPool ... */ }
     // --- Background Elements (Similar pooling needed) ---


    // --- Game Logic Functions ---

    function updateGameDimensions() {
        groundY = canvasHeight - GROUND_HEIGHT;
        ground.y = groundY;
        // Only reset player Y if not jumping - avoids snapping mid-air on resize
        if (player.isOnGround()) {
             player.y = groundY - player.height;
        }
        skyGradient.create(); // Recreate gradient for new height
        // Force obstacle positions update if needed (optional)
        activeObstacles.forEach(obs => obs.y = groundY - obs.height);
    }

    function resizeCanvas() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        canvasWidth = canvas.width;
        canvasHeight = canvas.height;
        // Disable image smoothing for crisp pixel art
        ctx.imageSmoothingEnabled = false;
        updateGameDimensions();
    }

    function getRandomObstacleInterval() {
        // Interval scales inversely with difficultyFactor and slightly with speed
        const speedFactor = baseGameSpeed / gameSpeed; // Faster speed = shorter interval potential
        const minGapTime = Math.max(0.8, 1.4 * speedFactor / difficultyFactor); // e.g., 0.8s min
        const maxGapTime = Math.max(minGapTime + 0.5, 2.5 * speedFactor / (difficultyFactor * 0.9)); // e.g., 2.5s max base
        return minGapTime + Math.random() * (maxGapTime - minGapTime);
    }

    function spawnObstacleSet() {
         const firstObstacle = getObstacle();
         activeObstacles.push(firstObstacle);
         obstacleTimer = 0; // Reset timer after spawning
         obstacleInterval = getRandomObstacleInterval(); // Get next interval

         multiObstacleChance = Math.min(score / 30 * 0.1, 0.6); // Adjust calculation if needed

         // Simple multi-obstacle logic (adjust gap based on time/speed)
         if (Math.random() < multiObstacleChance) {
             const minSafeGapTime = 0.6; // Minimum time gap player needs to jump
             const additionalGapTime = 0.2 + Math.random() * 0.4; // Random extra gap
             const gapTime = minSafeGapTime + additionalGapTime;
             const gapDistance = gameSpeed * gapTime;

             const secondObstacle = getObstacle();
             secondObstacle.x = firstObstacle.x + firstObstacle.width + gapDistance;
             activeObstacles.push(secondObstacle);

             // Optional third obstacle
             if (score > 20 && Math.random() < multiObstacleChance * 0.7) {
                 const thirdObstacle = getObstacle();
                 const gapTime2 = minSafeGapTime + 0.2 + Math.random() * 0.3;
                 thirdObstacle.x = secondObstacle.x + secondObstacle.width + gameSpeed * gapTime2;
                 activeObstacles.push(thirdObstacle);
             }
         }
    }

    function update(dt) {
        if (!playing) return;

        // --- Update Timers ---
        obstacleTimer += dt;
        cloudTimer += dt;
        backgroundTimer += dt;
        timeAccumulator += dt;

        // --- Spawning ---
        if (obstacleTimer >= obstacleInterval) {
            spawnObstacleSet(); // Handles timer reset and next interval calculation
        }

        // TODO: Add Cloud and Background Element Spawning using their timers and pools

        if (cloudTimer > 3.0) { // Example: spawn cloud every 3 seconds
            activeClouds.push(getCloud());
            cloudTimer = 0;
        }

        // --- Update Entities ---
        player.update(dt);

        // Update active obstacles
        for (let i = activeObstacles.length - 1; i >= 0; i--) {
            const obstacle = activeObstacles[i];
            obstacle.update(dt, gameSpeed);

            // Scoring
            if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                score++;
                obstacle.passed = true;
                // Defer DOM update
            }

            // Collision Check
            if (player.checkCollision(obstacle)) {
                gameOver();
                return; // Stop update on collision
            }

            // Culling (return to pool)
            if (obstacle.x + obstacle.width < 0) {
                returnObstacle(activeObstacles.splice(i, 1)[0]);
            }
        }

         // Update active clouds
         for (let i = activeClouds.length - 1; i >= 0; i--) {
             const cloud = activeClouds[i];
             cloud.x -= cloud.speed * dt;
             if (cloud.x + cloud.width < 0) {
                 // TODO: Return cloud to pool
                 activeClouds.splice(i, 1); // Placeholder removal
             }
         }
         // TODO: Update active background elements


        // --- Update Score Display (Optimized) ---
        if (score !== currentScoreDisplay) {
            currentScoreDisplay = score;
            scoreElement.textContent = `Score: ${currentScoreDisplay}`;
        }

        // --- Increase Difficulty (Time-based) ---
        if (timeAccumulator >= 5.0) { // Increase every 5 seconds
            timeAccumulator -= 5.0; // Use subtraction to handle overshoot

            gameSpeed = Math.min(gameSpeed + 10, 700); // Increase speed, cap at 700 px/s
            difficultyFactor = Math.min(difficultyFactor + 0.05, 2.5); // Increase difficulty factor
            // console.log(`Speed: ${gameSpeed.toFixed(1)}, Difficulty: ${difficultyFactor.toFixed(2)}`);

            // Recalculate next obstacle interval based on new difficulty/speed
             if (obstacleTimer >= obstacleInterval) {
                // If a spawn was already due, calculate next interval immediately
                obstacleInterval = getRandomObstacleInterval();
             } else {
                 // If spawn wasn't due, adjust remaining time proportionally (optional, can be complex)
                 // Or simply let the current interval finish and the *next* one will be shorter.
             }
        }
    }

    function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Draw Sky
        ctx.fillStyle = skyGradient.get();
        ctx.fillRect(0, 0, canvasWidth, groundY);

        // Draw Background Elements (Back to Front)
        activeBackgroundElements.forEach(el => el.draw());

        // Draw Clouds
        activeClouds.forEach(cloud => cloud.draw());

        // Draw Ground
        ground.draw();

        // Draw Obstacles
        activeObstacles.forEach(obstacle => obstacle.draw());

        // Draw Player
        player.draw();
    }

    function gameLoop(timestamp) {
        if (!lastTime) {
            lastTime = timestamp;
        }
        let deltaTime = (timestamp - lastTime) / 1000; // Delta time in seconds
        lastTime = timestamp;

        // --- Game Update Logic (Fixed Time Step - Optional but good for physics) ---
        // Accumulate time and update in fixed steps to prevent physics glitches at varying frame rates
        let accumulatedTime = deltaTime;
        while (accumulatedTime >= TIME_STEP) {
            update(TIME_STEP); // Update using fixed step
            accumulatedTime -= TIME_STEP;
        }
        // Handle the remainder time step if needed, or simply carry it over (less critical for this game)
        // update(accumulatedTime); // Option: Update with remaining time

        // --- Drawing ---
        draw();

        // --- Loop ---
        if (playing) {
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    function gameOver() {
        if (!playing) return; // Prevent multiple calls
        playing = false;
        cancelAnimationFrame(animationFrameId);
        finalScoreElement.textContent = score;
        gameOverElement.style.display = 'block';
        instructionsElement.style.display = 'none'; // Hide instructions on game over
        // Maybe add a slight delay before restart is enabled?
        setTimeout(() => { restartButton.disabled = false; }, 500);
        restartButton.focus(); // Focus the button
    }

    function resetGame() {
        score = 0;
        currentScoreDisplay = -1; // Force score update on first frame
        gameSpeed = baseGameSpeed;
        difficultyFactor = 1.0;
        player.y = groundY - player.height;
        player.velocityY = 0;
        player.jumpCount = 0;
        obstacleTimer = 0; // Reset timers
        cloudTimer = 0;
        backgroundTimer = 0;
        timeAccumulator = 0;
        obstacleInterval = 1.5; // Initial interval

        // Clear active arrays and return objects to pools
        while (activeObstacles.length > 0) returnObstacle(activeObstacles.pop());
        while (activeClouds.length > 0) returnCloud(activeClouds.pop()); // Assuming returnCloud is implemented
        // while (activeBackgroundElements.length > 0) returnBackgroundElement(activeBackgroundElements.pop());

        gameOverElement.style.display = 'none';
        instructionsElement.style.display = 'block'; // Show instructions again
        restartButton.disabled = true; // Disable button briefly

        // Prefill with some initial background elements/clouds if desired
        // spawnInitialScenery();
    }

    function startGame() {
        if (playing) return;
        resetGame();
        playing = true;
        lastTime = 0; // Reset lastTime for accurate delta on first frame
        if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous loop if any
        animationFrameId = requestAnimationFrame(gameLoop);
        instructionsElement.style.display = 'none'; // Hide instructions on start
    }

    // --- Event Handlers ---
    function handleJumpIntent() {
        if (playing) {
            player.jump();
        } else if (!restartDisabled && !gameOverElement.style.display || gameOverElement.style.display === 'block') {
            // Start game if game over screen is shown OR if it's not playing and not disabled
             startGame();
        }
    }

    // --- Initialization ---
    function init() {
        console.log('Initializing game...');
        // Attach listeners
        window.addEventListener('resize', resizeCanvas, false);
        window.addEventListener('game-jump-intent', handleJumpIntent, false); // Listen for custom event
        document.addEventListener('touchstart', handleJumpIntent, { passive: true }); // Use passive: true if not calling preventDefault
        restartButton.addEventListener('click', startGame, false);

        // Message listeners from parent
        window.addEventListener('message', (event) => {
            // Basic security - replace '*' with your viewer's origin in production
            // if (event.origin !== 'YOUR_VIEWER_ORIGIN') return;
             try { // Add try-catch for potential cross-origin issues
                if (event.data && event.data.type) {
                    console.log('Game received message:', event.data.type);
                    switch(event.data.type) {
                        case 'disableRestart':
                            if (restartButton) restartButton.style.display = 'none';
                            restartDisabled = true;
                            break;
                        case 'focusGame':
                            window.focus(); // Focus the iframe window
                             canvas.focus(); // Attempt to focus canvas
                            break;
                        case 'blurYourself':
                             if (document.activeElement && document.activeElement !== document.body) {
                                 document.activeElement.blur();
                             }
                             window.blur(); // Blur the iframe window
                            break;
                        // Add other message handlers if needed
                    }
                }
            } catch (e) {
                console.error("Error processing message:", e);
            }
        });

        // Initial setup
        resizeCanvas(); // Set initial size
        initPools();    // Initialize object pools
        resetGame();    // Set initial game state (but don't start loop yet)
        draw();         // Draw initial frame (player on ground, score 0)
        instructionsElement.style.display = 'block'; // Ensure instructions are visible initially

        // Tell the parent window the game is loaded and ready
        console.log('Game initialized, sending gameLoaded message.');
        if (window.parent && window.parent !== window) {
             try {
                window.parent.postMessage({ type: 'gameLoaded' }, '*'); // Use specific origin in production
             } catch(e) {
                console.error("Error posting gameLoaded message:", e);
             }
        } else {
            console.warn("Not running in an iframe or cannot access parent.");
             // Optionally start the game automatically if not in iframe
             // instructionsElement.textContent = "Press SPACE or tap to START";
        }
    }

    // --- Start ---
    // Use window.onload OR DOMContentLoaded
     window.addEventListener('load', init);
     // OR: document.addEventListener('DOMContentLoaded', init); // Use if you don't need images loaded

})();
    </script>
       <!-- Message listener script (already included in the main script, keep only one) -->
       <!-- Make sure the message listener logic inside the main IIFE is correct -->
</body>
</html>
